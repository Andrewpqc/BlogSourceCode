---
title: HTTP协议总结 
comments: true
date: 2018-07-15 17:03:57
updated: 2018-07-15 17:03:57
tags: [HTTP]
categories: Network
permalink:
---
HTTP协议是Hyper Text Transfer Protocol(超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web)服务器传输超文本到本地浏览器的传送协议。HTTP是当今世界上应用最为广泛的**应用层**协议之一。

HTTP协议工作于客户端-服务端架构(CS)之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。

![](/images/http请求响应.jpg)

下面总结一下HTTP的相关知识点，首先我们从HTTP的报文结构开始。

# HTTP报文格式
## 请求报文
![](/images/http_request.png)

HTTP请求报文由四部分组成:**请求行、请求头、一个空行、请求体**。如上图第一行为请求行，请求行由3部分组成，分别是请求方法，请求的URL和所使用的HTTP协议版本，这三部分用一个空格隔开，行未为一个回车换行符。请求行下面的是请求头部分，每一个请求头由头部字段名和值组成，中间用冒号分隔，行未依然为回车换行符。请求头可以有任意个。一个单独的换车换行符(即一个空行)表示了请求头部分结束，空行下面的就是可选的请求体部分。这就是一个HTTP请求的报文格式。

## 响应报文
![](/images/http_resp.jpeg)
HTTP响应报文与请求报文的格式基本相同，它是由:**状态行、响应头、一个空行、响应实体四部分组成**。如上图第一行为状态行。与请求报文不同的是状态行由协议版本、状态码和原因短语组成。

# HTTP方法
根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

| 方法名 | 描述 |
| :------:| :------: |
| GET | 请求指定的页面信息，并返回实体主体。 |
| POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 |
| PUT | 从客户端向服务器传送的数据取代指定的文档的内容. |
| DELETE | 请求服务器删除指定的页面。 |
| HEAD | 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| OPTIONS | 允许客户端查看服务器的性能、获取服务器支持的HTTP请求方法。 |
| TRACE | 回显服务器收到的请求，主要用于测试或诊断。 |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 |

在实践中GET,POST,PUT,DELETE四种方法使用的比较多,他们分别对应对资源的获取，创建，更新，删除这四种操作。


# HTTP状态码

HTTP状态码类型及其含义:

| 分类 | 分类描述 |
| :------:| :------: |
| 1xx | 信息，服务器收到请求，需要请求者继续执行操作 |
| 2xx | 成功，操作被成功接收并处理 |
| 3xx | 重定向，需要进一步的操作以完成请求 |
| 4xx | 客户端错误，请求包含语法错误或无法完成请求 |
| 5xx | 服务器错误，服务器在处理请求的过程中发生了错误 |

常见HTTP状态码列表:

| 状态码 | 状态码英文名称 | 中文描述 |
| :------:| :------: | :-----------: |
| 100 | Continue | 继续。客户端应继续其请求 |
| 101 | Switching Protocols | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
| 200 | OK | 请求成功。一般用于GET与POST请求 |
| 201 | Created | 已创建。成功请求并创建了新的资源 |
| 202 | Accepted | 已接受。已经接受请求，但未处理完成 |
| 203 | Non-Authoritative Information | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204 | No Content | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205 | Reset Content | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206 | Partial Content | 部分内容。服务器成功处理了部分GET请求 |
| 300 | Multiple Choices  | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301 | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302 | Found | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303 | See Other | 查看其它地址。与301类似。使用GET和POST请求查看 |
| 304 | Not Modified | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305 | Use Proxy | 使用代理。所请求的资源必须通过代理访问 |
| 306 | Unused | 已经被废弃的HTTP状态码 |
| 307 | Temporary Redirect 	 | 临时重定向。与302类似。使用GET请求重定向 |
| 400 | Bad Request |  	客户端请求的语法错误，服务器无法理解 |
| 401 | Unauthorized | 请求要求用户的身份认证 |
| 402 | Payment Required | 保留，将来使用 |
| 403 | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405 | Method Not Allowed | 客户端请求中的方法被禁止 |
| 406 | Not Acceptable | 服务器无法根据客户端请求的内容特性完成请求 |
| 407 | Proxy Authentication Required | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408 | Request Time-out  | 服务器等待客户端发送的请求时间过长，超时 |
| 409 | Conflict | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 411 | Length Required | 服务器无法处理客户端发送的不带Content-Length的请求信息 |
| 413 | Request Entity Too Large | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414 | Request-URI Too Large | 请求的URI过长（URI通常为网址），服务器无法处理 |
| 415 | Unsupported Media Type | 服务器无法处理请求附带的媒体格式 |
| 429 | Too Many Requests | 发送请求太多，服务器拒绝服务 |
| 500 | Internal Server Error  | 服务器内部错误，无法完成请求 |
| 501 | Not Implemented | 服务器不支持请求的功能，无法完成请求 |
| 502 | Bad Gateway | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 |
| 503 | Service Unavailable | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504 | Gateway Time-out | 充当网关或代理的服务器，未及时从远端服务器获取请求 |
| 505 | HTTP Version not supported | 服务器不支持请求的HTTP协议的版本，无法完成处理 |



# 持续连接与非持续连接
HTTP是建立在TCP协议之上的应用层协议，众所周知TCP协议为了实现可靠数据传输在建立连接的过程会进行三次握手。也就是说，客户端需要与服务器建立连接必须首先先服务器发送一个特殊的报文段(SYN)，该报文段是不能携带应用层数据的，然后客户端需要等待服务器发回确认报文(SYNAK)。待接收到服务器发会的SYNACK报文之后，客户端还需要发送ACK报文给服务器(这个ACK报文中可以携带应用层的数据)。在客户端服务器进行了三次报文的传输之后，连接才算建立，之后应用层的数据会在这个连接上传输。

HTTP 协议的初始版本中，**每进行一个 HTTP 通信(即一个请求响应对)都要断开一次 TCP 连接，这种方式称为非持续连接**。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面里包含的其他资源。因此，非持续连接每次的请求都会造成无畏的TCP连接建立和断开，增加通信量的开销。为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。**旨在建立一次 TCP 连接后进行多次请求和响应的交互，这种方式称为持久连接**。**在HTTP/1.1 中，所有的连接默认都是持久连接。**


# 流水线
持久连接使得多数请求以流水线方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。流水线技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML页面时，与挨个连接相比，用持久连接可以让请求更快结束。而流水线技术要比持久连接速度更快。请求数越多，时间差就越明显。采用流水线方式的持久连接使的HTTP通信的速度大幅提升。


# 一些辨析
## 301/302/303/307
301/302/303/307都是表示重定向。重定向实际使用是一个响应码(301或302或303或307)和一个响应头location，当浏览器收到响应的时候check响应码是3xx，则会取出响应头中Location对应的url，然后将该url替换浏览器地址栏中的并发起另一次HTTP事务。既然它们都表示重定向，那么他们的区别是什么呢

HTTP 1.0规范中有2个重定向－－301和302，在HTTP 1.1规范中存在4个重定向——301、302、303和307。
**HTTP 1.0规范定义**301表示永久重定向,也就是资源的真实URL为Location头部中的URL。对于GET请求重定向，浏览器跟进；对于POST请求的重定向，还是需要用户确认之后才能重定向，并且应该以POST方法发出重定向请。302表示临时重定向，Location中的地址不应该被认为是资源路径，在后续的请求中应该继续使用原地址。这时，原请求是POST，则不能自动进行重定向；原请求是GET，才可以自动重定向。
**在目前主流浏览器的实现中**浏览器无论是接收到301还是302,同样无论是GET还是POST,都会自动进行重定向，这导致规范和实现之间产生了二义性。由此衍生了一些问题，譬如302劫持，因此在HTTP 1.1中将302的规范细化成了303和307，希望以此来消除二义性。
>**302劫持**：
>对于301,搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；对于302,搜索引擎会抓取新的内容而保存旧的网址。利用这一原理，从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了，这就是302劫持。

为了消除上面规范与实现的二义性，在HTTP 1.1中引入了303和307状态码。实际上官方文档已经不建议使用302状态码，只是为了兼容而保留302。 HTTP 1.1把HTTP 1.0规范中302的实现和规范拆分开，分别赋予HTTP 1.1中303和307，因此在HTTP 1.1中，303继承了HTTP 1.0中302的实现（即原请求是post，也允许自动进行重定向，结果是无论原请求是get还是post，都可以自动进行重定向），而307则继承了HTTP 1.0中302的规范（即如果原请求是post，则不允许进行自动重定向，结果是post不重定向，get可以自动重定向）。

在HTTP 1.1规范中，307为临时重定向，如果重定向307的原请求不是get或者head方法，那么浏览器一定不能自动的进行重定向，即便Location有url，也应该忽略。
## GET/POST
>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
>GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。
>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
>GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。
>GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。
>GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。
>与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在URL中对所有人都是可见的。POST的数据不会显示在 URL 中。
>GET是幂等的，POST不幂等。

关于GET/POST的辨析，可以参考:[https://www.zhihu.com/question/28586791](https://www.zhihu.com/question/28586791)
