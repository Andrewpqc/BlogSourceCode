<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>gcc/g++常用编译选项和gdb常用调试命令</title>
      <link href="/2018/11/25/gcc-and-gdb/"/>
      <url>/2018/11/25/gcc-and-gdb/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/entry/5bfac5b6e51d45127e7767b3/detail" target="_blank" rel="noopener"><img src="https://badge.juejin.im/entry/5bfac5b6e51d45127e7767b3/likes.svg?style=flat-square" alt=""></a></p><p>gcc/g++编译器是我们写编译C/C++程序时离不开的编译工具，而gdb又是调试C/C++程序的利器，这一篇文章我们记录一下它们的惯常用法。</p><h2 id="gcc-g-常用编译选项"><a href="#gcc-g-常用编译选项" class="headerlink" title="gcc/g++常用编译选项"></a>gcc/g++常用编译选项</h2><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-c</td><td style="text-align:center">生成可目标文件，但不进行链接</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">指定生成文件的文件名</td></tr><tr><td style="text-align:center">-g</td><td style="text-align:center">在目标文件中添加调试信息，便于gdb调试或objdump反汇编</td></tr><tr><td style="text-align:center">-Wall</td><td style="text-align:center">显示所有的警告信息(建议使用)</td></tr><tr><td style="text-align:center">-Werror</td><td style="text-align:center">视警告为错误，出现警告即放弃编译</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:center">不显示任何警告信息(不建议使用)</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">显示编译步骤</td></tr><tr><td style="text-align:center">-On</td><td style="text-align:center">(n=0,1,2,3) 设置编译器优化等级，O0为不优化，O3为最高等级优化，O1为默认优化等级</td></tr><tr><td style="text-align:center">-L</td><td style="text-align:center">指定库文件的搜索目录</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:center">(小写的L)链接某一库</td></tr><tr><td style="text-align:center">-I</td><td style="text-align:center">(大写的i)指定头文件路径</td></tr><tr><td style="text-align:center">-D</td><td style="text-align:center">定义宏，例如-DAAA=1,-DBBBB</td></tr><tr><td style="text-align:center">-U</td><td style="text-align:center">取消宏定义，例如-UAAA</td></tr></tbody></table><h2 id="gdb常用调试命命令"><a href="#gdb常用调试命命令" class="headerlink" title="gdb常用调试命命令"></a>gdb常用调试命命令</h2><p>我们的可执行文件要能够被gdb调试，必须在编译时加上调试信息，也即是加上<code>-g</code>选项.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g example.c -o example</span><br></pre></td></tr></table></figure></p><p>如上我们生成了一个带有调试信息的可执行文件example,要调试example可以执行下列命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb example</span><br></pre></td></tr></table></figure></p><p>这样我们就进入了gdb的调试命令行，如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from example...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><p>如上可以看到命令行提示符为<code>(gdb)</code>,接着我们就可以在这个gdb的命令行提示符上面输入各种gdb的调试命令了(补充:这里也可以在shell中输入<code>gdb</code>,然后回车，这样直接进入到gdb的调试命令行，之后可以通过<code>file example</code>命令来载入待调试的可执行程序)。</p><p>下面我们就以如下的程序为例，详细的看下，在gdb的调试命令行中我们都有那些命令可用:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=a;j++)&#123;</span><br><span class="line">    sum += j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">long</span> sum = func(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><p>载入待调试的可执行文件之后，在gdb的命令行中输入<code>list</code>或者其简写<code>l</code>可以查看到程序的源码以及行号，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1#include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3long func(int a)&#123;</span><br><span class="line">4    long sum = 0;</span><br><span class="line">5    for(int j=1;j&lt;=a;j++)&#123;</span><br><span class="line">6    sum += j;</span><br><span class="line">7    &#125;</span><br><span class="line">8    return sum;</span><br><span class="line">9&#125;</span><br><span class="line">10</span><br><span class="line">(gdb) </span><br><span class="line">11int main(void)&#123;</span><br><span class="line">12    int a =100;</span><br><span class="line">13    long sum = func(a);</span><br><span class="line">14    printf(&quot;%ld&quot;,sum);</span><br><span class="line">15    return 0;</span><br><span class="line">16&#125;</span><br><span class="line">(gdb) </span><br><span class="line">Line number 17 out of range; example.c has 16 lines.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><p>如上输入<code>l</code>之后，默认会显示10行源代码，按回车之后会显示接下来的10行,直到文件的末尾。</p><h3 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h3><p>在gdb下添加断点使用命令<code>break</code>或简写 <code>b</code>，有下面几个常见用法（这里统一用 b:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b 函数名</span><br><span class="line">b 行号</span><br><span class="line">b 文件名:行号</span><br><span class="line">b 行号 if条件</span><br></pre></td></tr></table></figure></p><p>比如我们在 main函数和func函数上各添加一个断点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x685: file example.c, line 12.</span><br><span class="line">(gdb) break func</span><br><span class="line">Breakpoint 2 at 0x651: file example.c, line 4.</span><br></pre></td></tr></table></figure></p><p>如上我们成功加上了两个断点，在正确加上断点之后，会对应有一行输出，告诉我们断点的内存地址，断点对应的源文件名和行号。</p><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><p>在加上断点之后，我们可以通过<code>info break</code>命令查看断点的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000000685 in main at example.c:12</span><br><span class="line">2       breakpoint     keep y   0x0000000000000651 in func at example.c:4</span><br></pre></td></tr></table></figure></p><h3 id="禁用和解禁断点"><a href="#禁用和解禁断点" class="headerlink" title="禁用和解禁断点"></a>禁用和解禁断点</h3><p>通过<code>disable &lt;break number&gt;</code>来禁用指定Num的断点，如下我们禁用1号断点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable 1</span><br><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000000685 in main at example.c:12</span><br><span class="line">2       breakpoint     keep y   0x0000000000000651 in func at example.c:4</span><br></pre></td></tr></table></figure></p><p>如上，<code>disable 1</code>之后，断点1的<code>Enb</code>列由之前的<code>y</code>变成了<code>n</code>，说明断点1已被禁用。</p><p>通过<code>eable &lt;break number&gt;</code>可以来解禁断点，如下我们对刚才禁用的断点1解禁:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) enable 1</span><br><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000000685 in main at example.c:12</span><br><span class="line">2       breakpoint     keep y   0x0000000000000651 in func at example.c:4</span><br></pre></td></tr></table></figure></p><p>如上，断点1的Enb列又变成y了，它被成功解禁。</p><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><p>我们可以用<code>delete &lt;break number&gt;</code>命令来删除掉一个断点，如下我们删除断点1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete 1</span><br><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000000651 in func at example.c:4</span><br></pre></td></tr></table></figure></p><p>如上，断点1被成功删除。</p><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><p>我们可以使用<code>run</code>命令或者简写<code>r</code>来启动程序的执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/andrew/example </span><br><span class="line"></span><br><span class="line">Breakpoint 2, func (a=100) at example.c:4</span><br><span class="line">4    long sum = 0;</span><br></pre></td></tr></table></figure></p><p>如上，程序执行到断点2的时候就停止执行了。</p><h3 id="查看变量的值"><a href="#查看变量的值" class="headerlink" title="查看变量的值"></a>查看变量的值</h3><p><code>p &lt;variable name&gt;</code>/<code>print &lt;variable name&gt;</code>可以查看某一个变量的当前值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p sum</span><br><span class="line">$1 = 0</span><br></pre></td></tr></table></figure></p><p>如上，当前sum的值为0</p><h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><p><code>next</code>命令或者<code>n</code>可以单步执行，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">5    for(int j=1;j&lt;=a;j++)&#123;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$2 = 0</span><br><span class="line">(gdb) n</span><br><span class="line">6    sum += j;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$3 = 0</span><br><span class="line">(gdb) n</span><br><span class="line">5    for(int j=1;j&lt;=a;j++)&#123;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$4 = 1</span><br><span class="line">(gdb) n</span><br><span class="line">6    sum += j;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$5 = 1</span><br><span class="line">(gdb) n</span><br><span class="line">5    for(int j=1;j&lt;=a;j++)&#123;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$6 = 3</span><br></pre></td></tr></table></figure></p><h3 id="跳入跳出函数"><a href="#跳入跳出函数" class="headerlink" title="跳入跳出函数"></a>跳入跳出函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 13</span><br><span class="line">Breakpoint 1 at 0x693: file example.c, line 13.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/andrew/example </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at example.c:13</span><br><span class="line">13    long sum = func(a);</span><br><span class="line">(gdb) s</span><br><span class="line">func (a=100) at example.c:4</span><br><span class="line">4    long sum = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">5    for(int j=1;j&lt;=a;j++)&#123;</span><br><span class="line">(gdb) n</span><br><span class="line">6    sum += j;</span><br><span class="line">(gdb) n</span><br><span class="line">5    for(int j=1;j&lt;=a;j++)&#123;</span><br><span class="line">(gdb) n</span><br><span class="line">6    sum += j;</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  func (a=100) at example.c:6</span><br><span class="line">0x000055555555469d in main () at example.c:13</span><br><span class="line">13    long sum = func(a);</span><br><span class="line">Value returned is $1 = 5050</span><br><span class="line">(gdb) n</span><br><span class="line">14    printf(&quot;%ld&quot;,sum);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>如上，我在func()函数调用行加上了断点，然后<code>r</code>开始执行程序，之后程序在断点处停住，此时我执行<code>step</code>命令或其简写<code>s</code>来跳入func()函数内部调试，在内部依然像执行外部调试一样，如果要从函数跳出则执行<code>finished</code>，这时会导致函数执行完毕，并且打印出一些函数的返回信息，并且程序停在函数后的第一条语句处。</p><h3 id="监控变量"><a href="#监控变量" class="headerlink" title="监控变量"></a>监控变量</h3><p>使用<code>watch &lt;varible name&gt;</code>命令可以实现监控变量，使用<code>info watch</code>命令可以查看监控的变量。同时break所拥有的<code>enable</code>,<code>disable</code>,<code>delete</code>等动词对于watch依然使用，且用法大同小异。这里就不再赘述。</p><h3 id="显示变量的值"><a href="#显示变量的值" class="headerlink" title="显示变量的值"></a>显示变量的值</h3><p>使用<code>display &lt;varible name&gt;</code>命令可以在每一步执行之后打印变量的当前值,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start </span><br><span class="line">Temporary breakpoint 1 at 0x685: file example.c, line 12.</span><br><span class="line">Starting program: /home/andrew/example </span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at example.c:12</span><br><span class="line">12    int a =100, b =50;</span><br><span class="line">(gdb) display sum</span><br><span class="line">1: sum = 140737488346112</span><br><span class="line">(gdb) n</span><br><span class="line">13    long sum = func(a);</span><br><span class="line">1: sum = 140737488346112</span><br><span class="line">(gdb) </span><br><span class="line">14    printf(&quot;%ld&quot;,sum);</span><br><span class="line">1: sum = 5050</span><br><span class="line">(gdb) </span><br><span class="line">16    long sum2 = func(b);</span><br><span class="line">1: sum = 5050</span><br><span class="line">(gdb) </span><br><span class="line">17    printf(&quot;%ld&quot;,sum2);</span><br><span class="line">1: sum = 5050</span><br><span class="line">(gdb) </span><br><span class="line">18    return 0;</span><br><span class="line">1: sum = 5050</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><h3 id="进入shell"><a href="#进入shell" class="headerlink" title="进入shell"></a>进入shell</h3><p><code>shell</code>命令可以让我们从gdb命令行环境进入到shell的命令行环境，当我们在shell命令行环境中输入exit退出后，我们就又回到了之前的gdb命令行环境了。</p><h3 id="可视化调试"><a href="#可视化调试" class="headerlink" title="可视化调试"></a>可视化调试</h3><p>在gdb命令行环境中输入<code>wi</code>命令，可以让我们进入可视化调试环境，这个环境可以看到源代码，所使用的调试命令与上面讲到的一致。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc/g++ </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>io多路复用的边缘触发模式和水平触发模式</title>
      <link href="/2018/11/25/lt-and-et-of-multiplexing-io/"/>
      <url>/2018/11/25/lt-and-et-of-multiplexing-io/</url>
      
        <content type="html"><![CDATA[<p>io多路复用是内核同时监控多个文件描述符，当文件描述符上某事件(比如读和写)就绪，就会向调用进程发送通知的机制。io多路复用有两种触发通知的机制—边缘触发(Edge Triggered)和水平触发(Level Triggered)。这一篇文章就讲一讲这两种触发机制。</p><h2 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h2><p><strong>如果文件描述符上可以非阻塞地执行I/O系统调用，此时认为它已经就绪，触发通知</strong>.<br>在网络服务器的开发中，假如我们以水平触发模式的io多路复用来同时监控多个已连接描述符，当某一描述符上有数据可读的时候，就会触发通知(一般来说，就是相应调用返回)。应用程序在收到通知后可以选择读取所有可读的数据，读取部分数据，甚至是不读取任何数据。对于读取部分数据和不读取任何数据这种处理方式中，当下一次检查的时候，该文件描述符还是被返回(尽管在这一段时间内，该文件描述符上没有任何新的时间发生)，被返回的原因则是该文件描述符上仍然有数据可读，即仍然可以在其上非阻塞的执行<code>read()</code>。也就是说，在水平触发模式中，当前事件的消息不一定必须要当前读取完毕，留到之后读取也没有关系。</p><h2 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h2><p><strong>如果文件描述符自上次状态检查以来有了新的I/O活动(比如新的输入，用于写入的缓冲区腾出了空间等)，此时需要触发通知。</strong><br>仍然以网络服务器开发为例，这次我们使用边缘触发，当某一文件描述符上有数据可读，假如我们仍然是部分读取数据，那么在下一次检查的时候，我们将得不到该文件描述符已经ready的通知(除非在这一段时间内，该描述符上面有新的数据到来)。边缘触发只有在有新的i/o活动的时候才会触发通知，及时当前套接字上有数据，可以非阻塞的执行I/O系统调用，应用程序也得不到通知。也就是说，在边缘触发模式中，在一次通知中，我们应该尽可能的多的读取数据，直到不能再读为止。具体的做法是这样的:文件描述符应该提前设置问非阻塞(<code>O_NONBLOCK</code>),在已就绪文件描述符上循环的读取数据，知道<code>read()</code>返回<code>-1</code>，并且<code>erron</code>为<code>EAGAIN</code>或<code>EWOULDBLOCK</code>.</p><p>在上面我们对水平触发和边缘触发的分析中，我们可以知道边缘触发相比于水平触发来讲，降低了同一个事件被重复触发的概率，减少了多路复用系统调用的次数，因此边缘触发的性能由于水平触发。</p><p>在我们常用的io多路复用系统调用中，<code>select</code>和<code>poll</code>只支持水平触发，<code>epoll</code>则既支持水平触发也支持边缘触发。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> multiplexing io </tag>
            
            <tag> level triggered </tag>
            
            <tag> edge triggered </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux进程组、会话以及任务管理</title>
      <link href="/2018/10/31/linux-process-group-and-session-and-jobs-manage/"/>
      <url>/2018/10/31/linux-process-group-and-session-and-jobs-manage/</url>
      
        <content type="html"><![CDATA[<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>当我们在终端中敲下一条命令，然后按下回车的时候，Shell会开启一个新进程来执行这条命令。如果这条命令是由管道连接起来的多个命令组成的话，Shell便会开启多个进程来执行这一组任务。无论是单独的一条命令，还是由管道连接的多条命令，都会被放入到一个新的<strong>进程组(任务)</strong>中。只包含一条命令的时候，就会创建一个由一个进程组成的进程组。进程组中的每个进程都具有相同的进程组标识符(进程组ID)，这个进程组标识符其实就是进程组中某个进程(即进程组组长)的进程ID。</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p><strong>会话指的是一组进程组(任务)。</strong>一个会话中的所有进程都具有相同的会话标识符，会话首进程是指创建会话的进程，其进程ID会成为会话ID。使用会话最多的是支持任务控制的shell,由shell创建的所有进程组及shell自身隶属与同一个会话，shell自身就是该会话的会话首进程。</p><p>在任意时刻，会话中总有一个前台进程组(前台任务)，可以从终端读取输入，向终端发送输出。如果用户输入Ctrl+C或者Ctrl+Z,就可以分别让任务终止或挂起。同时，一个会话还可以拥有任意多个后台进程组，后台进程组可以用’&amp;’结尾的命令行创建。</p><h2 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h2><p>支持任务控制的shell提供了创建后台任务、列出所有任务、向任务发送信号，以及在前后台任务之间来回切换等命令。</p><p>shell中的任务分为三种状态Running、Stopped、Done。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">command</span>&gt; &amp;</span><br></pre></td></tr></table></figure></p><p>在一个命令后添加 &amp; 即可简单的放入后台运行。通过 &amp; 放置到后台的命令，仍保持 Running 状态，默认的标准输出和标准错误输出仍为终端，也就是说你仍然会看到它打印出的信息，这应该通过重定向来解决。如果输出的内容不需要，可以简单的重定向到 /dev/null。</p><p>当与终端断开连接时(即关闭终端)，任务会收到 SIGHUP 信号而被杀死，如果需要持续运行，则需使用 nohup 命令将其放置到系统后台，而非当前终端的后台，如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup python3 local.py 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p><p>这将放入系统后台运行<code>python3 local.py</code>，并将 stderr 重定向到 stdout。这是我们在终端中输入<code>exit</code>来退出终端，该任务就不会被杀死。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTRL+Z</span><br></pre></td></tr></table></figure><p>这将暂停当前任务，成为 Stopped 状态，并放入任务列表。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span></span><br></pre></td></tr></table></figure></p><p>显示所有当前任务，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jobs</span><br><span class="line">[1]+ Stopped vim</span><br><span class="line">[2]- Running python3 local.py 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span></span><br></pre></td></tr></table></figure><p>通过<code>fg [%n]</code>来激活任务到前台，如果省略<code>%n</code>参数，则默认激活标记为<code>+</code>的任务，且标记为<code>-</code>的任务将被标记为<code>+</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span></span><br></pre></td></tr></table></figure></p><p>通过<code>bg [%n]</code>来运行Stopped状态的后台任务，任务将继续运行，状态变为Running,且命令后增添了 &amp; 字样。</p><p>当你忘记将任务放入后台运行，即可组合使用 CTRL+Z 和 bg 来弥补它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span></span><br></pre></td></tr></table></figure></p><p>通过 kill –signal %n 来快捷地杀死后台任务。</p><p>signal 常见的有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 SIGHUP 终端断开连接</span><br><span class="line">2 SIGINT 中断（CTRL+C）</span><br><span class="line">3 SIGQUIT 退出（CTRL+\\）</span><br><span class="line">9 SIGKILL 强行终止</span><br><span class="line">15 SIGTERM 终止</span><br><span class="line">18 SIGCONT 继续（fg、bg）</span><br><span class="line">19 SIGSTOP 暂停（CTRL+Z）</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> process group </tag>
            
            <tag> jobs manage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊聊Python内存管理</title>
      <link href="/2018/10/08/python-memory-management/"/>
      <url>/2018/10/08/python-memory-management/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/entry/5bbd4ed75188255c960c51fd/detail" target="_blank" rel="noopener"><img src="https://badge.juejin.im/entry/5bbd4ed75188255c960c51fd/likes.svg?style=plastic" alt=""></a></p><p>python作为一门解释型语言，以代码简洁易懂著称。我们可以直接对名称赋值，而不必声明类型。名称类型的确定、内存空间的分配与释放都是由python解释器在运行时自动进行的。python这一自动管理内存功能极大的减小了程序员负担,这也是成就python自身的重要原因之一。所以，这一篇文章我们就聊一聊python的内存管理。</p><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>Python中，主要通过<strong>引用计数（Reference Counting）</strong>进行垃圾回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">    <span class="keyword">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。<br>以下情况是导致引用计数加一的情况:</p><ul><li>对象被创建，例如a=2</li><li>对象被引用，b=a</li><li>对象被作为参数，传入到一个函数中</li><li>对象作为一个元素，存储在容器中</li></ul><p>下面的情况则会导致引用计数减一:</p><ul><li>对象别名被显示销毁 del</li><li>对象别名被赋予新的对象</li><li>一个对象离开他的作用域</li><li>对象所在的容器被销毁或者是从容器中删除对象</li></ul><p>我们还可以通过sys包中的<code>getrefcount()</code>来获取一个名称所引用的对象当前的引用计数(注意，这里getrefcount()本身会使得引用计数加一)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure></p><p>引用计数法有其明显的优点，如高效、实现逻辑简单、具备实时性，一旦一个对象的引用计数归零，内存就直接释放了。不用像其他机制等到特定时机。将垃圾回收随机分配到运行的阶段，处理回收内存的时间分摊到了平时，正常程序的运行比较平稳。但是，引用计数也存在着一些缺点，通常的缺点有：</p><ul><li>逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。</li><li>在一些场景下，可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。</li><li>循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。</li></ul><p>也就是说，Python 的垃圾回收机制，很大一部分是为了处理可能产生的循环引用，是对引用计数的补充。</p><h1 id="标记清除解决循环引用"><a href="#标记清除解决循环引用" class="headerlink" title="标记清除解决循环引用"></a>标记清除解决循环引用</h1><p>Python采用了<strong>“标记-清除”(Mark and Sweep)</strong>算法，解决容器对象可能产生的循环引用问题。(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)</p><p>跟其名称一样，该算法在进行垃圾回收时分成了两步，分别是：</p><ul><li>A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达； </li><li>B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。</li></ul><p>如下图所示，在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。在图中，这两个链表分别被命名为”Object to Scan”和”Unreachable”。图中例子是这么一个情况：link1,link2,link3组成了一个引用环，同时link1还被一个变量A(其实这里称为名称A更好)引用。link4自引用，也构成了一个引用环。从图中我们还可以看到，每一个节点除了有一个记录当前引用计数的变量<code>ref_count</code>还有一个<code>gc_ref</code>变量，这个<code>gc_ref</code>是<code>ref_count</code>的一个副本，所以初始值为<code>ref_count</code>的大小。<br><img src="/images/marksweep1.png" alt=""></p><p>gc启动的时候，会逐个遍历”Object to Scan”链表中的容器对象，并且将当前对象所引用的所有对象的<code>gc_ref</code>减一。(扫描到link1的时候，由于link1引用了link2,所以会将link2的<code>gc_ref</code>减一，接着扫描link2,由于link2引用了link3,所以会将link3的<code>gc_ref</code>减一…..)像这样将”Objects to Scan”链表中的所有对象考察一遍之后，两个链表中的对象的<code>ref_count</code>和<code>gc_ref</code>的情况如下图所示。这一步操作就相当于解除了循环引用对引用计数的影响。<br><img src="/images/marksweep2.png" alt=""></p><p>接着，gc会再次扫描所有的容器对象，如果对象的<code>gc_ref</code>值为0，那么这个对象就被标记为<code>GC_TENTATIVELY_UNREACHABLE</code>，并且被移至”Unreachable”链表中。下图中的link3和link4就是这样一种情况。<br><img src="/images/marksweep3.png" alt=""></p><p>如果对象的<code>gc_ref</code>不为0，那么这个对象就会被标记为<code>GC_REACHABLE</code>。同时当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为<code>GC_REACHABLE</code>,这就是下图中link2和link3所碰到的情形。<br><img src="/images/marksweep4.png" alt=""></p><p>除了将所有可达节点标记为<code>GC_REACHABLE</code>之外，如果该节点当前在”Unreachable”链表中的话，还需要将其移回到”Object to Scan”链表中，下图就是link3移回之后的情形。<br><img src="/images/marksweep5.png" alt=""><br>第二次遍历的所有对象都遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象。如上图所示，此时link4存在于Unreachable链表中，gc随即释放之。</p><p><strong>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。</strong></p><h1 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h1><p>在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过<strong>“分代回收”(Generational Collection)</strong>以空间换时间的方法提高垃圾回收效率。</p><p>分代回收是基于这样的一个统计事实，<strong>对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</strong></p><p>python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。</p><p>gc的扫描在什么时候会被触发呢?答案是<strong>当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。</strong>值得注意的是<strong>当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。</strong>也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。</p><p>该阈值可以通过下面两个函数查看和调整:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gc.get_threshold() <span class="comment"># (threshold0, threshold1, threshold2).</span></span><br><span class="line">gc.set_threshold(threshold0[, threshold1[, threshold2]])</span><br></pre></td></tr></table></figure></p><p>下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.python.org/2/library/gc.html" target="_blank" rel="noopener">https://docs.python.org/2/library/gc.html</a><br><a href="https://rushter.com/blog/python-garbage-collector/" target="_blank" rel="noopener">https://rushter.com/blog/python-garbage-collector/</a><br><a href="https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/" target="_blank" rel="noopener">https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/</a><br><a href="https://www.quora.com/How-does-garbage-collection-in-Python-work-What-are-the-pros-and-cons" target="_blank" rel="noopener">https://www.quora.com/How-does-garbage-collection-in-Python-work-What-are-the-pros-and-cons</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> memory management </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux虚拟内存</title>
      <link href="/2018/08/19/virtual-memory-in-linux/"/>
      <url>/2018/08/19/virtual-memory-in-linux/</url>
      
        <content type="html"><![CDATA[<p>为了更有效的管理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存提供了三个重要的能力:<br>1.它将主存(物理内存)看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并且根据需要在磁盘和主存之间来回交换数据。通过这种方式它高效的使用了主存。<br>2.他为每个进程提供了一致的地址空间，从而简化了内存的管理。<br>3.它保护了每个进程的地址空间不被其他进程破坏。<br>这篇文章里就带大家了解一下虚拟内存是怎样实现上面的三种重要的能力的。</p><h2 id="寻址与地址空间"><a href="#寻址与地址空间" class="headerlink" title="寻址与地址空间"></a>寻址与地址空间</h2><p>在实际介绍虚拟内存的功能与实现之前我们必须先来大致了解一下物理寻址，虚拟寻址，物理地址空间，虚拟地址空间的概念。</p><h3 id="物理寻址与虚拟寻址"><a href="#物理寻址与虚拟寻址" class="headerlink" title="物理寻址与虚拟寻址"></a>物理寻址与虚拟寻址</h3><p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。第一个字节物理地址为0,下一个字节为1，在下一个为2,以此类推。不带任何存储器抽象的直接使用物理地址的方式就称作<strong>物理寻址(Physical addressing)</strong>。<br><img src="/images/PA.png" alt=""><br>如上图展示了一个物理寻址的示例。该示例的上下文是一条加载指令，它读取从物理地址4处开始的4字节。当CPU执行这条加载指令时，会生成一个有效的物理地址，通过内存总线，把它传递给主存，主存取出物理地址4处开始的4字节，并将它返回给CPU。早期的PC使用的是物理寻址，现代也有部分具有特殊用途的计算机系统会采用这种寻址方式。但是这种寻址方式对于现代的多道程序设计系统却不适用。所以现代处理器使用的是一种称为<strong>虚拟寻址(Virtual addressing)</strong>的寻址方式,参见下图。<br><img src="/images/VA.png" alt=""><br>使用虚拟地址，CPU通过生成一个虚拟地址(Virtual Address,VA)来访问主存。这个虚拟地址在被送到内存之前先被转换为了适当的物理地址。将一个虚拟地址转换成物理地址的过程叫做<strong>地址翻译</strong>。该地址翻译由一个<strong>CPU芯片上的</strong>叫做<strong>内存管理单元</strong>(Memory Management Unit,MMU)的专用硬件完成。MMU利用<strong>存放在主存中的查询表</strong>来动态的翻译虚拟地址。这个查询表的内容由操作系统管理，并且整个地址翻译的过程是系统自己完成的，不需要应用程序员操作。</p><h3 id="物理地址空间与虚拟地址空间"><a href="#物理地址空间与虚拟地址空间" class="headerlink" title="物理地址空间与虚拟地址空间"></a>物理地址空间与虚拟地址空间</h3><p>地址空间是一个非负整数地址的有序集合.<br>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,1,2,3,...&#125;</span><br></pre></td></tr></table></figure></p><p>如果地址空间中的整数是连续的，我们说它是一个线性地址空间(在这里我们假设地址空间总是连续的)。在一个带有虚拟内存的系统中，CPU从一个有N=pow(2,n)个地址的地址空间中生成虚拟地址，这个地址空间称为<strong>虚拟地址空间(virtual address space)</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,1,2,...,N-1&#125;</span><br></pre></td></tr></table></figure></p><p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含N=2的n次方个地址的虚拟地址空间就叫做n位地址空间。</p><p>一个系统还有还有<strong>物理地址空间(physical address space)</strong>,对应与系统中物理内存的M个字节:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,1,2,...,M-1&#125;</span><br></pre></td></tr></table></figure></p><p>在了解了物理地址空间和虚拟地址空间之后，我们现在应该要建立这样一个认知：<strong>每个数据对象可以有多个独立的地址，其中每个地址都选自不同的地址空间</strong>。这就是虚拟内存的基本思想。<strong>主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</strong></p><p>好了，在了解了与内存有关的概念之后，我们开始进入到虚拟内存的功能与实现的讨论了。</p><h2 id="作为缓存的实现"><a href="#作为缓存的实现" class="headerlink" title="作为缓存的实现"></a>作为缓存的实现</h2><p>在文章开头我们描述虚拟内存提供的三个重要能力中提到的第一个能力就是:<strong>虚拟内存将主存看作是存储在磁盘上的地址空间的缓存</strong>。下面我们就详细的讨论一下，这是如何实现的。</p><h3 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h3><p>在概念上来讲，虚拟内存被组织为由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有唯一的虚拟地址，作为到数组的索引(<strong>现在我们知道了虚拟内存虽然叫做内存，但其实它并不在内存中，而是磁盘中的一块空间)。</strong>虚拟内存与物理内存之间构成了一个缓存系统。虚拟内存位于较低层，物理内存位于较高层。虚拟内存上的数据可以被缓存到主存中。VM系统将虚拟内存分割为称为<strong>虚拟页(Virtual Page)</strong>的大小固定的块，每个虚拟页的大小为P=pow(2,p)字节。类似的，物理内存被分割为<strong>物理页(Physical Page)</strong>,大小也为P字节，物理页也被称为页帧。在虚拟内存与物理内存之间交换的单元并不是一个一个的字节，而正是这些P字节大小的块。</p><h3 id="虚拟内存的状态"><a href="#虚拟内存的状态" class="headerlink" title="虚拟内存的状态"></a>虚拟内存的状态</h3><p>在任意的时候，位于虚拟内存中的虚拟页都位于以下三种状态之一:</p><ul><li>未分配的<br>处于未分配状态的虚拟页是VM系统还未创建的页(严格来讲，他们此时并不能称之为虚拟页，它们是还未被纳入虚拟内存范围的磁盘块)。这些磁盘块没有任何数据与他们关联，因此它们不占用任何的磁盘空间。</li><li>缓存的<br>当前已缓存在物理内存中的已分配页。</li><li>未缓存的<br>当前未缓存在物理内存中的已分配页。</li></ul><p><img src="/images/8195112-47e3170732eb86a1.jpg" alt=""><br>如上图展示了一个有8个虚拟页的小虚拟内存，虚拟页0,3还未分配，因此在磁盘上还不存在，虚拟页1,4,6被缓存在物理内存中，页面2,5,7已经被分配了，但是当前并未被缓存在主存中。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>同任何缓存系统一样，虚拟内存系统必须有某种方法来判定一个虚拟页面是否缓存在物理内存中。如果是，系统还必须确定这个虚拟页存放在哪个物理页面中。如果不命中，系统还必须确定这个虚拟页存放在磁盘的哪个位置，从而将该虚拟页面读入到物理内存中的某个物理页面中，如果物理内存中没有多余的物理页面，那么还将选择一个牺牲页将其移出(在这里移出的时候还要考虑该牺牲页是否已经更新，如果更新还要对应的更新虚拟页面里面的内容)，从而腾出空间放置新读入的物理页面的数据。<br>上述的这些功能是由软硬件联合提供的，包括操作系统软件、MMU中的地址翻译硬件和一个存放在物理内存中的的叫做页表的数据结构。<strong>页表将虚拟页面映射到物理页面</strong>。每次地址翻译硬件将一个虚拟地址转换为物理地址的时候都要读取页表。</p><p>如下图展示了一个页表的基本基本组织结构:<br><img src="/images/pageTable.jpg" alt=""><br><strong>页表就是一个由页表条目(Page Table Entry,PTE)组成的数组</strong>。虚拟地址空间中的每个页在页表的一个固定偏移量处都有一个PTE。为了简单起见，这里我们假设每个PTE是由一个有效位(valid bit)和一个n位地址字段组成的。有效位表明了该虚拟页面是否被缓存在物理内存中。如果设置了有效位，则地址字段存放的就是物理内存中相应的物理页面的起始地址；如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配，否则，这个地址指向该虚拟页面在磁盘上的起始位置。</p><h3 id="页命中与缺页"><a href="#页命中与缺页" class="headerlink" title="页命中与缺页"></a>页命中与缺页</h3><p>还是以页表小节中的图片为例，考虑一下当CPU想要读包含在VP2中的虚拟内存中的一个字时会发生什么，由于VP2已经被缓存在物理内存中。地址翻译硬件将虚拟地址作为索引来定位PTE2,并且从物理内存中读取它(前面讲过页面位于物理内存中)，检查其有效位，发现其已经设置了有效位，此时地址翻译硬件就知道该页面已经缓存在物理内存中，并且该有效位后面的bit表示的就是对应的物理页面的地址。上面描述的这个过程就是页命中的情形。</p><p>下面我们来考虑一下缓存不命中的情形(在虚拟内存的习惯说法中，缓存不命中称为缺页)。</p><p>如下是缺页之前我们的示例页表的状态:</p><p><img src="/images/内存缺页前.png" alt=""><br>CPU想要读包含在VP3中的虚拟内存中的数据，地址翻译硬件根据CPU给出的虚拟地址，定位到页表中的PTE3,然后在内存中读取PTE3的内容，检查发现有效位为0,这表明当前CPU请求的页面并没有白缓存到物理内存中，这时就发生了缺页异常。这个缺页异常会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在次例中该牺牲页就是存放在PP3中的VP4。如果VP4已经被修改，那么内核就会把它赋值回磁盘。无论哪种情况，内核都会修改VP4中的页表条目，反映出VP4已经不再缓存在物理内存中这一事实。</p><p><img src="/images/内存缺页后.png" alt=""><br>接下来，内核从磁盘复制VP3到内存中的PP3,更新PTE3,此时我们的示例页表状态就成为上图这样子了。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到地址翻译硬件。但是现在VP3已经缓存在主存中了，那么页面也就能够由地址翻译硬件正常处理了。</p><p>在这里，我们有一个要注意的问题，在上面的叙述中，我们随机选择了一个页面作为牺牲页，但是在实际中为了获得更好的性能是不会随机选择的，这需要涉及到页面置换算法，我们将在后面的一篇文章中介绍。</p><h2 id="内存管理的实现"><a href="#内存管理的实现" class="headerlink" title="内存管理的实现"></a>内存管理的实现</h2><h2 id="内存保护的实现"><a href="#内存保护的实现" class="headerlink" title="内存保护的实现"></a>内存保护的实现</h2>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtual memeory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一起来记Linux命令(不定期更新).</title>
      <link href="/2018/07/27/linux-cmd-notes/"/>
      <url>/2018/07/27/linux-cmd-notes/</url>
      
        <content type="html"><![CDATA[<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>下面介绍几个关于<code>ls</code>命令没怎么用到过的option</p><table><thead><tr><th style="text-align:center">option</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center">-h</td><td style="text-align:center">与-l选项合用，可以显示带单位的文件夹或文件大小</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">以文件修改时间排序</td></tr></tbody></table><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>回到家目录:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></p><p>回到最近一次所在的位置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure></p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-m –mode=模式</td><td style="text-align:center">设定权限&lt;模式&gt;</td></tr><tr><td style="text-align:center">-p –parents</td><td style="text-align:center">可以是一个路径名称。若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录</td></tr><tr><td style="text-align:center">-v –verbose</td><td style="text-align:center">每次创建新目录都显示信息</td></tr></tbody></table><p><strong>mkdir不设定权限时默认创建的是775权限，即文件的所属者和与属主在同一个group的所有人可读可写可执行，该group以外的人可读可执行但是不可写</strong></p><p>一条命令创建复杂目录结构:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -vp complex/&#123;lib/,bin/,doc/&#123;info,product&#125;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动文件或更改文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源 目标</span><br></pre></td></tr></table></figure></p><p>当目标是文件名时执行的是重命名，当目标是一个已存在的目录名是，则将源移动值目标目录。</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -s a.txt b.txt</span><br></pre></td></tr></table></figure><p>对文件a.txt(A)建立一个符号连接b.txt(B).<br>A和B两个文件时刻保持同步，无论对哪个文件做出改变，另一个都会随之改变。删除B对A不会产生任何影响，但是删除A则会大致B不可用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp a/* b/</span><br></pre></td></tr></table></figure><p>将a目录下的所有内容复制到b目录之下。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>TCP流量控制与拥塞控制</title>
      <link href="/2018/07/21/tcp-flow-control-and-congestion-control/"/>
      <url>/2018/07/21/tcp-flow-control-and-congestion-control/</url>
      
        <content type="html"><![CDATA[<p>追求高速的传输速率是当今网络的永恒主题，但有时候我们也需要对发送方进行控制以提供流量控制服务和拥塞控制服务。这一片文章就介绍一下TCP的流量控制服务和拥塞控制服务。</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="流量控制的定义"><a href="#流量控制的定义" class="headerlink" title="流量控制的定义"></a>流量控制的定义</h2><p>前面讲过，一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到了正确的、按序的字节后，他就将数据放入接收缓存。相关联的应用进程会从该缓存中读取数据。但不必是数据一到达就立即读取。事实上，接收方也许正忙于其他任务，甚至要过很长时间后才读取该数据。<strong>如果某个应用进程读取比较缓慢，但是发送方发送的太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。</strong></p><p>TCP为它的应用程序提供了<strong>流量控制服务(flow-control service)</strong>以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个<strong>速度匹配服务</strong>，即发送方的发送速率与接收方应用程序的读取速率相匹配。</p><h2 id="流量控制的实现"><a href="#流量控制的实现" class="headerlink" title="流量控制的实现"></a>流量控制的实现</h2><p>TCP通过让发送方维护一个称为<strong>接收窗口(receive window)的变量(TCP报文段首部的接收窗口字段)来提供流量控制</strong>。通俗的讲，接收窗口用于给发送方一个指示－－该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连接两端的发送方都各自维护了一个接收窗口。<br><img src="/images/slide_23.jpg" alt=""><br>如上图所示<code>RcvBuffer</code>是接收缓存的总大小，<code>buffered data</code>是当前已经缓存了的数据，而<code>free buffer space</code>是当前剩余的缓存空间大小,<code>rwnd</code>的值就是<code>free buffer space</code>。主机B通过把当前的<code>rwnd</code>值放入到它发送给主机A的报文段首部的接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。<br>而<strong>主机A则将自己发往主机B的序号空间中未确认的数据量控制在<code>rwnd</code>值的范围内</strong>,这样就可以避免主机A使主机B的接收缓存溢出。</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="为什么需要拥塞控制"><a href="#为什么需要拥塞控制" class="headerlink" title="为什么需要拥塞控制?"></a>为什么需要拥塞控制?</h2><p>我们在前面讲到过，在TCP协议中，分组丢失一般是当网络变得拥塞时由路由器缓存溢出引起的。因此分组重传是作为网络拥塞的征兆来对待，但是却无法处理导致网络拥塞的原因，因为有太多的源想以过高的速率发送数据。一旦网络发生拥塞，分组所经历的时延会变大，分组丢失的可能性会变大，发送端需要重传的分组会变多，这只会导致网络越来越拥塞，形成恶性循环。因此，为了处理网络拥塞，需要一些机制以在面临网络拥塞时遏制发送方。</p><h2 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h2><p>在实践中采用了两种主要的拥塞控制方法，这两种方法是根据网络层是否为传输层拥塞控制提供了显示帮助来区分。它们是<strong>端到端拥塞控制</strong>和<strong>网路辅助的拥塞控制</strong>。</p><ul><li>端到端拥塞控制<br>在端到端的拥塞控制中，网路层没有为运输层提供显示支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察(如分组的丢失与时延)来推理判断之。</li><li>网络辅助的拥塞控制<br>在网络辅助的拥塞控制中，网络层构件(即路由器)向发送方提供关于网络中拥塞状态的显示反馈信息。拥塞信息从网络反馈到发送发通常有两种方式:直接反馈信息可以由网络路由器发给发送方，这种方式的通知通常采用一种阻塞分组的形式；第二种方法是路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生，一旦收到一个标记的分组后，接收方就会向发送方发送该网络拥塞指示。<br><img src="/images/a0HYBRB.png" alt=""></li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP是通过端到端的方法来解决拥塞控制的，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失被认为是网络拥塞的一个迹象，TCP会相应的减小其窗口长度。这里我们需要明确的几个问题是:<br>1.TCP发送方如何限制它向其连接发送流量的速率?<br>2.TCP发送方如何感知从它到目的地之间的路径上存在拥塞呢?<br>3.当感知到了拥塞时，采用何种算法来改变其发送速率呢?</p><p>首先我们来考虑TCP发送方怎样限制它向网络发送流量的速率。与流量控制一样，在发送方的TCP拥塞控制机制中跟踪了一个额外的变量，即<strong>拥塞窗口</strong>(congestion window)。拥塞窗口表示为cwnd,通过这个拥塞窗口，我们就能够对发送方向其连接发送数据的速率进行限制。具体的措施是:<strong>让一个发送方中未确认的数据量不会超过cwnd和rwnd的最小值</strong>，即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastByteSend - LastByteAcked &lt;= min&#123;cwnd,rwnd&#125;</span><br></pre></td></tr></table></figure></p><p>LastByteSend,LastByteAcked分别是最后一个发送的字节的序号和最后一个被确认的字节的序号。</p><p>如前所述TCP发送方通过捕获到丢包时间的产生感知从它到目的地之间的路径上存在拥塞。</p><p>在拥塞情况发生时，我们可以通过减小cwnd的值来减小发送方发送数据的速率。那么如果没有拥塞发生呢?如果没有拥塞，我们应该增加cwnd的值来增大发送方发送数据的速率。发送方发送速率过大会导致网络拥塞，甚至拥塞崩溃；而如果发送方过于谨慎，发送太慢则不能充分利用带宽。因此根据网络情况合理设置cwnd的值非常重要。</p><p>在概述了TCP拥塞控制之后，现在我们来考虑一下广受赞誉的TCP拥塞控制算法。该算法包括三部分:<strong>慢启动，拥塞避免，快速恢复</strong>。</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>当一条TCP连接开始，cwnd值通常初始置为一个MSS较小值。这使得初始发送速率为MSS/RTT。在慢启动(slow-start)状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。</p><p><img src="/images/4vCVSNC.png" alt=""></p><p>何时结束慢启动阶段的指数增长呢？<br>①如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1并重新开始慢启动过程。它还将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2，即当检测到拥塞时将ssthresh置为拥塞窗口值的一半。<br>②当检测到拥塞时ssthresh设为cwnd的一半，当到达或超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式。<br>③如果检测到3个冗余ACK，这时TCP执行一种快速重传并进入快速恢复状态。</p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>每个RTT只将cwnd的值增加一个MSS：对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS(MSS/cwnd)字节。例如，如果MSS是1460字节，并且cwnd是14 600字节，则在一个RTT内发送10个报文段。每个到达ACK增加1/10MSS的拥塞窗口长度，因此在收到对所有10个报文段的确认后，拥塞窗口的值将增加了一个MSS。当出现超时时，TCP的拥塞避免与慢启动阶段一样。当出现丢包时，网络继续从发送方向接收方交付报文段，当接收到3个冗余ACK时，将ssthresh的值置为cwnd的一半，同时将cwnd的值减半加上3个MSS。</p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>1）对收到的每个用冗余ACK，cwnd值增加一个MSS。<br>2）当对丢失报文段的一个ACK到达时，TCP在降低cwnd进入拥塞避免状态。<br>3）如果出现超时事件，执行如同慢启动和拥塞避免中相同的动作后，迁移到慢启动状态.</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP的流水线机制</title>
      <link href="/2018/07/20/tcp-pipeline/"/>
      <url>/2018/07/20/tcp-pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="流水线机制"><a href="#流水线机制" class="headerlink" title="流水线机制"></a>流水线机制</h2><p>在前面我们我们介绍TCP数据传输的过程中，讲到发送方发送一个报文段，然后等待接收方的确认报文，当确认无误之后，发送方接着发送下一个报文段。这样一种发送接收的过程是一种<strong>停等的</strong>(Stop-and-wait operation)。显然，它的传输性能是一个问题，特别是在今天的高速网络中更是如此。</p><p><img src="/images/tcp-pipeline.JPG" alt=""></p><p>所以，在实际中TCP采用了一种<strong>流水线的</strong>(Pipelined operation)方式:允许发送方发送多个分组而无需等待确认。毫无疑问，采用这种方式相较于停等有很大的性能上的提升。但是这也对可靠数据传输协议带来了一些影响:<br>1.必须增加序号范围，因为每一个输送中的分组(不计算重传)必须有一个唯一的序号，而且也许有多个在输送中未确认的报文。<br>2.协议的发送方和接收方必须能够缓存多个分组。发送方最低限度应当能够缓存那些已发送但还没有确认的分组(便于进行可能的重传)。接收方也需要缓存那些已经正确接收的分组。</p><h2 id="流水线机制中的差错恢复"><a href="#流水线机制中的差错恢复" class="headerlink" title="流水线机制中的差错恢复"></a>流水线机制中的差错恢复</h2><p>流水线差错恢复和有两种基本的方法:回退N步(Go-Back-N,GBN)和选择重传(Selective Repeat,SR)。</p><h3 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h3><p><img src="/images/gbn_seqnum.gif" alt=""><br>在回退N步协议中，允许发送方发送多个分组(当有多个分组可用时)而无需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p><p>在上图中显示了发送方看到的一个GBN协议的序号范围。我们将base定义为最早的未确认分组的序号，将nextseqnum定义为最小的未使用序号(即下一个待发送分组的序号)，则可以将序号范围划分成4段:[0,base-1]段内的序号对应于已经发送并被确认的分组，[base,nextseqnum-1]段内的序号对应已经发送但未被确认的分组，[nextseqnum,base+N-1]段内的序号能用于那些立即要被发送的分组，如果有数据来自上层的话。最后，大于或等于base+N的序号是不能使用的，直到当前流水线中未被确认的分组得到确认为止。</p><p>如图，那些已被发送但还未被确认的分组的序号范围可以看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前滑动，因此,N常被称为<strong>窗口长度</strong>，GBN协议常被称为<strong>滑动窗口协议</strong>。</p><p>在GBN中，发送方需要响应下列三种事件:</p><ul><li>上层调用<br>当上层调用的时候，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并且更新相应的变量。如果窗口已满，则指示上层该窗口已满。然后上层可能过一会再试。在实际实现中，发送方更可能缓存这些数据，或者使用同步机制允许上层在仅当窗口不满时才调用该服务。</li><li>收到ACK<br>在GBN协议中，接收方的发送确认报文采取的是<strong>累积确认</strong>的方式。发送方收到对序号为n的报文段的确认即表明接收方已经成功接收到了序号为n的以前且包括n在内的所有分组。这时发送方应该更新相关变量，使滑动窗口的起始位置移动到n+1.</li><li>超时事件<br>当发生定时器超时(可能是该定时器对应的报文丢失，或者是对应的响应报文丢失，或者是时延过大，最终的结果就是发送方在特定的时间内没有收到ACK报文，即定时器超时)，发送方<strong>重传所有</strong>的已发送但还未被确认的分组。(这里的重传所有分组，就对应着滑动窗口的回退)这里的定时器只有一个，它是最早的已发送但未被确认的分组所使用的定时器。如果收到一个ACK，但任然有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，该定时器被终止。</li></ul><p>在GBN协议中，接收方的动作很简单。如果一个序号为n的分组被正确接收(即上次交付给上层的数据是序号为n-1的分组)，则接收方为分组n发送一个ACK,并将该分组中的数据交付给上层。<strong>所有其他情况下，接收方丢弃该分组</strong>。</p><p>下面我们看一个窗口长度为4的GBN协议的运行情况:</p><p><img src="/images/gbn-in-operation.png" alt=""></p><p>从上图中，我们看到pkt2在发送的过程中丢失了，但是此时发送方没有察觉到pkt2的丢失，滑动窗口也没有满，于是发送方接着就发送了pkt3(发送方发完了pkt3之后，进入了等待的状态，因为此时滑动窗口已满)。pkt3的发送，导致接收方在没有收到pkt2的情况下收到了pkt3(即pkt3失序到达)，此时接收方采取的动作就是简单的丢弃pkt3。又回到发送方这边，由于pkt0,pkt1所对应的确认报文的到达，使得滑动窗口向前滑动，发送方就又可以发送pkt4,pkt5了。pkt4,pkt5由于也是失序到达的，所以接收方选择了丢弃它们。终于，发送方对应的pkt2的定时器发生了超时，发送方这时才知道原来pkt2在发送过程中出了问题，发送方重传了此时已发送但未被确认的分组，也就是重传了pkt2,pkt3,pkt4,pkt5。由于接收方接下来接收到的是正确的分组，所以接收方又可以正确处理了。</p><p>这就是GBN的一个典型运行实例。</p><h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>GBN协议潜在的允许发送方用多个分组“填充流水线”，因此避免了停等协议中所提到的信道利用率问题。然而GBN本身也有一些情况存在着性能问题。尤其是当窗口长度和线路时延较大时，在流水线中会有大量分组重传。单个分组的差错就能够引起GBN重传大量分组，许多分组根本没有必要重传。</p><p><strong>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。</strong></p><p>下图是在选择回传协议中某一场景下的发送方和接收方看到的序号空间。</p><p><img src="/images/Selective-repeat.JPG" alt=""></p><p>在选择重传协议中，在发送方的事件与动作:</p><ul><li>收到上层数据<br>当从上层接收到数据后,SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在GBN中一样，要么将数据缓存，要么将数据返回给上层一便以后传输。</li><li>超时<br>定时器再次被用于防止丢失分组，然而现在每个分组必须拥有自己的逻辑定时器，因为超时发生后只能发送一个分组。</li><li>收到ACK<br>如果收到ACK,倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base(即当前窗口的起始位置处)，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</li></ul><p>接收方的事件与动作:</p><ul><li>序号在[rcv_base,rcv_base+N+1]内的分组被正确接收<br>在此情况下，收到的分组落在接收方的窗口内，一个ACK被回送到发送方。如果该分组以前没接收过，则缓存该分组。如果该分组的序号等于接收窗口的基序号(rcv_base),则该分组以及以前缓存的序号连续的分组交付给上层</li><li>序号在[rcv_base-N,rcv_base-1]内的分组被正确接收<br>在此情况下，必须产生一个ACK,即使该分组是接收方以前已确认过的分组。</li><li>其他情况<br>丢弃分组。</li></ul><p>如下是一个选择重传的例子:<br><img src="/images/SR-operation.JPG" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> pipeline </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP连接的建立与断开</title>
      <link href="/2018/07/17/tcp-connection-manage/"/>
      <url>/2018/07/17/tcp-connection-manage/</url>
      
        <content type="html"><![CDATA[<p>TCP是面向连接的。“三次握手、四次挥手”形象的描述了TCP连接和建立的过程，这一篇文章我们就讲一讲TCP连接的建立与断开。</p><h1 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h1><p>假设运行在一台主机上的进程相与另一台主机上的一个进程建立一条连接。客户应用进程首先通知客户TCP，它想建立一个与服务器上的某个进程之间的连接。客户中的TCP会用以下方式与服务器中的TCP建立一条TCP连接:</p><h2 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h2><p>客户端的TCP首先向服务器的TCP发送一个特殊的TCP报文段，该报文段<strong>不包含任何的应用层数据，但是报文段的首部中的一个标志位(即SYN比特)被置为1。因此这个特殊的报文段被称为SYN报文</strong>,另外<strong>客户端随机选择一个初始序号(client_isn),并且将该序号放置在该起始的TCP SYN报文段的序号字段中</strong>。该报文段被封装在一个IP数据报中，并发送给服务器。</p><h2 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h2><p>一旦包含TCP SYN报文段的IP数据保护到达服务器主机，服务器会从该数据保护中提取出TCP SYN报文段，<strong>为该TCP连接分配缓存和变量，并向该客户TCP发送允许连接的报文段</strong>，这个连接也<strong>不包含应用层数据</strong>。但是，在报文段的首部却包含3个重要的信息。首先，<strong>SYN比特被置为1</strong>。其次，<strong>该TCP报文段的确认字段被置为client_isn+1</strong>。最后，<strong>服务器选择自己的初始序号（server_isn），并将其放置到TCP报文段首部的序号字段中</strong>。这个允许连接的报文段实际表明了：“我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn。我同意建立该连接。我自己的初始序号是server_isn”。<strong>允许连接的报文段有时被称为SYNACK报文段</strong>。</p><h2 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h2><p>在收到SYNACK报文段后，<strong>客户端要给该连接分配缓存和变量</strong>。客户主机则向服务器发送另一个报文段，这最后一个报文段对服务器的允许连接的报文段进行了确认(该客户通过将值server_isn+1放在TCP首部中的确认字段来完成此项工作)。因为连接已经建立了，所以该SYN比特被置为0,ACK比特置为1,该报文称为ACK报文。该三次握手的第三个阶段可以在报文段中携带客户到服务器的数据。</p><p><img src="/images/tcp-connection-made-three-way-handshake.png" alt=""></p><p>一旦完成了这三个步骤，客户端和服务器之间就可以相互发送包含数据的报文段了，在以后的每个报文段中，SYN比特都被设置为0.</p><h1 id="TCP连接的断开"><a href="#TCP连接的断开" class="headerlink" title="TCP连接的断开"></a>TCP连接的断开</h1><p>天下没有不散的宴席，对于TCP连接也是这样。参与TCP连接的两个进程中的任何一个都可以终止该连接。当连接结束后，主机中的”资源”(即缓存和变量)将被释放。<br><img src="/images/20180423135423195.png" alt=""></p><p>TCP连接断开的过程大概是这样的。如上图所示，我们以客户端主动要求断开连接为例:客户端向服务器发送FIN标志比特置为1的特殊报文标志自己想要断开连接，服务器收到该报文之后，则发送ACK比特置为1的报文表示确认，之后服务器接着发送自己的终止报文段，其FIN比特被置为1.最后客户端对服务器的终止报文段表示确认。此时，在两台主机上用于该连接的所有资源都被释放。</p><h1 id="TCP状态变迁"><a href="#TCP状态变迁" class="headerlink" title="TCP状态变迁"></a>TCP状态变迁</h1><h2 id="客户端TCP状态变迁"><a href="#客户端TCP状态变迁" class="headerlink" title="客户端TCP状态变迁"></a>客户端TCP状态变迁</h2><p><img src="/images/client-status.png" alt=""></p><ul><li>CLOSED<br>客户端的起始状态是CLOSED。</li><li>SYN_SENT<br>当应用层程序发起向某一服务器进程通信的指令时，客户端TCP将向该服务器进程发送SYN报文段，发送出去之后，客户端TCP进入到SYN_SENT状态。</li><li>ESTABLISHED<br>客户端TCP就需要接收服务器TCP发送的SYNACK报文段，并且客户端TCP向服务器发送ACK报文段表示确认。之后客户端TCP进入到ESTABLISHED状态。处于这个状态后客户端与服务器就可以进行正式通信了。</li><li>FIN_WAIT_1<br>现在假设客户端提出断开连接，客户端向服务器发送一个FIN比特置为1的特殊报文段，向服务器TCP表明自己需要断开连接。发送完成后，客户端TCP就进入了FIN_WAIT_1状态。在这个状态中客户端TCP等待服务器端发来的ACK确认报文。</li><li>FIN_WAIT_2<br>当客户端TCP接收到了服务器的ACK之后，客户端TCP就进入了FIN_WAIT_2状态了。在这个状态中客户端TCP等待服务端发送自己的FIN报文段。</li><li>TIME_WAIT<br>当客户端TCP接收到了服务器端TCP的FIN报文段之后，客户端TCP就会向服务器端TCP发送ACK报文以表示确认。这个最后的确认报文发送完成了之后，客户端TCP就进入了TIME_WAIT状态。</li><li>CLOSED<br>在TIME_WAIT状态，客户端TCP需要等待两倍的报文段的最大生存时间(Double Maximun Segment Life),在Linux上报文段的最大生存时间通常是30秒，两倍的MSL就是一分钟，也就是60秒。60秒之后，客户端TCP重新回到CLOSED状态。</li></ul><p>因为TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭；后发FIN包的一方执行的是被动关闭。<strong>主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长</strong>。<br>为什么主动关闭的一方不直接进入CLOSED状态，而是进入TIME_WAIT状态，并且停留两倍的MSL时长呢？这是因为TCP是建立在不可靠网络上的可靠的协议。例子：主动关闭的一方收到被动关闭的一方发出的FIN包后，回应ACK包，同时进入TIME_WAIT状态，但是因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动连接一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旧的TCP连接已经不存在了，系统此时只能返回RST包</span><br><span class="line">新的TCP连接被建立起来了，延迟包可能干扰新的连接</span><br></pre></td></tr></table></figure></p><p>不管是哪种情况都会让TCP不再可靠，所以TIME_WAIT状态有存在的必要性。</p><h2 id="服务端TCP状态变迁"><a href="#服务端TCP状态变迁" class="headerlink" title="服务端TCP状态变迁"></a>服务端TCP状态变迁</h2><p><img src="/images/server-status.png" alt=""></p><ul><li>CLOSED<br>同样的服务器端TCP初始时是CLOSED状态</li><li>LISTEN<br>服务器应用程序创建一个监听套接字，这时服务器TCP监听主上的某一个端口，等待客户机上的TCP的连接。此时的TCP处于LISTEN状态。</li><li>SYN_RCVD<br>当接收到客户TCP发来的请求连接的SYN报文之后，服务端TCP为该连接分配缓存和变量，然后SYNACK报文至客户端TCP,发送成功后，服务器端TCP就进入了SYN_RCVD状态。</li><li>ESTABLISHED<br>在SYN_RCVD状态的服务端TCP下一步需要接收客户端TCP发送过来的ACK报文，待成功接收到了这个ACK报文之后，服务端的TCP就进入到了ESTABLISHED状态了。当进入ESTABLISHED状态之后，服务端TCP就可以与客户端TCP进行正式通信了。</li><li>CLOSE_WAIT<br>处于ESTABLISHED状态的服务端TCP如果收到客户端TCP的FIN标志位设为1的报文段，这表明客户端需要发送的数据发送完了，客户端需要断开TCP连接，这时服务器TCP就要发送一个ACK表示确认，告诉客户端TCP:”我知道你要断开了，等我准备好哈”。服务器发往客户端的这个ACK报文发送成功之后，服务器TCP就进入到了CLOSE_WAIT状态了。</li><li>LAST_ACK<br>当服务器TCP也准备好了断开连接的话，服务器TCP会向客户端TCP发送自己的FIN报文，向客户端表明自己也已经转备好了。发送完了这个FIN之后，服务器TCP就进入到了LAST_ACK状态了。</li><li>CLOSED<br>当服务器接收到客户端TCP发送过来的最后一个ACK之后，服务器就可以关闭连接，释放与该连接有关的变量和缓存。这一切完成之后，服务器TCP又进入到了CLOSED状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP中的序号和确认号</title>
      <link href="/2018/07/17/sequence-number-and-ack-number-in-tcp/"/>
      <url>/2018/07/17/sequence-number-and-ack-number-in-tcp/</url>
      
        <content type="html"><![CDATA[<p>在上一节讲到TCP报文段结构的时候讲到TCP首部中有两个字段序号和确认号，这一节里面我们就详细的讲讲TCP序号和确认号是如何在TCP的可靠数据传输服务中发挥重要作用的。在我们实际了解序号和确认号之前我们先要了解一下可靠数据传输原理。</p><h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p>TCP协议是运行在网络层IP协议之上的，这里我们需要直接给出的是:IP协议提供了单一的服务，称为<strong>尽力而为服务</strong>，数据在IP协议上传输是不可靠的。我们要研究可靠数据传输，那么就需要知道数据直接在IP协议上传输怎么就不可靠了呢?会出现那些问题呢?数据在网络中传输会出现下列问题:</p><ul><li><strong>比特错误</strong></li><li><strong>分组丢失</strong></li><li><strong>接收顺序错乱</strong></li></ul><p>可靠数据传输的目的就是要解决上面的三个问题。</p><h2 id="比特错误"><a href="#比特错误" class="headerlink" title="比特错误"></a>比特错误</h2><p>对于比特错误，TCP首部中有检验和字段，接收方在接收到数据之后，通过检查检验和字段就可以判断传输的数据中是否发生了比特错误。如果发生了比特错误，接收方可以进行纠错，如果纠错无法恢复那么接收方就只能给发送方以反馈，把这个消息告诉发送方。发送方这时就会重传该分组。</p><p>上面描述中的给发送方以反馈的过程就是发送一个ACK分组，即确认的过程(事实上，无论接收到的分组是否出现了错误，接收方都应该给发送方以反馈，让发送方时刻知道当前数据发送是否正常。也就是说每发送一个分组，发送方和接收方之间都会有一个确认的过程)。而发送方重传则是当传输出现问题时的唯一解决办法。</p><p>这里我们忽略了一个问题，确认分组(ACK分组)也可能会发生比特错误。这时候该怎么办呢?首先我们要明白的一点是确认分组也是一个TCP报文段，也包含了检验和字段，也就是说发送方可以根据这个检验和字段判断出该确认分组是否出现了比特错误。基于这一点，这个问题或许有下面的三中解决办法:</p><p>1.当发送方接收到发生比特错误的确认分组时，需要向接收方也发过去一个类似确认分组的分组，以告诉接收方重新发送确认分组。但是这个类似于确认分组的分组也是可能会发生比特错误的。这这样的话我们明显陷入了一个循环问题，如果选择这种方法，无疑我们走上了一条困难重重之路。这种方法显然是行不通的。</p><p>2.第二种可能的方法是增加足够的检验和比特，使发送方不仅可以检测到比特错误，还可以自动纠正比特错误。这种方法对于会产生比特错误，但是不会丢失数据的情况来说是可以直接解决问题的。但真实的情景中丢失数据是存在的。所以这种方法在真实的情景中也是无能为力。</p><p>3.第三种方法是，当发送方检查到表明传送成功的确认分组和检查到由于比特错误而意义含糊不清的确认分组时，都重传最近分组。这种方法逻辑很清晰，但是却引入了一个新问题。由于比特错误而意义含糊不清的确认分组里面有一部分是表明传送成功，还有一部分是表明传送失败，而发送方都将其看做是传送失败的意思，从而重传最近分组。这样就在网络传输中引入了冗余分组。接收方不知道接收到的分组是新的还是一次重传。也就是说，接收方可能会两次或以上的接收到同一个分组，并且将他们当做新的分组处理。这样的话，发送方发送的数据与接收方接收到的数据就不一致，所以这也违背了可靠数据传输的原则。</p><p>解决这一个问题其实也很简单，我们只需要对第三种方法稍加改进即可。也就是在数据分组中添加一个新字段，让发送发对其数据分组编号，即将发送发数据分组的序号放入该分组中。于是，接收方只需要检查序号即可确定收到的分组是否是一次重传。(几乎所有现有的数据传输协议中，包括TCP，都采用了这种方法)</p><h2 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h2><p>下面我们来考虑分组丢失的问题。在丢失分组这个层面来讲，<strong>发送方将一个分组发送出去有可能发生发送的分组丢失或者接收方发送给发送方的用于确认的分组丢失</strong>,如下:<br><img src="/images/segment-lost.jpeg" alt=""><br><img src="/images/ack-lost.png" alt=""></p><p>上面的两种丢失情况，对于发送方来说是一样的－－接收不到确认分组。所以发送方采取的措施也是统一的－－重传。</p><p>但是，这里我们还需要考虑一些细节。发送方怎样确认自己接收不到一个分组的确认分组的呢？发送方需要等待足够长的时间以便确认分组丢失。<strong>显然发送方至少需要等待一个这样长的时间:即发送方与接收方之间的一个往返时延加上接收方处理一个分组的时间。</strong>在许多网络环境下，最欢情况下的最大时延是很难估算的，确定的因素非常少。在实际的处理是发送方明智的选择一个时间　值，以判定可能发生了丢包(尽管不能确保)，如果在这个时间内没有收到ACK，则重传该分组。这就是TCP的<strong>超时重传机制</strong>。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其ACK都没有丢失。这样就可能在发送方与接收方的信道中引入<strong>冗余数据分组</strong>,好在，上面讲到的<strong>序号</strong>可以成功解决这一个问题。</p><p>从发送方的观点看，重传是一种万能灵药。<strong>发送方不知道是一个数据分组丢失，还是一个ACK丢失，或者只是该分组或ACK过度时延。在所有这些情况下，动作都是一样的:重传</strong>。为了实现基于时间的重传机制，我们需要一个<strong>倒计时定时器</strong>。</p><h2 id="接收顺序错乱"><a href="#接收顺序错乱" class="headerlink" title="接收顺序错乱"></a>接收顺序错乱</h2><p>经过上面的讨论，解决接收顺序错乱也就简单了，依然是<strong>序号</strong>，接收方有了每一个分组的需要，那么不发生数据错误和数据丢失就可以装配出完整的数据。</p><h1 id="序号和确认号的工作细节"><a href="#序号和确认号的工作细节" class="headerlink" title="序号和确认号的工作细节"></a>序号和确认号的工作细节</h1><p>在了解了可靠数据传输所采取的一般策略之后，我们就来仔细看看序号和确认号具体是怎样协同工作的。<strong>TCP报文段首部中两个最重要的字段就是序号字段和确认字段</strong>,这两个字段是TCP可靠传输服务的关键部分。</p><p>TCP把数据看做看成一个无结构的、有序的字节流。序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上。因此，<strong>一个报文段的序号是该报文段首字节的字节流编号</strong>。</p><p>假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式的对数据流中的每一个字节编号。假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如图所示，该TCP将为该数据流构建500个报文段，给第一个报文段分配序号0,第二个报文段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP报文段首部的序号字段。</p><p><img src="/images/byte-stream.png" alt=""></p><p>确认号要比序号要难处理一些。<strong>主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号</strong>。看一个例子有助于实际发生的事情。假设主机A已收到了来自主机B的编号为0–535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536.</p><!-- ![](/images/seq-ack.gif) --><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>数据在网络中传输会出现:比特错误、分组丢失、接收顺序错乱三种错误</li><li>序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上。因此，一个报文段的序号是该报文段首字节的字节流编号</li><li>主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号</li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP简介</title>
      <link href="/2018/07/16/introduction-to-tcp/"/>
      <url>/2018/07/16/introduction-to-tcp/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章，我们讲了UDP。UDP最大的缺点就是无法提供可靠数据传输，这使得数据发送出去之后可能丢失。在一些对数据完整性要求十分严格的场景下，UDP就无用武之地了。而TCP就是用来解决数据完整传输这一问题的。</p><p><img src="/images/tcp.jpg" alt=""><br>－－图　泰国TCP Group(เกี่ยวกับ TCP),貌似是卖饮料的。</p><p>TCP是因特网传输层的<strong>面向连接</strong>的<strong>可靠数据传输</strong>。为了实现可靠数据传输，TCP使用了许多措施:<strong>差错检测、超时重传、累积确认、定时器以及用于序号和确认号的首部字段</strong>。</p><h1 id="可靠数据传输机制"><a href="#可靠数据传输机制" class="headerlink" title="可靠数据传输机制"></a>可靠数据传输机制</h1><table><thead><tr><th style="text-align:center">机制</th><th style="text-align:center">　用途和说明　</th></tr></thead><tbody><tr><td style="text-align:center">检验和</td><td style="text-align:center">用于监测在一个传输分组中的比特错误</td></tr><tr><td style="text-align:center">定时器</td><td style="text-align:center">用于超时/重传一个分组,可能因为该分组(或其ACK)在信道中丢失了.由于当一个分组延时但未丢失,或当一个分组已被接收方接收但从接收方到发送方的ACK丢失时,可能产生超时事件,所以接收方可能会收到一个分组的多个冗余副本.</td></tr><tr><td style="text-align:center">序号</td><td style="text-align:center">用于为从发送方流向接收方的数据分组按序号编号.所接受分组的序号的空隙可是的接收方检测除丢失的分组.具有相同序号的分组可使接收方检测出一个分组的冗余副本.</td></tr><tr><td style="text-align:center">确认</td><td style="text-align:center">接收方用于告诉发送方一个分组或一组分组已经被正确地接收到了.确认报文通常携带着被确认的分组或多个分组的序号.确认可以是逐个的或积累的,这取决于协议.</td></tr><tr><td style="text-align:center">否定确认</td><td style="text-align:center">收方用于告诉发送方某个分组未被正确的接收.否则人确定报文通常携带着未被正确接收的分组的序号.</td></tr><tr><td style="text-align:center">窗口、流水线</td><td style="text-align:center">发送方也许被限制仅发送那些序号落在一个指定范围内的分组.通过允许一次发送多个分组但未被确认,发送方的利用率可以在停等操作模式上得到增加.我们很快将会看到,窗口长度可根据接收方接收和缓存报文的能力/网络中的拥塞程度或两者的情况来进行设置.</td></tr></tbody></table><p>在这里，我首先给出TCP可靠数据传输所采取的机制，关于这些机制的原理我后面还会有陆续几篇文章介绍。</p><h1 id="TCP通信的过程"><a href="#TCP通信的过程" class="headerlink" title="TCP通信的过程"></a>TCP通信的过程</h1><p>TCP是面向连接的,这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须先相互发送某些预备报文段，以建立确保数据传输的参数。在握手的过程中，连接的双方都将初始化与TCP连接的许多TCP状态变量，例如<strong>初始化发送缓存和接收缓存，交换确定彼此的序号和确认号等</strong>。</p><p>一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。在介绍发送接收数据之前我们先介绍TCP连接的两个基本特点:</p><ul><li><strong>TCP连接提供的是全双工服务</strong><br>如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据可以在从进程B流向进程A的同时，也从进程A流向进程B。</li><li><strong>TCP连接是点对点的</strong><br>也即是TCP连接是单个发送方和单个接收方之间的连接。多播(在一次发送操作中，从一个发送方将数据传送给多个接收方)对于TCP来说是不可能的。</li></ul><p><img src="/images/io-buf.jpeg" alt=""></p><p>我们考虑一下从客户进程向服务进程发送数据的情况。客户端进程通过套接字(该进程之门)传递数据流。数据一旦通过该门，它就由客户端中运行的TCP控制了.TCP经这些数据引导到该链接的发送缓存里，发送缓存是在三次握手初期设置的设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据。<strong>取出数据的大小受限于最大报文段长度</strong>(Maximum Segment Size,MSS)。然后，TCP会为每块应用层数据配上一个TCP首部，从而形成多个TCP报文段，这些报文段被下传到网络层，网络层将其封装在网络层的IP数据包中，然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接收缓存，应用程序从此缓存中读取数据流。由于TCP提供的是全双工服务，所以<strong>TCP连接的每一端都有各自的发送缓存和接收缓存</strong>。</p><p>由上面的讨论我们可以看出，<strong>TCP连接的组成包括:一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字</strong>。两台主机之间的网络元素(路由器、交换机和中继器)没有为该TCP连接分配任何缓存与变量。</p><h1 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h1><p>为了便于后面介绍TCP可靠数据传输的实现，这里我们先介绍一下TCP报文段的结构:</p><p><img src="/images/tcp-segment-struct.JPG" alt=""></p><p><strong>TCP报文段由首部字段和一个数据字段组成</strong>。数据字段包含一块应用数据。如前所述，MSS限制报文段数据字段的最大长度。当TCP发送一个大文件时，通常是将该文件划分为长度为MSS的若干块(最后一块除外，它通常小于MSS).然而对于很多交互式应用来说，其TCP报文的数据字段通常很小。例如像Telnet这样的远程登录应用，其TCP报文段的数据字段经常只有一个字节，由于TCP的首部一般是20个字节(比UDP首部多12字节)，所以Telnet发送的报文段也许只有21字节。</p><p>如上图，TCP报文段由下列部分组成:</p><ul><li><p><strong>源端口号(source port)和目的端口号(dest port)</strong><br>被用来多路复用/分解来自或送到上层应用的数据。协助实现进程间的数据交付功能。</p></li><li><p><strong>检验和字段(checksum)</strong><br>同UDP一样，检验和字段也是用来检查报文中可能发生的比特错误。</p></li><li><p><strong>32比特的序号字段(sequence number)和32比特的确认号字段(acknowledgement number)</strong><br>这两个字段被TCP发送方和接收方用来实现可靠数据传输服务。</p></li><li><p><strong>16比特的接收窗口字段(receive window)</strong><br>该字段用来实现流量控制，即匹配发送方的发送速度与接收方的接收速度。</p></li><li><p><strong>4比特的首部长度字段</strong><br>该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部字段的长度是可变的，所以发送方需要计算首部的长度，以方便接收方处理。</p></li><li><strong>可选与变长的选项字段(options,variable length)</strong><br>该字段用于发送方与接收方协商最大报文段长度时，或者在高速网络环境下用作窗口调节因子时使用</li><li><strong>6比特的标志字段(flag field)</strong><br>标志字段的6个比特分别为:URG、ACK、PSH、RST、SYN、FIN。ACK比特置为1，则表明这是一个确认报文，包含一个对已成功接收报文段的确认。RST、SYN、FIN用于连接的建立和拆除。当PSH比特设置为1,就指示接收方应立即将数据交给上层。URG比特用来指示报文段里存在着被发送端上层的实体置为紧急的数据，紧急数据的最后一个字节由16比特的<strong>应急数据指针</strong>指出。当紧急数据存在并给定指向紧急数据尾的指针的时候，TCP必须通知接收端的上层实体。(在实践中，PSH,URG和紧急数据指针并没有使用。为了讨论的完整性，这里才提到这些字段)</li></ul><p>了解TCP报文段的结构对于后面我们讨论TCP可靠数据传输来说至关重要。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>TCP是因特网传输层的面向连接的可靠数据传输。</li><li>TCP为了实现可靠数据传输，采用了:差错检测、超时重传、累积确认、定时器以及用于序号和确认号的首部字段等措施。</li><li>TCP连接提供的是全双工服务,点对点通信。“多播”对TCP协议来说是不可能的。</li><li>TCP在通信之前需要先握手，以初始化与TCP连接的许多TCP状态变量。这也是TCP称为面向连接的原因。</li><li>TCP连接的每一端都有各自的发送缓存和接收缓存。</li><li>TCP连接的组成包括:一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。</li><li>TCP报文段由首部字段和一个数据字段组成，数据字段的大小受限于最大报文段长度(MSS)。</li><li>TCP报文由源端口号(source port)和目的端口号(dest port)、检验和字段(checksum)、32比特的序号字段(sequence number)和32比特的确认号字段(acknowledgement number)、16比特的接收窗口字段(receive window)、4比特的首部长度字段、可选与变长的选项字段(options,variable length)、6比特的标志字段(flag field)等部分组成。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UDP协议及其功能</title>
      <link href="/2018/07/16/udp-and-its-features/"/>
      <url>/2018/07/16/udp-and-its-features/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中，我们讲了一些运输层的基本特点。这一篇文章中，我们就从具体的网络协议下手。在传输层常用的协议就是TCP(传输控制协议)和UDP(用户数据报协议),这一节我们先聊一聊比较简单的UDP协议。UDP是一个不提供不必要服务的最简化的运输层协议，<strong>它提供了两种最为基本的服务：进程到进程间的数据交付和差错检查。</strong></p><h1 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h1><p><img src="/images/udp-segment-struct.png" alt=""><br>UDP报文由上图中的五部分组成：<strong>源端口，目的端口，长度，检验和，应用数据</strong>。应用层数据占用了UDP报文段的数据字段，其他的四个部分则组成了UDP报文段的首部字段。UDP首部中的四个字段每一个占用两个字节(16 bit)。</p><ul><li>源端口号<br>传递源端口号有助于服务器端应用程序确定报文的来源。</li><li>目的端口号<br>传递目的端口号可以使目的主机将应用数据交付运行在目的端口的响应进程(即执行分解功能)。</li><li>长度<br>长度字段则指示了在UDP报文段中的字节数(首部加数据)，因为数据字段的长度在UDP报文段中不是固定的，为了便于接收端程序的处理，所以需要一个长度字段。</li><li>检验和<br>接收方使用检验和来检查该报文段中是否出现了差错。</li></ul><h1 id="差错检查的实现原理"><a href="#差错检查的实现原理" class="headerlink" title="差错检查的实现原理"></a>差错检查的实现原理</h1><p>UDP检验和提供了差错检测功能。这就是说，检验和用于确认当UDP报文段从源到目的地移动时，其中的比特是否发生了改变(这种改变可能是由于链路中的噪声干扰或者存储在路由器中引入问题引起的)。检验和的计算方法是这样的:发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和遇到任何溢出都被回卷。得到的结果放在UDP报文段中的检验和字段。可以在[<a href="https://tools.ietf.org/html/rfc1071" target="_blank" rel="noopener">RFC 1071</a>]中找到有效实现的细节.</p><p><strong>虽然UDP提供了这种差错检测的机制，但是它对差错回复却无能为力。UDP的某种实现只是丢弃受损的报文段，其他的实现是将受损的报文段交给应用程序并且给出警告。</strong></p><h1 id="UDP应用场景"><a href="#UDP应用场景" class="headerlink" title="UDP应用场景"></a>UDP应用场景</h1><p>UDP不提供可靠数据传输，就没有三次握手这种消耗时间的建立连接的操作，也没有对包的各种检查以及状态维护操作。所以使用UDP作为传输层协议往往会更加快速，但也可能会出现丢失数据的情况。UDP也不提供拥塞控制,所以它没有传输速率限制。由于UDP协议传输时的特点，它还是有许多的应用场景。它主要适合与可以容忍少量数据丢失，低时延，需要快速传输大量数据的场景。如因特网电话、视频会议之类的实时应用以及流式多媒体的传输。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>UDP是无连接的</li><li>UDP只提供进程到进程间的数据交付和差错检查两种服务</li><li>UDP报文由源端口，目的端口，长度，检验和，应用数据五部分组成</li><li>UDP适合与可以容忍少量数据丢失，低时延，需要快速传输大量数据的场景</li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊聊计算机网络传输层</title>
      <link href="/2018/07/16/transport-layer-udp-and-tcp/"/>
      <url>/2018/07/16/transport-layer-udp-and-tcp/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cs-network-layers.jpg" alt=""><br>如上图，计算机网络在TCP/IP概念模型中被分为4层，传输层位于应用层和网络层之间，它是分层的网络体系结构的重要组成部分。<strong>该层为运行在不同主机上的应用进程提供直接通信</strong>起着至关重要的作用。这篇文章，就聊一聊传输层。</p><p>在协议栈中，传输层位于网络层之上。<strong>网络层提供了主机之间的逻辑通信，而传输层为不同主机上的进程之间提供了逻辑通信。</strong>理解传输层与网络层的这种本质差别对理解传输层提供的服务至关重要。下面我们举一个类比的例子，来说明。</p><h1 id="一个类比例子"><a href="#一个类比例子" class="headerlink" title="一个类比例子"></a>一个类比例子</h1><blockquote><p>考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。东海岸的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每周要给每个堂兄弟姐妹写一封信，每封信都用单独的信封通过传统的邮政服务发送。因此，每个家庭每周向另一家庭发送144封信。（如果他们有电子邮件的话，这些孩子可以省不少钱！）每个家庭有一个孩子负责收发邮件，西海岸家庭是Ann而东海岸家庭是Bill。每周Ann去她所有的兄弟姐妹那里收集邮件，并将这些邮件交到每天到家门口的邮政运输车上。当信件到达西海岸家庭时，Ann也负责将信件发到她的兄弟姐妹手上，东海岸家庭中Bill也负责类似工作。</p></blockquote><p>－－ 例子来源于《<a href="https://book.douban.com/subject/26176870/" target="_blank" rel="noopener">计算机网络－自顶向下的方法</a>》</p><p>我们可以做下面这样的类比:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层报文　　＝　信封上的字符</span><br><span class="line">进程　　　　　＝　堂兄弟姐妹</span><br><span class="line">主机(端系统)　＝　家庭</span><br><span class="line">运输层协议　　＝　Ann和Bill</span><br><span class="line">网络层协议　　＝　邮政服务</span><br></pre></td></tr></table></figure></p><p>在这个例子中，网络层就像邮递员，而运输层就像Ann和Bill。现在我们再来理解上面的这句话:<strong>网络层提供了主机之间的逻辑通信，而传输层为不同主机上的进程之间提供了逻辑通信。</strong>邮政服务知识将信件送到指定的家庭，它不会将信件分发到家庭的具体成员手中。这个分发的工作则是由Ann和Bill提供的。值得注意的是Ann和Bill都是在各自的家里进行工作的，他们没有参与任何中间邮件中心对邮件进行分拣的工作，也没有将邮件从一个邮件中心送到另一个邮件中心。相应的，<strong>运输层协议只工作在端系统中</strong>。在端系统中，运输层协议将来自应用进程的的报文移动到网络边缘(即网络层)，但对有关这些报文在网络层中如何移动却不做任何规定。<br>由这个例子，我们可以做出如下概括:<strong>网络层提供了不同端系统的数据交付服务，而传输层则将这种不同主机间的交付拓展为了运行在不同端系统上的两个进程之间的交付。</strong>进程到进程之间的数据交付是传输层提供的最基本的服务之一。</p><h1 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h1><p>传输层的这种进程间的数据交付是怎样实现的呢?众所周知，一个网络应用程序有一个或多个套接字(Socket),它相当于是从网络向进程传递数据和从进程向网络传递数据的门户。在接收端，传输层实际上并没有将数据交付给进程，而是将数据交给了一个中间套接字。由于在任一时刻，在接收主机上可能不止一个套接字，所以每个套接字都有唯一的标识符。</p><p>现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为此目的每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将这些报文段传递到网络，所有这些工作被称为<strong>多路复用</strong>。联系上面的例子，Ann收集家庭成员的信件，并交到每天到家门口的邮政运输车上就是多路复用；而Ann分发收到的邮件给各个兄弟姐妹的过程则为多路分解。</p><h1 id="传输层提供的其他服务"><a href="#传输层提供的其他服务" class="headerlink" title="传输层提供的其他服务"></a>传输层提供的其他服务</h1><p>上面讲到了传输层通过多路复用和多路分解将不同主机间的交付拓展为了运行在不同端系统上的两个进程之间的交付。进程到进程之间的数据交付是传输层提供的最基本的服务之一。除此之外传输层还提供了许多其它的服务。下面进行列举:</p><ul><li>进程间的数据交付(TCP,UDP)</li><li>完整性检查(TCP,UDP)</li><li>可靠数据传输(TCP)</li><li>拥塞控制(TCP)</li></ul><p>这里先列举出来，置于这些服务究竟是怎么实现的，请关注后续文章。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>1.运输层拓展了网络层的主机到主机的数据交付，提供了进程之间的数据交付。<br>2.运输层只运行在端系统中。<br>3.进程间的数据交付只是传输层最基本的功能之一，传输层还可以提供很多其他的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTTP常用首部字段</title>
      <link href="/2018/07/15/http2/"/>
      <url>/2018/07/15/http2/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章<a href="https://andrewpqc.github.io/2018/07/15/http1/#more">HTTP协议总结</a>中讲到了HTTP报文结构，无论是请求报文还是响应报文中都有首部。在HTTP报文众多的字段当中，HTTP首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。下面我们就总结一下在HTTP请求和响应中常用的首部字段。</p><h1 id="首部字段的结构和分类"><a href="#首部字段的结构和分类" class="headerlink" title="首部字段的结构和分类"></a>首部字段的结构和分类</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号”:”分隔。   </li><li>另外，字段值对应单个 HTTP 首部字段可以有多个值。</li><li>当HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。</li></ul><p>如下是两个首部字段的例子:</p><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">冒号</th><th style="text-align:center">字段值</th></tr></thead><tbody><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">:</td><td style="text-align:center">text/html</td></tr><tr><td style="text-align:center">Keep-Alive</td><td style="text-align:center">:</td><td style="text-align:center">timeout=30, max=120</td></tr></tbody></table><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>首部字段根据实际用途被分为以下4种类型：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">　描述　</th></tr></thead><tbody><tr><td style="text-align:center">通用首部字段</td><td style="text-align:center">请求报文和响应报文两方都会使用的首部</td></tr><tr><td style="text-align:center">请求首部字段</td><td style="text-align:center">从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</td></tr><tr><td style="text-align:center">响应首部字段</td><td style="text-align:center">从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</td></tr><tr><td style="text-align:center">实体首部字段</td><td style="text-align:center">针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</td></tr></tbody></table><p>下面我按照这四种类型详细的总结一下。</p><h1 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h1><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存的行为</td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">逐挑首部、连接的管理</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">创建报文的日期时间</td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">报文指令</td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">报文末端的首部一览</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">指定报文主体的传输编码方式</td></tr><tr><td style="text-align:center">Upgrade</td><td style="text-align:center">升级为其他协议</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">代理服务器的相关信息</td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">错误通知</td></tr></tbody></table><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p><h3 id="可用的指令一览"><a href="#可用的指令一览" class="headerlink" title="可用的指令一览"></a>可用的指令一览</h3><p>可用的指令按请求和响应分类如下：</p><h4 id="缓存请求指令"><a href="#缓存请求指令" class="headerlink" title="缓存请求指令"></a>缓存请求指令</h4><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">no-cache</td><td style="text-align:center">无</td><td style="text-align:center">强制向服务器再次验证</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">无</td><td style="text-align:center">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:center">max-age = [秒]</td><td style="text-align:center">必需</td><td style="text-align:center">响应的最大Age值</td></tr><tr><td style="text-align:center">max-stale( =[秒])</td><td style="text-align:center">可省略</td><td style="text-align:center">接收已过期的响应</td></tr><tr><td style="text-align:center">min-fresh = [秒]</td><td style="text-align:center">必需</td><td style="text-align:center">期望在指定时间内的响应仍有效</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">无</td><td style="text-align:center">代理不可更改媒体类型</td></tr><tr><td style="text-align:center">only-if-cached</td><td style="text-align:center">无</td><td style="text-align:center">从缓存获取资源</td></tr><tr><td style="text-align:center">cache-extension</td><td style="text-align:center">-</td><td style="text-align:center">新指令标记（token）</td></tr></tbody></table><h4 id="缓存响应指令"><a href="#缓存响应指令" class="headerlink" title="缓存响应指令"></a>缓存响应指令</h4><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">无</td><td style="text-align:center">可向任意方提供响应的缓存</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">可省略</td><td style="text-align:center">仅向特定用户返回响应</td></tr><tr><td style="text-align:center">no-cache</td><td style="text-align:center">可省略</td><td style="text-align:center">缓存前必须先确认其有效性</td></tr><tr><td style="text-align:center">no-store</td><td style="text-align:center">无</td><td style="text-align:center">不缓存请求或响应的任何内容</td></tr><tr><td style="text-align:center">no-transform</td><td style="text-align:center">无</td><td style="text-align:center">代理不可更改媒体类型</td></tr><tr><td style="text-align:center">must-revalidate</td><td style="text-align:center">无</td><td style="text-align:center">可缓存但必须再向源服务器进行确认</td></tr><tr><td style="text-align:center">proxy-revalidate</td><td style="text-align:center">无</td><td style="text-align:center">要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td style="text-align:center">max-age = [秒]</td><td style="text-align:center">必需</td><td style="text-align:center">响应的最大Age值</td></tr><tr><td style="text-align:center">s-maxage = [秒]</td><td style="text-align:center">必需</td><td style="text-align:center">公共缓存服务器响应的最大Age值</td></tr><tr><td style="text-align:center">cache-extension</td><td style="text-align:center">-</td><td style="text-align:center">新指令标记（token）</td></tr></tbody></table><h3 id="表示能否缓存的指令"><a href="#表示能否缓存的指令" class="headerlink" title="表示能否缓存的指令"></a>表示能否缓存的指令</h3><ul><li>public 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure></li></ul><p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p><ul><li>private 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure></li></ul><p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p><ul><li>no-cache 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure></li></ul><p>使用 no-cache 指令是为了防止从缓存中返回过期的资源。<br>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。<br>如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。<br>Cache-Control: no-cache=Location<br>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p><ul><li>no-store 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure></li></ul><p>当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。<br>注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。</p><h3 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h3><ul><li>s-maxage 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: s-maxage=604800（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。<br>另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</p><ul><li>max-age 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=604800（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。<br>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。<br>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。</p><ul><li>min-fresh 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: min-fresh=60（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p><ul><li>max-stale 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-stale=3600（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>使用 max-stale 可指示缓存资源，即使过期也照常接收。<br>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</p><ul><li>only-if-cached 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: only-if-cached</span><br></pre></td></tr></table></figure></li></ul><p>表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。</p><ul><li>must-revalidate 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure></li></ul><p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。</p><ul><li>proxy-revalidate 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: proxy-revalidate</span><br></pre></td></tr></table></figure></li></ul><p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p><ul><li>no-transform 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure></li></ul><p>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</p><h3 id="Cache-Control-扩展"><a href="#Cache-Control-扩展" class="headerlink" title="Cache-Control 扩展"></a>Cache-Control 扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private, community=&quot;UCI&quot;</span><br></pre></td></tr></table></figure><p>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。</p><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>Connection 首部字段具备以下两个作用：</p><ul><li>控制不再转发的首部字段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure></li></ul><p>在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即Hop-by-hop首部）。</p><ul><li>管理持久连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></li></ul><p>HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure></p><p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>表明创建 HTTP 报文的日期和时间。<br>Date: Mon, 10 Jul 2017 15:50:06 GMT<br>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。</p><h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><p>Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure></p><p>该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。<br>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure></p><h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trailer: Expires</span><br></pre></td></tr></table></figure><p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。</p><h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>规定了传输报文主体时采用的编码方式。<br>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p><h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: TSL/1.0</span><br></pre></td></tr></table></figure><p>用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: 1.1 a1.sample.com(Squid/2.7)</span><br></pre></td></tr></table></figure><p>为了追踪客户端和服务器端之间的请求和响应报文的传输路径。<br>报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。<br>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。</p><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>该首部字段通常会告知用户一些与缓存相关的问题的警告。<br>Warning 首部字段的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning：[警告码][警告的主机:端口号] &quot;[警告内容]&quot;([日期时间])</span><br></pre></td></tr></table></figure></p><p>最后的日期时间可省略。<br>HTTP/1.1 中定义了7种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。</p><table><thead><tr><th style="text-align:center">警告码</th><th style="text-align:center">警告内容</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">110</td><td style="text-align:center">Response is stale(响应已过期)</td><td style="text-align:center">代理返回已过期的资源</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">Revalidation failed(再验证失败)</td><td style="text-align:center">代理再验证资源有效性时失败（服务器无法到达等原因）</td></tr><tr><td style="text-align:center">112</td><td style="text-align:center">Disconnection operation(断开连接操作)</td><td style="text-align:center">代理与互联网连接被故意切断</td></tr><tr><td style="text-align:center">113</td><td style="text-align:center">Heuristic expiration(试探性过期)</td><td style="text-align:center">响应的试用期超过24小时(有效缓存的设定时间大于24小时的情况下)</td></tr><tr><td style="text-align:center">199</td><td style="text-align:center">Miscellaneous warning(杂项警告)</td><td style="text-align:center">任意的警告内容</td></tr><tr><td style="text-align:center">214</td><td style="text-align:center">Transformation applied(使用了转换)</td><td style="text-align:center">代理对内容编码或媒体类型等执行了某些处理时</td></tr><tr><td style="text-align:center">299</td><td style="text-align:center">Miscellaneous persistent warning(持久杂项警告)</td><td style="text-align:center">任意的警告内容</td></tr></tbody></table><h1 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h1><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept</td><td style="text-align:center">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:center">Accept-Charset</td><td style="text-align:center">优先的字符集</td></tr><tr><td style="text-align:center">Accept-Encoding</td><td style="text-align:center">优先的内容编码</td></tr><tr><td style="text-align:center">Accept-Language</td><td style="text-align:center">优先的语言（自然语言）</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">Web认证信息</td></tr><tr><td style="text-align:center">Expect</td><td style="text-align:center">期待服务器的特定行为</td></tr><tr><td style="text-align:center">From</td><td style="text-align:center">用户的电子邮箱地址</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">请求资源所在服务器</td></tr><tr><td style="text-align:center">If-Match</td><td style="text-align:center">比较实体标记（ETag）</td></tr><tr><td style="text-align:center">If-Modified-Since</td><td style="text-align:center">比较资源的更新时间</td></tr><tr><td style="text-align:center">If-None-Match</td><td style="text-align:center">比较实体标记（与 If-Macth 相反）</td></tr><tr><td style="text-align:center">If-Range</td><td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td style="text-align:center">If-Unmodified-Since</td><td style="text-align:center">比较资源的更新时间(与 If-Modified-Since 相反)</td></tr><tr><td style="text-align:center">Max-Forwards</td><td style="text-align:center">最大传输逐跳数</td></tr><tr><td style="text-align:center">Proxy-Authorization</td><td style="text-align:center">代理服务器要求客户端的认证信息</td></tr><tr><td style="text-align:center">Range</td><td style="text-align:center">实体的字节范围请求</td></tr><tr><td style="text-align:center">Referer</td><td style="text-align:center">对请求中 URI 的原始获取方</td></tr><tr><td style="text-align:center">TE</td><td style="text-align:center">传输编码的优先级</td></tr><tr><td style="text-align:center">User-Agent</td><td style="text-align:center">HTTP 客户端程序的信息</td></tr></tbody></table><h2 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, application/xhtml+xml, application/xml; q=0.5</span><br></pre></td></tr></table></figure><p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。<br>若想要给显示的媒体类型增加优先级，则使用 q=[数值] 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。</p><h2 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</span><br></pre></td></tr></table></figure><p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 q=[数值] 来表示相对优先级。</p><h2 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 q=[数值] 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。</p><h2 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3</span><br></pre></td></tr></table></figure><p>告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 q=[数值] 来表示相对优先级。</p><h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic ldfKDHKfkDdasSAEdasd==</span><br></pre></td></tr></table></figure><p>告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p><h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect: 100-continue</span><br></pre></td></tr></table></figure><p>告知服务器客户端期望出现的某种特定行为。</p><h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">From: Deeson_Woo@163.com</span><br></pre></td></tr></table></figure><p>告知服务器使用用户代理的电子邮件地址。</p><h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: andrewpqc.xyz</span><br></pre></td></tr></table></figure><p>告知服务器，请求的资源所处的互联网主机和端口号。<br>Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。<br>若服务器未设定主机名，那直接发送一个空值即可  Host: 。</p><h2 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h2><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure></p><p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。<br>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。<br>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</p><h2 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><p>首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。<br>它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</p><h2 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure><p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p><h2 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Range: &quot;123456&quot;</span><br></pre></td></tr></table></figure><p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。<br>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</p><h2 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p><h2 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Forwards: 10</span><br></pre></td></tr></table></figure><p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p><h2 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure><p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。<br>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。</p><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure><p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。<br>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://www.sample.com/index.html</span><br></pre></td></tr></table></figure><p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p><h2 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip, deflate; q=0.5</span><br></pre></td></tr></table></figure><p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。<br>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。TE: trailers</p><h2 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101</span><br></pre></td></tr></table></figure><p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。<br>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p><h1 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h1><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Accept-Ranges</td><td style="text-align:center">是否接受字节范围请求</td></tr><tr><td style="text-align:center">Age</td><td style="text-align:center">推算资源创建经过时间</td></tr><tr><td style="text-align:center">ETag</td><td style="text-align:center">资源的匹配信息</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:center">令客户端重定向至指定 URI</td></tr><tr><td style="text-align:center">Proxy-Authenticate</td><td style="text-align:center">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:center">Retry-After</td><td style="text-align:center">对再次发起请求的时机要求</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:center">HTTP 服务器的安装信息</td></tr><tr><td style="text-align:center">Vary</td><td style="text-align:center">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:center">服务器对客户端的认证信息</td></tr></tbody></table><h2 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。<br>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p><h2 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age: 1200</span><br></pre></td></tr></table></figure><p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。<br>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</p><h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure><p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。<br>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。<br>ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： ETag: W/“usagi-1234”。</p><h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://www.sample.com/sample.html</span><br></pre></td></tr></table></figure><p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。<br>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。<br>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p><h2 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。<br>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。</p><h2 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 180</span><br></pre></td></tr></table></figure><p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。<br>字段值可以指定为具体的日期时间（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是创建响应后的秒数。</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache/2.2.6 (Unix) PHP/5.2.5</span><br></pre></td></tr></table></figure><p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><h2 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。<br>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p><h2 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。</p><h1 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h1><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Allow</td><td style="text-align:center">资源可支持的 HTTP 方法</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:center">实体主体适用的编码方式</td></tr><tr><td style="text-align:center">Content-Language</td><td style="text-align:center">实体主体的自然语言</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:center">实体主体的大小（单位：字节）</td></tr><tr><td style="text-align:center">Content-Location</td><td style="text-align:center">替代对应资源的 URI</td></tr><tr><td style="text-align:center">Content-MD5</td><td style="text-align:center">实体主体的报文摘要</td></tr><tr><td style="text-align:center">Content-Range</td><td style="text-align:center">实体主体的位置范围</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">实体主体的媒体类型</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:center">实体主体过期的日期时间</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:center">资源的最后修改日期时间</td></tr></tbody></table><h2 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure><p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。<br>当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p><h2 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。<br>主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。</p><h2 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure><p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 15000</span><br></pre></td></tr></table></figure><p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。</p><h2 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Location: http://www.sample.com/index.html</span><br></pre></td></tr></table></figure><p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p><h2 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure><p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><h2 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure><p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。</p><h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><p>首部字段 Expires 会将资源失效的日期告知客户端。<br>缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。<br>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</p><h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure><p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p><h1 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h1><table><thead><tr><th style="text-align:center">首部字段名</th><th style="text-align:center">说明</th><th style="text-align:center">首部类型</th></tr></thead><tbody><tr><td style="text-align:center">Set-Cookie</td><td style="text-align:center">开始状态管理所使用的 Cookie 信息</td><td style="text-align:center">响应首部字段</td></tr><tr><td style="text-align:center">Cookie</td><td style="text-align:center">服务器接收到的 Cookie 信息</td><td style="text-align:center">请求首部字段</td></tr></tbody></table><h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;</span><br></pre></td></tr></table></figure><p>下面的表格列举了 Set-Cookie 的字段值。</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">NAME=VALUE</td><td style="text-align:center">赋予 Cookie 的名称和其值（必需项）</td></tr><tr><td style="text-align:center">expires=DATE</td><td style="text-align:center">Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td></tr><tr><td style="text-align:center">path=PATH</td><td style="text-align:center">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td></tr><tr><td style="text-align:center">domain=域名</td><td style="text-align:center">作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td></tr><tr><td style="text-align:center">Secure</td><td style="text-align:center">仅在 HTTPS 安全通信时才会发送 Cookie</td></tr><tr><td style="text-align:center">HttpOnly</td><td style="text-align:center">加以限制，使 Cookie 不能被 JavaScript 脚本访问</td></tr></tbody></table><h3 id="expires-属性"><a href="#expires-属性" class="headerlink" title="expires 属性"></a>expires 属性</h3><p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。<br>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。<br>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</p><h3 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h3><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p><h3 id="domain-属性"><a href="#domain-属性" class="headerlink" title="domain 属性"></a>domain 属性</h3><p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除example.com 以外，<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 或 www2.example.com 等都可以发送 Cookie。<br>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。<br>8.1.4 secure 属性<br>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p><h3 id="HttpOnly-属性"><a href="#HttpOnly-属性" class="headerlink" title="HttpOnly 属性"></a>HttpOnly 属性</h3><p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。<br>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status=enable</span><br></pre></td></tr></table></figure><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p><h1 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h1><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。<br>以下是最为常用的首部字段。</p><h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Frame-Options: DENY</span><br></pre></td></tr></table></figure><p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p><p>DENY：拒绝<br>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="http://sample.com/sample.html" target="_blank" rel="noopener">http://sample.com/sample.html</a> 页面为 SAMEORIGIN 时，那么 sample.com 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）</p><h2 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-XSS-Protection: 1</span><br></pre></td></tr></table></figure><p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p><p>0 ：将 XSS 过滤设置成无效状态<br>1 ：将 XSS 过滤设置成有效状态</p><h2 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNT: 1</span><br></pre></td></tr></table></figure><p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p><p>0 ：同意被追踪<br>1 ：拒绝被追踪<br>由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p><h2 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND</span><br></pre></td></tr></table></figure><p>首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。<br>要进行 P3P 的设定，需按以下操作步骤进行：</p><p>步骤 1：创建 P3P 隐私<br>步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml<br>步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Header </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP协议总结</title>
      <link href="/2018/07/15/http1/"/>
      <url>/2018/07/15/http1/</url>
      
        <content type="html"><![CDATA[<p>HTTP协议是Hyper Text Transfer Protocol(超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web)服务器传输超文本到本地浏览器的传送协议。HTTP是当今世界上应用最为广泛的<strong>应用层</strong>协议之一。</p><p>HTTP协议工作于客户端-服务端架构(CS)之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p><img src="/images/http请求响应.jpg" alt=""></p><p>下面总结一下HTTP的相关知识点，首先我们从HTTP的报文结构开始。</p><h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="/images/http_request.png" alt=""></p><p>HTTP请求报文由四部分组成:<strong>请求行、请求头、一个空行、请求体</strong>。如上图第一行为请求行，请求行由3部分组成，分别是请求方法，请求的URL和所使用的HTTP协议版本，这三部分用一个空格隔开，行未为一个回车换行符。请求行下面的是请求头部分，每一个请求头由头部字段名和值组成，中间用冒号分隔，行未依然为回车换行符。请求头可以有任意个。一个单独的换车换行符(即一个空行)表示了请求头部分结束，空行下面的就是可选的请求体部分。这就是一个HTTP请求的报文格式。</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p><img src="/images/http_resp.jpeg" alt=""><br>HTTP响应报文与请求报文的格式基本相同，它是由:<strong>状态行、响应头、一个空行、响应实体四部分组成</strong>。如上图第一行为状态行。与请求报文不同的是状态行由协议版本、状态码和原因短语组成。</p><h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:center">请求指定的页面信息，并返回实体主体。</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:center">从客户端向服务器传送的数据取代指定的文档的内容.</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">请求服务器删除指定的页面。</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:center">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td style="text-align:center">OPTIONS</td><td style="text-align:center">允许客户端查看服务器的性能、获取服务器支持的HTTP请求方法。</td></tr><tr><td style="text-align:center">TRACE</td><td style="text-align:center">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td style="text-align:center">CONNECT</td><td style="text-align:center">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td></tr></tbody></table><p>在实践中GET,POST,PUT,DELETE四种方法使用的比较多,他们分别对应对资源的获取，创建，更新，删除这四种操作。</p><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>HTTP状态码类型及其含义:</p><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">分类描述</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">成功，操作被成功接收并处理</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">重定向，需要进一步的操作以完成请求</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>常见HTTP状态码列表:</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">状态码英文名称</th><th style="text-align:center">中文描述</th></tr></thead><tbody><tr><td style="text-align:center">100</td><td style="text-align:center">Continue</td><td style="text-align:center">继续。客户端应继续其请求</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">Switching Protocols</td><td style="text-align:center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td style="text-align:center">200</td><td style="text-align:center">OK</td><td style="text-align:center">请求成功。一般用于GET与POST请求</td></tr><tr><td style="text-align:center">201</td><td style="text-align:center">Created</td><td style="text-align:center">已创建。成功请求并创建了新的资源</td></tr><tr><td style="text-align:center">202</td><td style="text-align:center">Accepted</td><td style="text-align:center">已接受。已经接受请求，但未处理完成</td></tr><tr><td style="text-align:center">203</td><td style="text-align:center">Non-Authoritative Information</td><td style="text-align:center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td style="text-align:center">204</td><td style="text-align:center">No Content</td><td style="text-align:center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td style="text-align:center">205</td><td style="text-align:center">Reset Content</td><td style="text-align:center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td style="text-align:center">206</td><td style="text-align:center">Partial Content</td><td style="text-align:center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td style="text-align:center">300</td><td style="text-align:center">Multiple Choices</td><td style="text-align:center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td style="text-align:center">301</td><td style="text-align:center">Moved Permanently</td><td style="text-align:center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td style="text-align:center">302</td><td style="text-align:center">Found</td><td style="text-align:center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td style="text-align:center">303</td><td style="text-align:center">See Other</td><td style="text-align:center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td style="text-align:center">304</td><td style="text-align:center">Not Modified</td><td style="text-align:center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td style="text-align:center">305</td><td style="text-align:center">Use Proxy</td><td style="text-align:center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td style="text-align:center">306</td><td style="text-align:center">Unused</td><td style="text-align:center">已经被废弃的HTTP状态码</td></tr><tr><td style="text-align:center">307</td><td style="text-align:center">Temporary Redirect</td><td style="text-align:center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td style="text-align:center">400</td><td style="text-align:center">Bad Request</td><td style="text-align:center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td style="text-align:center">401</td><td style="text-align:center">Unauthorized</td><td style="text-align:center">请求要求用户的身份认证</td></tr><tr><td style="text-align:center">402</td><td style="text-align:center">Payment Required</td><td style="text-align:center">保留，将来使用</td></tr><tr><td style="text-align:center">403</td><td style="text-align:center">Forbidden</td><td style="text-align:center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td style="text-align:center">404</td><td style="text-align:center">Not Found</td><td style="text-align:center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td style="text-align:center">405</td><td style="text-align:center">Method Not Allowed</td><td style="text-align:center">客户端请求中的方法被禁止</td></tr><tr><td style="text-align:center">406</td><td style="text-align:center">Not Acceptable</td><td style="text-align:center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td style="text-align:center">407</td><td style="text-align:center">Proxy Authentication Required</td><td style="text-align:center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td style="text-align:center">408</td><td style="text-align:center">Request Time-out</td><td style="text-align:center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td style="text-align:center">409</td><td style="text-align:center">Conflict</td><td style="text-align:center">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td style="text-align:center">411</td><td style="text-align:center">Length Required</td><td style="text-align:center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td style="text-align:center">413</td><td style="text-align:center">Request Entity Too Large</td><td style="text-align:center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td style="text-align:center">414</td><td style="text-align:center">Request-URI Too Large</td><td style="text-align:center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td style="text-align:center">415</td><td style="text-align:center">Unsupported Media Type</td><td style="text-align:center">服务器无法处理请求附带的媒体格式</td></tr><tr><td style="text-align:center">429</td><td style="text-align:center">Too Many Requests</td><td style="text-align:center">发送请求太多，服务器拒绝服务</td></tr><tr><td style="text-align:center">500</td><td style="text-align:center">Internal Server Error</td><td style="text-align:center">服务器内部错误，无法完成请求</td></tr><tr><td style="text-align:center">501</td><td style="text-align:center">Not Implemented</td><td style="text-align:center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td style="text-align:center">502</td><td style="text-align:center">Bad Gateway</td><td style="text-align:center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td></tr><tr><td style="text-align:center">503</td><td style="text-align:center">Service Unavailable</td><td style="text-align:center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td style="text-align:center">504</td><td style="text-align:center">Gateway Time-out</td><td style="text-align:center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td style="text-align:center">505</td><td style="text-align:center">HTTP Version not supported</td><td style="text-align:center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h1 id="持续连接与非持续连接"><a href="#持续连接与非持续连接" class="headerlink" title="持续连接与非持续连接"></a>持续连接与非持续连接</h1><p>HTTP是建立在TCP协议之上的应用层协议，众所周知TCP协议为了实现可靠数据传输在建立连接的过程会进行三次握手。也就是说，客户端需要与服务器建立连接必须首先先服务器发送一个特殊的报文段(SYN)，该报文段是不能携带应用层数据的，然后客户端需要等待服务器发回确认报文(SYNAK)。待接收到服务器发会的SYNACK报文之后，客户端还需要发送ACK报文给服务器(这个ACK报文中可以携带应用层的数据)。在客户端服务器进行了三次报文的传输之后，连接才算建立，之后应用层的数据会在这个连接上传输。</p><p>HTTP 协议的初始版本中，<strong>每进行一个 HTTP 通信(即一个请求响应对)都要断开一次 TCP 连接，这种方式称为非持续连接</strong>。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面里包含的其他资源。因此，非持续连接每次的请求都会造成无畏的TCP连接建立和断开，增加通信量的开销。为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<strong>旨在建立一次 TCP 连接后进行多次请求和响应的交互，这种方式称为持久连接</strong>。<strong>在HTTP/1.1 中，所有的连接默认都是持久连接。</strong></p><h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><p>持久连接使得多数请求以流水线方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。流水线技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML页面时，与挨个连接相比，用持久连接可以让请求更快结束。而流水线技术要比持久连接速度更快。请求数越多，时间差就越明显。采用流水线方式的持久连接使的HTTP通信的速度大幅提升。</p><h1 id="一些辨析"><a href="#一些辨析" class="headerlink" title="一些辨析"></a>一些辨析</h1><h2 id="301-302-303-307"><a href="#301-302-303-307" class="headerlink" title="301/302/303/307"></a>301/302/303/307</h2><p>301/302/303/307都是表示重定向。重定向实际使用是一个响应码(301或302或303或307)和一个响应头location，当浏览器收到响应的时候check响应码是3xx，则会取出响应头中Location对应的url，然后将该url替换浏览器地址栏中的并发起另一次HTTP事务。既然它们都表示重定向，那么他们的区别是什么呢</p><p>HTTP 1.0规范中有2个重定向－－301和302，在HTTP 1.1规范中存在4个重定向——301、302、303和307。<br><strong>HTTP 1.0规范定义</strong>301表示永久重定向,也就是资源的真实URL为Location头部中的URL。对于GET请求重定向，浏览器跟进；对于POST请求的重定向，还是需要用户确认之后才能重定向，并且应该以POST方法发出重定向请。302表示临时重定向，Location中的地址不应该被认为是资源路径，在后续的请求中应该继续使用原地址。这时，原请求是POST，则不能自动进行重定向；原请求是GET，才可以自动重定向。<br><strong>在目前主流浏览器的实现中</strong>浏览器无论是接收到301还是302,同样无论是GET还是POST,都会自动进行重定向，这导致规范和实现之间产生了二义性。由此衍生了一些问题，譬如302劫持，因此在HTTP 1.1中将302的规范细化成了303和307，希望以此来消除二义性。</p><blockquote><p><strong>302劫持</strong>：<br>对于301,搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；对于302,搜索引擎会抓取新的内容而保存旧的网址。利用这一原理，从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了，这就是302劫持。</p></blockquote><p>为了消除上面规范与实现的二义性，在HTTP 1.1中引入了303和307状态码。实际上官方文档已经不建议使用302状态码，只是为了兼容而保留302。 HTTP 1.1把HTTP 1.0规范中302的实现和规范拆分开，分别赋予HTTP 1.1中303和307，因此在HTTP 1.1中，303继承了HTTP 1.0中302的实现（即原请求是post，也允许自动进行重定向，结果是无论原请求是get还是post，都可以自动进行重定向），而307则继承了HTTP 1.0中302的规范（即如果原请求是post，则不允许进行自动重定向，结果是post不重定向，get可以自动重定向）。</p><p>在HTTP 1.1规范中，307为临时重定向，如果重定向307的原请求不是get或者head方法，那么浏览器一定不能自动的进行重定向，即便Location有url，也应该忽略。</p><h2 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET/POST"></a>GET/POST</h2><blockquote><p>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。<br>GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。<br>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。<br>GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。<br>GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。<br>GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。<br>与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在URL中对所有人都是可见的。POST的数据不会显示在 URL 中。<br>GET是幂等的，POST不幂等。</p></blockquote><p>关于GET/POST的辨析，可以参考:<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊聊HTTP、HTTPS那些事儿</title>
      <link href="/2018/05/02/something-about-https-and-let-s-encrypt/"/>
      <url>/2018/05/02/something-about-https-and-let-s-encrypt/</url>
      
        <content type="html"><![CDATA[<p>在HTTP协议中有可能存在信息窃听或身份伪装等安全问题，而使用HTTPS通信机制则可以有效的防止这些问题。这一篇文章我打算从安全的角度来聊一聊HTTP和HTTPS。</p><h1 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h1><p>HTTP具有相当优秀和方便的一面，然而它也并非只有好的一面，事物皆具有两面性，它也有自己的不足之处。这些不足之处尤其体现在安全方面。下面我们就先来看看HTTP在安全方面的缺陷。</p><h2 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h2><p>众所周知，HTTP报文使用明文(未经加密的报文)的方式来发送。而按照TCP/IP协议簇的工作方式，通信内容在所有的通信线路上都有可能遭到窥视。互联网是由能够连通到全世界的网络组成的。无论世界上哪个角落的服务器在和客户端通信时，再此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视的行为的发生。</p><p>即使经过加密处理的通信，其通信内容仍然会被窥视到，这点和未加密的通信是一样的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息还是会被看到。</p><p>窃听相同段上的通信并非难事，只需要收集在互联网上流动的数据包(帧)就行了。对于收集来的数据包的解析工作，可以交给那些抓包或者嗅探器工具。所以说，<strong>互联网上任何角落都存在通信内容被窃听的风险</strong>。</p><p>在目前大家正在研究的如何防止窃听的保护措施中，最为普及的就是加密技术。加密的对象可以是对整个通信线路进行加密，也就是服务器和客户端之间在建立起安全的通信线路之后才开始真正的通信。还有一种是将参与通信的内容本身加密。为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。</p><h2 id="不验证通信方身份可能遭遇伪装"><a href="#不验证通信方身份可能遭遇伪装" class="headerlink" title="不验证通信方身份可能遭遇伪装"></a>不验证通信方身份可能遭遇伪装</h2><p>HTTP协议中的请求和响应不会对通信方进行确认，也就是说存在’服务器是否就是发送请求中URI真正指定的主机，返回的响应是否真的返回到实际请求的客户端’等类似问题。理论上来讲，任何人都可以发起请求，服务器只要接收到请求，不管对方是谁都会返回一个响应，这会存在以下的各种忧患：</p><ul><li>无法确认请求发送至目标的Web服务器是，否是按照真实意图返回响应的那台服务器，有可能是已经伪装的Web服务器。</li><li>无法确认响应返回到的客户端是否是按真实意图接收响应的那个客户端，有可能是已伪装的客户端。</li><li>无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击(Denial of Service,拒绝服务攻击)。</li></ul><p>虽然HTTP协议无法确认通信方，但如果使用SSL则可以，SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确认通信方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认同通信方(服务器或客户端)持有的证书，即可判断通信方的真实意图。</p><h2 id="无法证明报文完整性，可能已遭篡改"><a href="#无法证明报文完整性，可能已遭篡改" class="headerlink" title="无法证明报文完整性，可能已遭篡改"></a>无法证明报文完整性，可能已遭篡改</h2><p>由于HTTP协议无法证明通信的报文的完整性，因此在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。因为在数据传输的途中，内容可能会被篡改。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-in-the-Middle attack,MITM).</p><p>虽然有使用HTTP协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是MD5,SHA-1等散列值校验的方法。但是这种方法都需要操作客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件，浏览器无法自动帮用户检查。另外，这种方法也依然无法百分之百的保证确认结果正确，应为MD5值本身被改写的话，用户是没有办法意识到的。</p><p>通过上面的分析，我们知道HTTP在安全方面确实存在着很大的缺陷，为了有效的防止这些弊端，有必要使用HTTPS。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><strong>HTTP加上加密处理和认证以及完整性保护后就是HTTPS</strong>。HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议替代而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS,其实就是身披SSL协议这层外壳的HTTP。在采用SSL之后，HTTP就拥有了安全传输的能力。</p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>要了解https我们先来了解一下两种加密算法:对称加密和非对称加密。<br>对称加密特点是：加密和解密使用相同密钥的算法。它要求发送方和接收方在安全通信之前，商定一个对称密钥。对称算法的安全性完全依赖于密钥，密钥泄漏就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。<br>非对称加密特点是：有公钥和私钥之分，公钥可以给任何人，而私钥则只部署在服务器端。<strong>并且公钥加密的数据，有且只有与该公钥对应的私钥才可以解密。</strong>非对称加密的缺点是加密和解密的计算量比较大，非常消耗CPU资源。</p><h2 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h2><p><img src="/images/sslsession.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> Let&#39; Encrypt </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>终端翻墙备忘录</title>
      <link href="/2018/04/30/let-the-terminal-penetrate-the-firewall/"/>
      <url>/2018/04/30/let-the-terminal-penetrate-the-firewall/</url>
      
        <content type="html"><![CDATA[<p>这几天要开始用GO写东西了，但是由于GFW的存在，在终端中有一些包用<code>go get</code>无法下载到。虽然本人有可以使用的ssr服务(服务默认跑在本地的1080端口)，但是ssr使用的是socks5代理。在命令行终端下，ssr无法正常工作。因为在终端下wget、curl、git、brew等命令行工具使用的都是http协议。这样的话，我们需要做就是将socks5代理转成http代理。下面就介绍两个常用的转换的工具。</p><h1 id="socks5转http"><a href="#socks5转http" class="headerlink" title="socks5转http"></a>socks5转http</h1><h2 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h2><blockquote><p>Privoxy is a non-caching web proxy with advanced filtering capabilities for enhancing privacy,modifying web page data and HTTP headers, controlling access, and removing ads and other obnoxious Internet junk. Privoxy has a flexible configuration and can be customized to suit individual needs and tastes. It has application for both stand-alone systems and multi-user networks.</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install privoxy</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>/etc/privoxy/config</code>文件中添加如下的一条配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure></p><p>这条配置的意思是将到达privoxy的http流量以socks5的形式转发至本地的1080端口(ssr服务跑在该端口)，将从本地1080端口传回的socks5流量以http形式转发至终端程序.(这句话完全是我自己的理解)</p><h3 id="重启并确认"><a href="#重启并确认" class="headerlink" title="重启并确认"></a>重启并确认</h3><p>因为更改了配置文件，所以要重启provixy服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service privoxy restart</span><br></pre></td></tr></table></figure></p><p>确认privoxy服务已经启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service privoxy status</span><br></pre></td></tr></table></figure></p><p>privoxy服务默认跑在本地的8118端口。</p><h2 id="polipo"><a href="#polipo" class="headerlink" title="polipo"></a>polipo</h2><blockquote><p>Polipo is single-threaded, non blocking caching web proxy that has very modest resource needs. </p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>在<code>/etc/polipo/config</code>文件中做如下的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># This file only needs to list configuration variables that deviate</span><br><span class="line"># from the default values.  See /usr/share/doc/polipo/examples/config.sample</span><br><span class="line"># and &quot;polipo -v&quot; for variables you can tweak and further information.</span><br><span class="line"></span><br><span class="line">logSyslog = true</span><br><span class="line">logFile = /var/log/polipo/polipo.log</span><br><span class="line"></span><br><span class="line">proxyAddress = &quot;0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line">socksParentProxy = &quot;127.0.0.1:1080&quot;</span><br><span class="line">socksProxyType = socks5</span><br><span class="line"></span><br><span class="line">chunkHighMark = 50331648</span><br><span class="line">objectHighMark = 16384</span><br><span class="line"></span><br><span class="line">dnsQueryIPv6 = no</span><br></pre></td></tr></table></figure></p><h3 id="重启并确认-1"><a href="#重启并确认-1" class="headerlink" title="重启并确认"></a>重启并确认</h3><p>因为更改了配置文件，所以要重启polipo服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service polipo restart</span><br></pre></td></tr></table></figure></p><p>确认polipo服务已经启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service polipo status</span><br></pre></td></tr></table></figure></p><p>polipo服务默认跑在本地的8123端口。</p><h1 id="终端设置"><a href="#终端设置" class="headerlink" title="终端设置"></a>终端设置</h1><p>当我们把协议转换服务架设好之后，下一步要做的就是在终端中设置代理了.</p><h2 id="当前终端设置代理"><a href="#当前终端设置代理" class="headerlink" title="当前终端设置代理"></a>当前终端设置代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=`http://127.0.0.1:8118`</span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">'http://127.0.0.1:8118'</span></span><br></pre></td></tr></table></figure><p>注意上面使用的是privoxy的端口，如果是polipo则改为对应的端口。下同。<br>我们在当前终端中设置上面的两个环境变量即可设置代理。但是这种方式只在当前终端有效，当新启动一个终端后就需要重新设置。</p><h2 id="在-bashrc文件中设置代理"><a href="#在-bashrc文件中设置代理" class="headerlink" title="在.bashrc文件中设置代理"></a>在.bashrc文件中设置代理</h2><p>我们可以在当前用户的<code>.bashrc</code>文件中设置如下的两个alias：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">"export http_proxy=http://localhost:8118;export https_proxy=http://localhost:8118"</span> </span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">"unset http_proxy;unset https_proxy"</span></span><br></pre></td></tr></table></figure></p><p>让配置立即生效:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure></p><p>我们在终端中通过运行<code>proxy</code>命令来启用终端代理，运行<code>unproxy</code>就不用代理。这样就可以在代理与非代理之间切换自如了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> privoxy </tag>
            
            <tag> polipo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在k8s-dashboard中集成heapster</title>
      <link href="/2018/04/25/heapster-in-kubernetes/"/>
      <url>/2018/04/25/heapster-in-kubernetes/</url>
      
        <content type="html"><![CDATA[<p>前面，我们在k8s集群中安装了kubernetes-dashboard插件，进入到了dashboard的界面中去了。但是我们查看kubernetes-dashboard的log,会发现有下面这样的记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2018/04/29 01:56:10 Getting config category</span><br><span class="line">2018/04/29 01:56:10 Getting discovery and load balancing category</span><br><span class="line">2018/04/29 01:56:10 Getting lists of all workloads</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 Getting pod metrics</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 [2018-04-29T01:56:10Z] Outcoming response to 10.32.0.1:49022 with 200 status code</span><br><span class="line">2018/04/29 01:56:38 Metric client health check failed: the server could not find the requested resource (get services heapster). Retrying in 30 seconds.</span><br></pre></td></tr></table></figure></p><p>从上面的log中我们大致可以得出如下的信息:当前系统中没有用于获取监控信息指标的客户端(metric client)，所以kubernetes-dashboard的处理方式是跳过这一步。同时，对metric client的健康检查失败了。这些问题不会导致dashboard无法工作，只是kubernetes-dashboard获取不到系统以及各个pod的监控数据。这里的解决方案就是安装另外一个k8s插件－－heapster.</p><h1 id="heapster简介"><a href="#heapster简介" class="headerlink" title="heapster简介"></a>heapster简介</h1><p>Heapster是容器集群监控和性能分析工具，天然的支持Kubernetes和CoreOS。<br>Kubernetes有个出名的监控agent—cAdvisor。在每个kubernetes Node上都会运行cAdvisor，它会收集本机以及容器的监控数据(cpu,memory,filesystem,network,uptime)。<br>Heapster是一个收集者，将每个Node上的cAdvisor的数据进行汇总，然后导到第三方工具(如InfluxDB)。<br><img src="/images/heapster.png" alt=""></p><p>Heapster首先从K8S Master获取集群中所有Node的信息，然后通过这些Node上的kubelet获取有用数据，而kubelet本身的数据则是从cAdvisor得到。所有获取到的数据都被推到Heapster配置的后端存储中，并还支持数据的可视化。现在后端存储 + 可视化的方法，如InfluxDB + grafana。</p><p>下面我们就在k8s集群中配置安装heapster.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们仍然采用容器化的方式，依托于k8s集群本身的方式来安装heapster.</p><h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>我们需要下面的三个镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heapster-influxdb-amd64:v1.3.3</span><br><span class="line">heapster-grafana-amd64:v4.4.3</span><br><span class="line">heapster-amd64:v1.4.0</span><br></pre></td></tr></table></figure></p><p>本来这些镜像本来在gcr.io上，但是由于国内网络无法直接访问到。我们这里依然采用网友上传到docker hub上的镜像。使用下面的脚本即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">images=(heapster-amd64:v1.4.0 heapster-influxdb-amd64:v1.3.3 heapster-grafana-amd64:v4.4.3)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull alleyj/<span class="variable">$imageName</span></span><br><span class="line">  docker tag alleyj/<span class="variable">$imageName</span> gcr.io/google_containers/<span class="variable">$imageName</span></span><br><span class="line">  docker rmi alleyj/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>这样，我们的镜像就准备完了。下面我们就需要获得对应的manifest文件了。</p><h2 id="manifest文件准备"><a href="#manifest文件准备" class="headerlink" title="manifest文件准备"></a>manifest文件准备</h2><p>这里，我们一共需要4个manifest文件，这四个文件可以在<a href="https://github.com/kubernetes/heapster" target="_blank" rel="noopener">heapster的github仓库</a>获得。在目录<code>heapster/deploy/kube-config/influxdb/</code>下有三个yml文件，分别对应的是heapster、influxdb、grafana。另外还需要的一个yml文件是一个基于rbac的角色绑定文件，在<code>heapster/deploy/kube-config/rbac/</code>目录下。</p><p>这样我们就准备好了这些文件，置于heapster目录之下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heapster-rbac.yaml</span><br><span class="line">heapster.yaml</span><br><span class="line">grafana.yaml</span><br><span class="line">influxdb.yaml</span><br></pre></td></tr></table></figure></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>查看这些文件，看看所使用的镜像版本是否是你上面所下载的镜像的版本。确认无误之后运行下面的命令即可配置完成:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f heapster/</span><br></pre></td></tr></table></figure></p><p>这样，我们再次进入到k8s-dashboard就可以看到各种以图表形式展示的系统，各个pod的实时的监控数据了。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> heapster </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kubernetes-dashboard的身份认证</title>
      <link href="/2018/04/25/k8s-dashboard-auth/"/>
      <url>/2018/04/25/k8s-dashboard-auth/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章中，我们成功配置安装了kubernetes-dashboard插件，但是这里似乎来了另外一个问题:我们怎样进入到dashboard?</p><p><img src="/images/dashboard.login.png" alt="login"><br>如上图，<code>kubernetes-dashboard</code>提供了两种验证方式:<code>kubeconfig</code>、<code>token</code>。这两种验证方式都是怎么回事呢?诶，好像有一个<code>skip</code>,我们点击看看。直接点击<code>skip</code>,我们进入到了dashboard的界面，但是似乎我们什么都做不了，页面给出了提醒，我们没有权限查看和操作集群里面的资源。该怎么办呢？下面就让我们一起来看看kubernetes里面的身份认证和权限管理吧!</p><p>要了解k8s中的身份认证和权限管理我们就必须先来了解k8s中的RBAC(Role-based access control)授权模式。</p><h1 id="RBAC-in-K8s"><a href="#RBAC-in-K8s" class="headerlink" title="RBAC in K8s"></a>RBAC in K8s</h1><p><code>RBAC Authorization</code>的基本概念是<code>Role</code>和<code>RoleBinding</code>。<code>Role</code>是一些<code>permission</code>的集合；而<code>RoleBinding</code>则是将<code>Role</code>授权给某些<code>User</code>、某些<code>Group</code>或某些<code>ServiceAccount</code>。K8s官方博客<a href="https://kubernetes.io/blog/2017/04/rbac-support-in-kubernetes" target="_blank" rel="noopener">RBAC Support in Kubernetes</a>一文的中的配图对此做了很生动的诠释：</p><p><img src="/images/rbac2.png" alt="picture"><br>从上图中我们可以看到：<br>Role:<code>pod-reader</code> 拥有Pod的<code>get</code>和<code>list</code> permissions；<br>RoleBinding:<code>pod-reader</code>将<code>Role</code>:<code>pod-reader</code>授权给右边的<code>User</code>、<code>Group</code>和<code>ServiceAccount</code>。</p><p>与<code>Role</code>和<code>RoleBinding</code>对应的是，K8s还有<code>ClusterRole</code>和<code>ClusterRoleBinding</code>的概念，它们不同之处在于：<code>ClusterRole</code>和<code>ClusterRoleBinding</code>是针对整个<code>Cluster</code>范围内有效的，无论用户或资源所在的<code>namespace</code>是什么；而<code>Role</code>和<code>RoleBinding</code>的作用范围是局限在某个k8s namespace中的。</p><p>kubernetes在安装之初就已经生成了许多<code>role</code>、<code>rolebinding</code>、<code>clusterrole</code>和<code>clusterrolebinding</code>,它们也是属于kubernetes资源的一部分，所以可以通过<code>get</code>、<code>describe</code>等命令查看，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]<span class="comment"># kc get role -n kube-system</span></span><br><span class="line">NAME                                             AGE</span><br><span class="line">extension-apiserver-authentication-reader        5d</span><br><span class="line">kubernetes-dashboard-minimal                     2d</span><br><span class="line">system::leader-locking-kube-controller-manager   5d</span><br><span class="line">system::leader-locking-kube-scheduler            5d</span><br><span class="line">system:controller:bootstrap-signer               5d</span><br><span class="line">system:controller:cloud-provider                 5d</span><br><span class="line">system:controller:token-cleaner                  5d</span><br><span class="line">weave-net                                        5d</span><br><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]<span class="comment"># kc describe role extension-apiserver-authentication-reader -n kube-system</span></span><br><span class="line">Name:extension-apiserver-authentication-reader</span><br><span class="line">Labels:kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:rbac.authorization.kubernetes.io/autoupdate=<span class="literal">true</span></span><br><span class="line">PolicyRule:</span><br><span class="line">  ResourcesNon-Resource URLsResource NamesVerbs</span><br><span class="line">  ---------------------------------------------</span><br><span class="line">  configmaps[][extension-apiserver-authentication][get]</span><br></pre></td></tr></table></figure></p><p>下面截取了<code>kubernetes-dashboard.yml</code>文件的一部分：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------------------- Dashboard Service Account ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard Role &amp; Role Binding ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to create and watch for changes of 'kubernetes-dashboard-key-holder' secret.</span></span><br><span class="line"><span class="attr">- apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">  resources:</span> <span class="string">["secrets"]</span></span><br><span class="line"><span class="attr">  verbs:</span> <span class="string">["create",</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line"><span class="attr">- apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">  resources:</span> <span class="string">["secrets"]</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get, update and delete 'kubernetes-dashboard-key-holder' secret.</span></span><br><span class="line"><span class="attr">  resourceNames:</span> <span class="string">["kubernetes-dashboard-key-holder",</span> <span class="string">"kubernetes-dashboard-certs"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  verbs:</span> <span class="string">["get",</span> <span class="string">"update"</span><span class="string">,</span> <span class="string">"delete"</span><span class="string">]</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get metrics from heapster.</span></span><br><span class="line"><span class="attr">- apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">  resources:</span> <span class="string">["services"]</span></span><br><span class="line"><span class="attr">  resourceNames:</span> <span class="string">["heapster"]</span></span><br><span class="line"><span class="attr">  verbs:</span> <span class="string">["proxy"]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p><p>上面这个yml文件做了这么一件事情：在<code>kube-system</code>命名空间中创建了一个名为<code>kubernetes-dashboard</code>的<code>ServiceAccount</code>。同时，在<code>kube-system</code>命名空间中创建了一个名为<code>kubernetes-dashboard-minimal</code>的<code>Role</code>，并且定义了这个Role的权限.然后同样是在<code>kube-system</code>命名空间中创建了一个<code>RoleBinding</code>,将上面的<code>Role</code>与<code>ServiceAccount</code>绑定在一起了。这样<code>kubernetes-dashboard</code>就有了<code>kubernetes-dashboard-minimal</code>所定义的权限了。<strong>有一点需要注意：这里的<code>kubernetes-dashboard</code>这个ServiceAccount是当用户直接点击<code>skip</code>进入到<code>dashboard</code>时所使用的账户。</strong></p><h1 id="测试环境中的认证"><a href="#测试环境中的认证" class="headerlink" title="测试环境中的认证"></a>测试环境中的认证</h1><p>如果是在测试环境中，我们图个简单，不考虑安全性的情况之下。可以考虑让外部用户直接点击<code>skip</code>进入到dashboard，并且拥有所有的权限。这一点可以通过将<code>cluster-admin</code>这个拥有全集群最高权限的<code>ClusterRole</code>绑定到默认使用的<code>ServiceAccount－－kubernetes-dashboard</code>，具体的做法是:<br>创建文件:<code>dashboard-admin.yml</code>,填写下列内容:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure></p><p>执行下面的命令来创建一个ClusterRoleBinding：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f dashboard-admin.yml</span><br></pre></td></tr></table></figure></p><p>这样，我们就可以直接点击<code>skip</code>进入dashboard,并且拥有全部的权限。</p><h1 id="基于token的认证"><a href="#基于token的认证" class="headerlink" title="基于token的认证"></a>基于token的认证</h1><p>下面我们来说说token这种方式。点击选择:Token单选框，提示你输入token。token从哪里获取，我们从来没有生成过token？其实当前K8s中已经有了很多token：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]# kc get secret -n kube-system</span><br><span class="line">NAME                                     TYPE                                  DATA      AGE</span><br><span class="line">attachdetach-controller-token-vkm75      kubernetes.io/service-account-token   3         5d</span><br><span class="line">bootstrap-signer-token-k59x3             kubernetes.io/service-account-token   3         5d</span><br><span class="line">bootstrap-token-ff4535                   bootstrap.kubernetes.io/token         5         5d</span><br><span class="line">certificate-controller-token-z3qpm       kubernetes.io/service-account-token   3         5d</span><br><span class="line">daemon-set-controller-token-3lbtj        kubernetes.io/service-account-token   3         5d</span><br><span class="line">default-token-8372f                      kubernetes.io/service-account-token   3         5d</span><br><span class="line">deployment-controller-token-pb2wl        kubernetes.io/service-account-token   3         5d</span><br><span class="line">disruption-controller-token-jwjlt        kubernetes.io/service-account-token   3         5d</span><br><span class="line">endpoint-controller-token-t3h87          kubernetes.io/service-account-token   3         5d</span><br><span class="line">generic-garbage-collector-token-sm8lt    kubernetes.io/service-account-token   3         5d</span><br><span class="line">heapster-token-zqld8                     kubernetes.io/service-account-token   3         6h</span><br><span class="line">horizontal-pod-autoscaler-token-v6wjc    kubernetes.io/service-account-token   3         5d</span><br><span class="line">job-controller-token-hfl7h               kubernetes.io/service-account-token   3         5d</span><br><span class="line">kube-dns-token-rfkvx                     kubernetes.io/service-account-token   3         5d</span><br><span class="line">kube-proxy-token-r017j                   kubernetes.io/service-account-token   3         5d</span><br><span class="line">kubernetes-dashboard-certs               Opaque                                2         2d</span><br><span class="line">kubernetes-dashboard-key-holder          Opaque                                2         4d</span><br><span class="line">kubernetes-dashboard-token-jzx4v         kubernetes.io/service-account-token   3         2d</span><br><span class="line">namespace-controller-token-3j3sn         kubernetes.io/service-account-token   3         5d</span><br><span class="line">node-controller-token-cnjsn              kubernetes.io/service-account-token   3         5d</span><br><span class="line">persistent-volume-binder-token-p1cwr     kubernetes.io/service-account-token   3         5d</span><br><span class="line">pod-garbage-collector-token-rbw2m        kubernetes.io/service-account-token   3         5d</span><br><span class="line">replicaset-controller-token-pt682        kubernetes.io/service-account-token   3         5d</span><br><span class="line">replication-controller-token-s2kb7       kubernetes.io/service-account-token   3         5d</span><br><span class="line">resourcequota-controller-token-xlrrh     kubernetes.io/service-account-token   3         5d</span><br><span class="line">service-account-controller-token-zlcph   kubernetes.io/service-account-token   3         5d</span><br><span class="line">service-controller-token-0cqs6           kubernetes.io/service-account-token   3         5d</span><br><span class="line">statefulset-controller-token-0p29q       kubernetes.io/service-account-token   3         5d</span><br><span class="line">token-cleaner-token-cq9nk                kubernetes.io/service-account-token   3         5d</span><br><span class="line">ttl-controller-token-gndzv               kubernetes.io/service-account-token   3         5d</span><br><span class="line">weave-net-token-w6grc                    kubernetes.io/service-account-token   3         5d</span><br><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]# kc describe secret attachdetach-controller-token-vkm75 -n kube-system</span><br><span class="line">Name:attachdetach-controller-token-vkm75</span><br><span class="line">Namespace:kube-system</span><br><span class="line">Labels:&lt;none&gt;</span><br><span class="line">Annotations:kubernetes.io/service-account.name=attachdetach-controller</span><br><span class="line">kubernetes.io/service-account.uid=691cdfc2-4612-11e8-8dc4-00163e0a39da</span><br><span class="line"></span><br><span class="line">Type:kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:1025 bytes</span><br><span class="line">namespace:11 bytes</span><br><span class="line">token:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhdHRhY2hkZXRhY2gtY29udHJvbGxlci10b2tlbi12a203NSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhdHRhY2hkZXRhY2gtY29udHJvbGxlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjY5MWNkZmMyLTQ2MTItMTFlOC04ZGM0LTAwMTYzZTBhMzlkYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphdHRhY2hkZXRhY2gtY29udHJvbGxlciJ9.ZBoh8-i6882nHH_oaEhtUw7L-M-2kGgrV3dRqAFw1bQUbenOYCK_xqQFeW0gTpEmYa_-k2cukfHKgqtyCF2U_hr1mXikc4aAZzJubnszQhNnASzHFihi5AkZfxBBiqYjd8WUaUSms1VbvImvmSg_Ndrw3-SSB0B0b-sWEH4dAwcXx1_hN2V3GBXZjjdFHT51U6ogvwzs-YJ_Uk5GqWIPxPNHhGMFQtQL3vVIHpxumtG6xdoVRuDitMl0gH71gugSgjabNLPMjIHmApbI3BIeH9bX9jO271OdTzNGvKaBOx2xLRJBTvrk4bSyZsSdqrLkWlUVgCTw7VNLKpmgfNTMDQ</span><br></pre></td></tr></table></figure></p><p>如上，这里有很多的<code>secret</code>存在于系统之中，每个<code>secret</code>都对应了一个<code>token</code>,但是这些<code>token</code>所对应的权限都不相同,所以不一定会符合我们的要求。</p><p>这里我们需要创建一个名为admin的ServiceAccount并绑定名为cluster-admin的ClusterRole角色(该角色拥有集群最高权限)，使用下面的yaml文件创建admin用户并赋予他管理员权限，然后可以通过token登陆dashbaord。这种认证方式本质上是通过ServiceAccount的身份认证加上Bearer token请求API server的方式实现。<br>admin-token.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br></pre></td></tr></table></figure></p><p>运行下面的命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f admin-token.yml</span><br></pre></td></tr></table></figure></p><p>然后我们可以通过如下的命令来获取admin ServiceAccount的token：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9f6pgul78p7die5tlzZ ~]# kc get secret -n kube-system | grep admin</span><br><span class="line">admin-token-whj4t                        kubernetes.io/service-account-token   3         1d</span><br><span class="line">[root@iZwz9f6pgul78p7die5tlzZ ~]# kc describe secret/admin-token-whj4t -n kube-system</span><br><span class="line">Name:admin-token-whj4t</span><br><span class="line">Namespace:kube-system</span><br><span class="line">Labels:&lt;none&gt;</span><br><span class="line">Annotations:kubernetes.io/service-account.name=admin</span><br><span class="line">kubernetes.io/service-account.uid=f2e69a6e-4a03-11e8-8dc4-00163e0a39da</span><br><span class="line"></span><br><span class="line">Type:kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:1025 bytes</span><br><span class="line">namespace:11 bytes</span><br><span class="line">token:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi10b2tlbi13aGo0dCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImYyZTY5YTZlLTRhMDMtMTFlOC04ZGM0LTAwMTYzZTBhMzlkYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphZG1pbiJ9.Nq6N7E7xY09sITcqa0WP3OeNo6Sp_se69q9aH3oM-gWDx7Sp_sbRn1VIBE-op9yG4XRbkoam-KVYhyX7QVATesYCF1fZ0p0ENcctAhmO9aEoQ1GS5I6W3DWrUXgWgaZJSrNHt-czHC_WUB3ilggaDcOEAqPEb3gYqrezyEarclQPNQZfHo3UNWjhjCqmm2vOEweCbyn9o0t8QHTTT_Pp26Bq1ho2B4HqGEeM8RHa175mG18eJQ5aRYuMM70Yp0uNyyMQmXnPTNzX0uHvU9uq-dSxxDRlq5bRg_l5bravtCsr51I-VMU9FyWd3OJWK0z1hrO76X1JrWfsbmzY3rVCSg</span><br></pre></td></tr></table></figure></p><p>如上，我们得到了该用户的token,<strong>注意：这里的token是进行base64编码后的结果，而我们需要的是解码之后的结果</strong>,直接获取解码之后的token可以通过下面的命令实现:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system get secret admin-token-whj4t -o jsonpath=&#123;.data.token&#125;|base64 -d</span><br></pre></td></tr></table></figure></p><p>这样，我们将解码之后的token复制出来，填入dashboard认证表单中就可以进入dashboard并且获取全集群的最高权限。</p><h1 id="基于kubeconfig的认证"><a href="#基于kubeconfig的认证" class="headerlink" title="基于kubeconfig的认证"></a>基于kubeconfig的认证</h1><p>如何生成kubeconfig文件请参考创建<a href="https://jimmysong.io/kubernetes-handbook/guide/kubectl-user-authentication-authorization.html" target="_blank" rel="noopener">用户认证授权的kubeconfig文件</a>。</p><p>注意参考文章中生成的kubeconfig文件中没有token字段，如果我们要使用<code>kubeconfig</code>登录dashboard则需要手动添加该字段。</p><p>对于访问<code>dashboard</code>时候使用的<code>kubeconfig</code>文件如<code>brand.kubeconfig</code>必须追到<code>token</code>字段，否则认证不会通过。而使用<code>kubectl</code>命令时的用的<code>kubeconfig</code>文件则不需要包含token字段。</p><p>kubeconfig的认证可以让拥有该kubeconfig的用户只拥有一个或几个命名空间的操作权限，这相比与上面的token的方式更加的精确和安全。kubeconfig也可以针对<code>kubectl</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -f brand.kubeconfig　~/.kube/config</span><br></pre></td></tr></table></figure></p><p>这样，该用户就只具有brand.kubeconfig文件所确定的命名空间的操作权限了。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> dashboard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为集群配置安装kubernetes-dashboard插件</title>
      <link href="/2018/04/24/setup-k8s-dashboard-on-cluster/"/>
      <url>/2018/04/24/setup-k8s-dashboard-on-cluster/</url>
      
        <content type="html"><![CDATA[<p>kubernetes-Dashboard是一个基于Web UI的kubernetes用户接口。你可以使用它在kubernetes集群中部署、调试容器化的应用，管理集群本身，创建、预览、更新集群中所拥有的资源对象，扩展和滚动更新你的应用。下面就来记录一下我是如何配置安装kuernetes-dashboard的。</p><p>kubernetes-dashboard 1.6.x以前和1.7.x的差距比较大，主要增加了一些https的认证。由于我们的集群的版本为1.7.5，下面打算安装kubernetes-dashboard V1.7.1,首先我们需要做的就是下载需要的镜像。</p><h1 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line">GCR_URL=gcr.io/google_containers</span><br><span class="line">DOCKERHUB_URL=alleyj</span><br><span class="line"></span><br><span class="line">images=(kubernetes-dashboard-init-amd64:V1.0.1</span><br><span class="line">    kubernetes-dashboard-amd64:v1.7.1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker tag <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span> <span class="variable">$GCR_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker rmi <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="下载对应的yml文件"><a href="#下载对应的yml文件" class="headerlink" title="下载对应的yml文件"></a>下载对应的yml文件</h1><p>接下来我们需要一个kubernetes-dashboard.yaml的配置文件，可以直接在<a href="https://github.com/kubernetes/dashboard/tree/master/src/deploy/recommended" target="_blank" rel="noopener">dashboard的仓库中</a>的dashboard/src/deploy/recommended文件夹下下载。<strong>注意:由于我们这里安装的是kubernetes-dashboard V1.7.1,所以我们需要下载对应版本的kubernetes-dashboard.yaml文件。具体做法是，调整repository的tag至v1.7.1</strong>。查看文件的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"># Copyright 2015 Google Inc. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"># you may not use this file except in compliance with the License.</span><br><span class="line"># You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line"># Configuration to deploy release version of the Dashboard UI compatible with</span><br><span class="line"># Kubernetes 1.7.</span><br><span class="line">#</span><br><span class="line"># Example usage: kubectl create -f &lt;this_file&gt;</span><br><span class="line"></span><br><span class="line"># ------------------- Dashboard Secret ------------------- #</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard-certs</span><br><span class="line">  namespace: kube-system</span><br><span class="line">type: Opaque</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Service Account ------------------- #</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Role &amp; Role Binding ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-minimal</span><br><span class="line">  namespace: kube-system</span><br><span class="line">rules:</span><br><span class="line">  # Allow Dashboard to create and watch for changes of &apos;kubernetes-dashboard-key-holder&apos; secret.</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;secrets&quot;]</span><br><span class="line">  verbs: [&quot;create&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;secrets&quot;]</span><br><span class="line">  # Allow Dashboard to get, update and delete &apos;kubernetes-dashboard-key-holder&apos; secret.</span><br><span class="line">  resourceNames: [&quot;kubernetes-dashboard-key-holder&quot;, &quot;kubernetes-dashboard-certs&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;update&quot;, &quot;delete&quot;]</span><br><span class="line">  # Allow Dashboard to get metrics from heapster.</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;services&quot;]</span><br><span class="line">  resourceNames: [&quot;heapster&quot;]</span><br><span class="line">  verbs: [&quot;proxy&quot;]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-minimal</span><br><span class="line">  namespace: kube-system</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: Role</span><br><span class="line">  name: kubernetes-dashboard-minimal</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Deployment ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kubernetes-dashboard</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kubernetes-dashboard</span><br><span class="line">    spec:</span><br><span class="line">      initContainers:</span><br><span class="line">      - name: kubernetes-dashboard-init</span><br><span class="line">        image: gcr.io/google_containers/kubernetes-dashboard-init-amd64:v1.0.0</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kubernetes-dashboard-certs</span><br><span class="line">          mountPath: /certs</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubernetes-dashboard</span><br><span class="line">        image: gcr.io/google_containers/kubernetes-dashboard-amd64:v1.7.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br><span class="line">          protocol: TCP</span><br><span class="line">        args:</span><br><span class="line">          - --tls-key-file=/certs/dashboard.key</span><br><span class="line">          - --tls-cert-file=/certs/dashboard.crt</span><br><span class="line">          # Uncomment the following line to manually specify Kubernetes API server Host</span><br><span class="line">          # If not specified, Dashboard will attempt to auto discover the API server and connect</span><br><span class="line">          # to it. Uncomment only if the default does not work.</span><br><span class="line">          # - --apiserver-host=http://my-address:port</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kubernetes-dashboard-certs</span><br><span class="line">          mountPath: /certs</span><br><span class="line">          readOnly: true</span><br><span class="line">          # Create on-disk volume to store exec logs</span><br><span class="line">        - mountPath: /tmp</span><br><span class="line">          name: tmp-volume</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            scheme: HTTPS</span><br><span class="line">            path: /</span><br><span class="line">            port: 8443</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          timeoutSeconds: 30</span><br><span class="line">      volumes:</span><br><span class="line">      - name: kubernetes-dashboard-certs</span><br><span class="line">        secret:</span><br><span class="line">          secretName: kubernetes-dashboard-certs</span><br><span class="line">      - name: tmp-volume</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      serviceAccountName: kubernetes-dashboard</span><br><span class="line">      # Comment the following tolerations if Dashboard must not be deployed on master</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        effect: NoSchedule</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Service ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure></p><p>查看上述的文件，可以看到这里需要的两个镜像都已经存在于本地，但是略有不同的是这里需要的<code>kubernetes-dashboard-init-amd64:v1.0.0</code>，而我们本地有的镜像tag为<code>v1.0.1</code>,所以我们这里更改一下这个yml文件，将<code>kubernetes-dashboard-init-amd64的tag</code>从<code>v1.0.0</code>改为<code>v1.0.1</code>.</p><h1 id="创建相应的资源"><a href="#创建相应的资源" class="headerlink" title="创建相应的资源"></a>创建相应的资源</h1><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kc create -f kubernetes-dashboard.yml</span><br></pre></td></tr></table></figure><p>查看kube-system中，kubernetes-dashboard所对应的pod的状态一直是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                                              READY     STATUS     RESTARTS   AGE</span><br><span class="line">kubernetes-dashboard-3554419144-j2qqp             0/1       Init:0/1   0          3m</span><br></pre></td></tr></table></figure></p><p>我们discribe一下这个pod<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod kubernetes-dashboard-3554419144-j2qqp -n kube-system</span><br></pre></td></tr></table></figure></p><p>输出的Event如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  FirstSeenLastSeenCountFromSubObjectPathTypeReasonMessage</span><br><span class="line">  ------------------------------------------------------------</span><br><span class="line">  29s29s1default-schedulerNormalScheduledSuccessfully assigned kubernetes-dashboard-3554419144-j2qqp to izwz9f6pgul78p7die5tlzz</span><br><span class="line">  29s29s1kubelet, izwz9f6pgul78p7die5tlzzNormalSuccessfulMountVolumeMountVolume.SetUp succeeded <span class="keyword">for</span> volume <span class="string">"tmp-volume"</span> </span><br><span class="line">  29s29s1kubelet, izwz9f6pgul78p7die5tlzzNormalSuccessfulMountVolumeMountVolume.SetUp succeeded <span class="keyword">for</span> volume <span class="string">"kubernetes-dashboard-certs"</span> </span><br><span class="line">  29s29s1kubelet, izwz9f6pgul78p7die5tlzzNormalSuccessfulMountVolumeMountVolume.SetUp succeeded <span class="keyword">for</span> volume <span class="string">"kubernetes-dashboard-token-5mhr7"</span> </span><br><span class="line">  28s28s1kubelet, izwz9f6pgul78p7die5tlzzspec.initContainers&#123;kubernetes-dashboard-init&#125;NormalPulledContainer image <span class="string">"gcr.io/google_containers/kubernetes-dashboard-init-amd64:v1.0.1"</span> already present on machine</span><br><span class="line">  28s28s1kubelet, izwz9f6pgul78p7die5tlzzspec.initContainers&#123;kubernetes-dashboard-init&#125;NormalCreatedCreated container</span><br><span class="line">  28s28s1kubelet, izwz9f6pgul78p7die5tlzzspec.initContainers&#123;kubernetes-dashboard-init&#125;NormalStartedStarted container</span><br><span class="line">  27s8s3kubelet, izwz9f6pgul78p7die5tlzzspec.containers&#123;kubernetes-dashboard&#125;NormalPulledContainer image <span class="string">"gcr.io/google_containers/kubernetes-dashboard-amd64:v1.7.1"</span> already present on machine</span><br><span class="line">  27s8s3kubelet, izwz9f6pgul78p7die5tlzzspec.containers&#123;kubernetes-dashboard&#125;NormalCreatedCreated container</span><br><span class="line">  26s7s3kubelet, izwz9f6pgul78p7die5tlzzspec.containers&#123;kubernetes-dashboard&#125;NormalStartedStarted container</span><br><span class="line">  25s4s5kubelet, izwz9f6pgul78p7die5tlzzspec.containers&#123;kubernetes-dashboard&#125;WarningBackOffBack-off restarting failed container</span><br></pre></td></tr></table></figure></p><p>可以看到，initContainer kubernetes-dashboard-init容器全运行正常，kubernetes-dashboard容器运行失败。</p><p>接着我们来查看一下logs:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs kubernetes-dashboard-3554419144-j2qqp -n kube-system</span><br></pre></td></tr></table></figure></p><p>输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2018/04/24 14:41:19 Using in-cluster config to connect to apiserver</span><br><span class="line">2018/04/24 14:41:19 Using service account token for csrf signing</span><br><span class="line">2018/04/24 14:41:19 No request provided. Skipping authorization</span><br><span class="line">2018/04/24 14:41:19 Starting overwatch</span><br><span class="line">2018/04/24 14:41:19 Successful initial request to the apiserver, version: v1.7.5</span><br><span class="line">2018/04/24 14:41:19 New synchronizer has been registered: kubernetes-dashboard-key-holder-kube-system. Starting</span><br><span class="line">2018/04/24 14:41:19 Starting secret synchronizer for kubernetes-dashboard-key-holder in namespace kube-system</span><br><span class="line">2018/04/24 14:41:19 Initializing secret synchronizer synchronously using secret kubernetes-dashboard-key-holder from namespace kube-system</span><br><span class="line">2018/04/24 14:41:19 Initializing JWE encryption key from synchronized object</span><br><span class="line">2018/04/24 14:41:19 Creating in-cluster Heapster client</span><br><span class="line">2018/04/24 14:41:19 Serving securely on HTTPS port: 8443</span><br><span class="line">2018/04/24 14:41:19 open /certs/dashboard.crt: no such file or directory</span><br></pre></td></tr></table></figure></p><p>可以看到，这里说没有<code>/certs/dashboard.crt</code>文件，这个证书文件本应该是在运行init容器时创建的，但是这里不知道为什么我们这里没有创建成功。</p><p>下面，我们删除刚才由<code>kubernetes-dashboard.yml</code>文件所创建的资源，然后采取openssl来创建自签名证书。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f kubenetes-dashboard.yml</span><br></pre></td></tr></table></figure></p><h2 id="再次尝试"><a href="#再次尝试" class="headerlink" title="再次尝试"></a>再次尝试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -newkey rsa:4096 -nodes -sha256 -keyout dashboard.key -x509 -days 365 -out dashboard.crt</span><br></pre></td></tr></table></figure><p>依据提示，填写签发者信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Generating a 4096 bit RSA private key</span><br><span class="line">......................++</span><br><span class="line">....................................................................................................++</span><br><span class="line">writing new private key to &apos;dashboard.key&apos;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &apos;.&apos;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:Hubei  </span><br><span class="line">Locality Name (eg, city) [Default City]:Wuhan</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:Muxistudio</span><br><span class="line">Organizational Unit Name (eg, section) []:be</span><br><span class="line">Common Name (eg, your name or your server&apos;s hostname) []:iZwz9f6pgul78p7die5tlzZ</span><br><span class="line">Email Address []:3480437308@qq.com</span><br></pre></td></tr></table></figure></p><p>执行完之后，你的命令执行目录就会多出来两个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ll</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 2086 Nov 14 09:59 dashboard.crt</span><br><span class="line">-rw-r--r--. 1 root root 3272 Nov 14 09:59 dashboard.key</span><br></pre></td></tr></table></figure><p>将这两个文件移动到<code>/certs/</code>目录之下，然后根据这两个文件使用下面的命令来创建secret,来替换掉kubernetes-dashboard.yml中定义的secret：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create secret generic kubernetes-dashboard-certs --from-file=/certs -n kube-system</span><br></pre></td></tr></table></figure></p><p>下面，我们再次依据<code>kubernetes-dashboard.yml</code>来创建dashboard所需要的资源对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubernetes-dashboard.yml</span><br></pre></td></tr></table></figure></p><p>输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serviceaccount &quot;kubernetes-dashboard&quot; created</span><br><span class="line">role &quot;kubernetes-dashboard-minimal&quot; created</span><br><span class="line">rolebinding &quot;kubernetes-dashboard-minimal&quot; created</span><br><span class="line">deployment &quot;kubernetes-dashboard&quot; created</span><br><span class="line">service &quot;kubernetes-dashboard&quot; created</span><br><span class="line">Error from server (AlreadyExists): error when creating &quot;dashboard.yml&quot;: secrets &quot;kubernetes-dashboard-certs&quot; already exists</span><br></pre></td></tr></table></figure></p><p>从输出也可以看出来，其他资源已经创建成功，而<code>kubernetes-dashboard-certs</code>则被我们成功替换掉了。</p><p>下面，我们查看一下dashboard对应的pod的事件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod kubernetes-dashboard-3554419144-jjj5q -n kube-system</span><br></pre></td></tr></table></figure></p><p>事件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  FirstSeenLastSeenCountFromSubObjectPathTypeReasonMessage</span><br><span class="line">  ------------------------------------------------------------</span><br><span class="line">  3m3m1default-schedulerNormalScheduledSuccessfully assigned kubernetes-dashboard-3554419144-jjj5q to izwz9f6pgul78p7die5tlzz</span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzNormalSuccessfulMountVolumeMountVolume.SetUp succeeded for volume &quot;tmp-volume&quot; </span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzNormalSuccessfulMountVolumeMountVolume.SetUp succeeded for volume &quot;kubernetes-dashboard-token-jzx4v&quot; </span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzNormalSuccessfulMountVolumeMountVolume.SetUp succeeded for volume &quot;kubernetes-dashboard-certs&quot; </span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzspec.initContainers&#123;kubernetes-dashboard-init&#125;NormalPulledContainer image &quot;gcr.io/google_containers/kubernetes-dashboard-init-amd64:v1.0.1&quot; already present on machine</span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzspec.initContainers&#123;kubernetes-dashboard-init&#125;NormalCreatedCreated container</span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzspec.initContainers&#123;kubernetes-dashboard-init&#125;NormalStartedStarted container</span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzspec.containers&#123;kubernetes-dashboard&#125;NormalPulledContainer image &quot;gcr.io/google_containers/kubernetes-dashboard-amd64:v1.7.1&quot; already present on machine</span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzspec.containers&#123;kubernetes-dashboard&#125;NormalCreatedCreated container</span><br><span class="line">  3m3m1kubelet, izwz9f6pgul78p7die5tlzzspec.containers&#123;kubernetes-dashboard&#125;NormalStartedStarted container</span><br></pre></td></tr></table></figure></p><p>如上，一切正常。我们的kubernetes-dashboard插件就此安装完成。</p><h1 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h1><p>下面，我们要访问服务器上的<code>kubernetes-dashboard</code>服务就还需要做下面的一步操作：将kubernetes-dashboard的service变为外部可路由。将service的类型由默认的ClusterIP改为NodePort.<br>执行下面的命令，更改service的配置文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit service kubernetes-dashboard -n kube-system</span><br></pre></td></tr></table></figure></p><p>更改完成之后，我们查看服务的暴露的主机端口:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get service kubernetes-dashboard -n kube-system</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                   CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kubernetes-dashboard   10.109.219.222   &lt;nodes&gt;       443:30087/TCP   52m</span><br></pre></td></tr></table></figure></p><p>如上，服务暴露的主机端口为30087,我们访问<code>https://&lt;主机公网IP&gt;:30087/</code>即可访问到dashboard服务。注意，<strong>这里使用的是HTTPS服务，并且使用的是自签名证书，所以在我们初次进入时，浏览器会因为无法识别证书的签署机构而阻止继续访问，这时我们只需要点击高级选项，标识网站为安全即可。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> dashboard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Kubeadm搭建一个k8s 1.7.5的单节点集群</title>
      <link href="/2018/04/23/setup-kubernetes-cluster-with-kubeadm/"/>
      <url>/2018/04/23/setup-kubernetes-cluster-with-kubeadm/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.muxixyz.com" target="_blank" rel="noopener">团队</a>近期打算自己开发一个基于kubernetes的应用部署、监控、维护、管理的云平台MAE(Muxi APP Engine)，思路来自于赵老板的一篇<a href="http://zxc0328.github.io/2017/05/27/mae/#more" target="_blank" rel="noopener">博客</a>。可以让用户直接在可视化的环境下完成应用的部署、集群维护的一个服务。开发首先得需要一个kubernetes集群，这几天一直在弄kubernetes的东西。今天就先总结一下集群搭建的基本过程，记录一下搭建过程中遇到的坑，希望能够给后来者以参考。</p><h1 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h1><p>由于是学生团队，搭建过程基于的环境比较简陋：</p><ul><li>阿里云学生机一台，CentOS 7.4 ,64位的操作系统</li><li>CPU:1核</li><li>内存：2G</li><li>带宽：1Mbps</li></ul><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="节点命名"><a href="#节点命名" class="headerlink" title="节点命名"></a>节点命名</h2><p>阿里云的机器的hostname默认都是一长串由字母和数字组成的字符串，没有什么规律。为了便于以后的管理，我们可以使用<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec_configuring_host_names_using_hostnamectl" target="_blank" rel="noopener">hostnamectl命令</a>来给我们的节点取一个具有语义性的名字。具体操作,在root用户下运行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl <span class="built_in">set</span>-hostname <span class="string">"k8s-master"</span></span><br></pre></td></tr></table></figure></p><p>因为我们这里只有一台主机，所以就给它命名成k8s-master.</p><h2 id="禁用防火墙"><a href="#禁用防火墙" class="headerlink" title="禁用防火墙"></a>禁用防火墙</h2><p>如果各个主机启用了防火墙，需要开放Kubernetes各个组件所需要的端口，可以查看Installing kubeadm中的<a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/#check-required-ports" target="_blank" rel="noopener">Check required ports</a>一节。 这里简单起见在各节点禁用防火墙：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure></p><p>创建/etc/sysctl.d/k8s.conf文件，添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br></pre></td></tr></table></figure></p><p>执行<code>sysctl -p /etc/sysctl.d/k8s.conf</code>使修改生效。</p><h2 id="禁用SELINUX"><a href="#禁用SELINUX" class="headerlink" title="禁用SELINUX"></a>禁用SELINUX</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure><p>修改成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure></p><p>修改<code>/etc/selinux/config</code>文件的过程也可以直接这样:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/selinux/config</span><br></pre></td></tr></table></figure></p><h2 id="关闭系统的Swap"><a href="#关闭系统的Swap" class="headerlink" title="关闭系统的Swap"></a>关闭系统的Swap</h2><p>Kubernetes 1.8开始要求关闭系统的Swap。如果不关闭，默认配置下kubelet将无法启动。可以通过kubelet的启动参数<code>--fail-swap-on=false</code>更改这个限制。 我们这里关闭系统的Swap:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapoff -a</span><br></pre></td></tr></table></figure></p><p>修改<code>/etc/fstab</code>文件，注释掉<code>SWAP</code>的自动挂载，使用<code>free -m</code>确认swap已经关闭。<br><code>swappiness</code>参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=0</span><br></pre></td></tr></table></figure></p><p>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。</p><h1 id="安装并配置docker"><a href="#安装并配置docker" class="headerlink" title="安装并配置docker"></a>安装并配置docker</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>docker属于kubernetes的基础设施,一般来说docker 1.12是比较稳定的，我们要在阿里云学生机上下载docker需要先添加docker的镜像源，像下面这样:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt;/etc/yum.repos.d/docker.repo &lt;&lt;EOF</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>然后通过下面的命令将服务器上的软件包信息先在本地缓存,以提高搜索安装软件的速度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum makecache</span><br></pre></td></tr></table></figure></p><p>现在你可以通过下面的命令来查看你新添加的软件源中可以安装的docker的版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-engine showduplicates</span><br></pre></td></tr></table></figure></p><p>这里我们选择安装docker 1.12.6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install docker-engine-1.12.6-1.el7.centos.x86_64</span><br></pre></td></tr></table></figure></p><p>启动docker:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ systemctl start docker</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下面我们需要到<code>docker　hub</code>镜像仓库中拉取镜像，为了加快拉取镜像的速度，我们在这里给<code>docker</code>配置一下加速器。国内的阿里云、daoclode、时速云等均有免费的docker加速器提供，大家可以自行google。这里我采用阿里云的镜像加速服务。因为在下面的kubeadm初始化master节点的时候，需要保证docker的<code>cgroup driver</code>类型与<code>kubelet</code>启动时使用的<code>cgroup driver</code>一致(<code>cgroupfs</code>或者<code>systemd</code>),所以这里也一并展示一下配置docker的<code>cgroup driver</code>的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://sw9esv3f.mirror.aliyuncs.com"</span>]，</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>因为修改了配置文件，所以这里需要重启一下docker.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p><h1 id="安装k8s相关镜像及组件"><a href="#安装k8s相关镜像及组件" class="headerlink" title="安装k8s相关镜像及组件"></a>安装k8s相关镜像及组件</h1><p>k8s集群分为master节点和node节点，master节点主要用于对于集群进行管理。k8s安装一般有两种安装方式，第一种为官方提供的工具kubeadm安装，第二种为二进制文件安装，此处主要介绍第一种</p><h2 id="相关镜像下载"><a href="#相关镜像下载" class="headerlink" title="相关镜像下载"></a>相关镜像下载</h2><p>由于使用kubeadm在安装的过程中会使用一些谷歌开源的镜像，但是国内无法访问到gcr.io，所以一般情况下我们需要翻墙拉取镜像，但是有以下前辈已经拉取到我们所需的镜像，并且传到了dockerhub上，我们可以直接使用这上面的镜像。并且刚才配置了加速器，所以拉取的速度也是很快的。这里就推荐两个docker hub上的仓库:<a href="https://hub.docker.com/search/?isAutomated=0&amp;isOfficial=0&amp;page=1&amp;pullCount=0&amp;q=alleyj&amp;starCount=0" target="_blank" rel="noopener">alleyj</a>,<a href="https://hub.docker.com/u/mirrorgooglecontainers/" target="_blank" rel="noopener">mirrorgooglecontainers</a><br>这里以alleyj的仓库为例，先需要从这个仓库里pull我们需要的镜像，然后使用<code>docker tag</code>命令将镜像的前缀改为<code>gcr.io/google_containers</code>,最后使用<code>docker rmi</code>去掉之前的镜像记录。可以使用如下脚本完成以上操作:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line">KUBE_VERSION=v1.7.5</span><br><span class="line">KUBE_PAUSE_VERSION=3.0</span><br><span class="line">ETCD_VERSION=3.0.17</span><br><span class="line">DNS_VERSION=1.14.4</span><br><span class="line"></span><br><span class="line">GCR_URL=gcr.io/google_containers</span><br><span class="line">DOCKERHUB_URL=alleyj</span><br><span class="line"></span><br><span class="line">images=(kube-proxy-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-scheduler-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-controller-manager-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-apiserver-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">pause-amd64:<span class="variable">$&#123;KUBE_PAUSE_VERSION&#125;</span></span><br><span class="line">etcd-amd64:<span class="variable">$&#123;ETCD_VERSION&#125;</span></span><br><span class="line">k8s-dns-sidecar-amd64:<span class="variable">$&#123;DNS_VERSION&#125;</span></span><br><span class="line">k8s-dns-kube-dns-amd64:<span class="variable">$&#123;DNS_VERSION&#125;</span></span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:<span class="variable">$&#123;DNS_VERSION&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker tag <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span> <span class="variable">$GCR_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker rmi <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>kubernetes各个版本所需要的镜像版本可以参见－&gt;<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#running-kubeadm-without-an-internet-connection" target="_blank" rel="noopener">这里</a></p><h2 id="组件下载"><a href="#组件下载" class="headerlink" title="组件下载"></a>组件下载</h2><p>这里我们还需要下载的组件是<code>kubelet</code>,<code>kubectl</code>,<code>kubeadm</code>,<code>kubernetes-cni</code>。首先添加yum源:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>然后可以通过下面的命令来查看该镜像源中可以安装的对应组件的版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum list kubeadm showduplicates</span><br><span class="line">$ yum list kubelet showduplicates</span><br><span class="line">$ yum list kubectl showduplicates</span><br><span class="line">$ yum list kubernetes-cni showduplicates</span><br></pre></td></tr></table></figure></p><p>这里，我们选择下面的版本安装.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubernetes-cni-0.5.1-0.x86_64 </span><br><span class="line">yum install -y kubelet-1.7.5-0.x86_64 </span><br><span class="line">yum install -y kubectl-1.7.5-0.x86_64 </span><br><span class="line">yum install -y kubeadm-1.7.5-0.x86_64</span><br></pre></td></tr></table></figure></p><p>启动kubelet.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></p><h2 id="配置kubelet"><a href="#配置kubelet" class="headerlink" title="配置kubelet"></a>配置kubelet</h2><p>kubelet负责在节点上启动，终止，重启容器。我们需要对其进行响应的配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/systemd/system/kubelet.service.d/20-pod-infra-image.conf &lt;&lt;EOF</span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"KUBELET_EXTRA_ARGS=--pod-infra-container-image=gcr.io/google_containers/pause-amd64:3.0"</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>上面配置的是kubelet的启动参数，指定了pause容器镜像。这个pause容器在pod中担任Linux命名空间共享的基础,启用pid命名空间，开启init进程。更多关于pause容器的内容，可以看－&gt;<a href="https://jimmysong.io/posts/what-is-a-pause-container/" target="_blank" rel="noopener">这里</a><br>在kubeadm初始化master节点的过程中，我们还需要设置两个环境变量:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBE_REPO_PREFIX=<span class="string">"gcr.io/google_containers"</span></span><br><span class="line"><span class="built_in">export</span> KUBE_ETCD_IMAGE=<span class="string">"gcr.io/google_containers/etcd-amd64:3.0.17"</span></span><br></pre></td></tr></table></figure></p><p>这两个环境变量指定了kubernetes所需的系统镜像的前缀，和etcd镜像的完整名称。由于这些镜像现在都以gcr.io/google_containers为前缀存在于本地，所以不用考虑说以gcr.io/google_containers为前缀拉取不到镜像的问题。</p><p>配置完毕，我们重新启动kubelet:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure></p><h1 id="kubeadm初始化master节点"><a href="#kubeadm初始化master节点" class="headerlink" title="kubeadm初始化master节点"></a>kubeadm初始化master节点</h1><p>到目前为止，我们搭建单节点集群所需要的所有软件，镜像全部安装完毕。下面我们就是要使用kubeadm来初始化集群。这个地方就开始遇到各种坑了。首先，在<code>kubeadm init</code>之前我们需要<strong>保证本机的<code>docker</code>和<code>kubelet</code>服务都处于运行状态</strong>.所以我们先来确认一下这两个服务是否都跑起来了:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status docker</span><br><span class="line">$ systemctl status kubelet</span><br></pre></td></tr></table></figure></p><p>如果你在运行上面的两个命令后看到的都是绿色，那么很幸运，你跳过了这个坑。不幸的是，笔者的kubelet一直无法跑起来。<code>systemctl status kubelet</code>的输出如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf, 20-pod-infra-image.conf</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since 日 2018-04-22 10:26:38 CST; 1s ago</span><br><span class="line">     Docs: http://kubernetes.io/docs/</span><br><span class="line">  Process: 21169 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_SYSTEM_PODS_ARGS $KUBELET_NETWORK_ARGS $KUBELET_DNS_ARGS $KUBELET_AUTHZ_ARGS $KUBELET_CADVISOR_ARGS $KUBELET_CGROUP_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=255)</span><br><span class="line"> Main PID: 21169 (code=exited, status=255)</span><br><span class="line"></span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --seccomp-profile-root string                         &lt;Warning: Alpha feature&gt; ...comp&quot;)</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --stderrthreshold severity                            logs at or above this thr...ult 2)</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: -v, --v Level                                             log level for V logs</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --version version[=true]                              Print version information and quit</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --vmodule moduleSpec                                  comma-separated list of p...ogging</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ systemd[1]: kubelet.service: main process exited, code=exited, status=255/n/a</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --volume-plugin-dir string                            The full path of the dire...xec/&quot;)</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: F0422 10:26:38.470722   21169 server.go:145] unknown flag: --require-kubeconfig</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ systemd[1]: Unit kubelet.service entered failed state.</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ systemd[1]: kubelet.service failed.</span><br></pre></td></tr></table></figure></p><p>其实，现在看来这个地方也不叫做坑，上面的输出倒数第3行已经说的很清楚了<code>unknown flag: --require-kubeconfig</code>。这说明kubelet的启动参数中出现了一个它不认的flag.(笔者装的时候一直在查看kubelet的状态，就是没有好好看log，导致这里花费了许多时间。这说明仔细看log真的很重要!!!)。下面我们就去看看kubelet启动参数的配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br></pre></td></tr></table></figure></p><p>文件内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--kubeconfig=/etc/kubernetes/kubelet.conf --require-kubeconfig=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_NETWORK_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin&quot;</span><br><span class="line">Environment=&quot;KUBELET_DNS_ARGS=--cluster-dns=10.96.0.10 --cluster-domain=cluster.local&quot;</span><br><span class="line">Environment=&quot;KUBELET_AUTHZ_ARGS=--authorization-mode=Webhook --client-ca-file=/etc/kubernetes/pki/ca.crt&quot;</span><br><span class="line">Environment=&quot;KUBELET_CADVISOR_ARGS=--cadvisor-port=0&quot;</span><br><span class="line">Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=systemd&quot;</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_SYSTEM_PODS_ARGS $KUBELET_NETWORK_ARGS $KUBELET_DNS_ARGS $KUBELET_AUTHZ_ARGS $KUBELET_CADVISOR_ARGS $KUBELET_CGROUP_ARGS $KUBELET_EXTRA_ARGS</span><br></pre></td></tr></table></figure></p><p>果真，在KUBELET_KUBECONFIG_ARGS中有一个参数<code>--require-kubeconfig=true</code>，去掉即可。<br>下面重新启动kubelet:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure></p><p>查看kubelet的状态，发现kubelet仍然没有运行起来:&lt;(<br>下面查看一下系统log,看看究竟发生了啥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -n 10 /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure></p><p>输出如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --authorization-mode has been deprecated, This parameter should be <span class="built_in">set</span> via the config file specified by the Kubelet<span class="string">'s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.</span></span><br><span class="line"><span class="string">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --client-ca-file has been deprecated, This parameter should be set via the config file specified by the Kubelet'</span>s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ <span class="keyword">for</span> more information.</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --cadvisor-port has been deprecated, The default will change to 0 (disabled) <span class="keyword">in</span> 1.12, and the cadvisor port will be removed entirely <span class="keyword">in</span> 1.13</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --cgroup-driver has been deprecated, This parameter should be <span class="built_in">set</span> via the config file specified by the Kubelet<span class="string">'s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.</span></span><br><span class="line"><span class="string">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --fail-swap-on has been deprecated, This parameter should be set via the config file specified by the Kubelet'</span>s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ <span class="keyword">for</span> more information.</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: I0422 10:46:38.716591   21994 feature_gate.go:226] feature gates: &amp;&#123;&#123;&#125; map[]&#125;</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: F0422 10:46:38.716693   21994 server.go:218] unable to load client CA file /etc/kubernetes/pki/ca.crt: open /etc/kubernetes/pki/ca.crt: no such file or directory</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ systemd: kubelet.service: main process exited, code=exited, status=255/n/a</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ systemd: Unit kubelet.service entered failed state.</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ systemd: kubelet.service failed.</span><br></pre></td></tr></table></figure></p><p>输出的第三行有这样一条：<code>unable to load client CA file /etc/kubernetes/pki/ca.crt: open /etc/kubernetes/pki/ca.crt: no such file or directory</code><br>关于这个客户端证书，笔者自己也没有怎么搞明白，后面需要接着研究。但是貌似这个证书是在<code>kubeadm init</code>的过程中创建的。所以笔者采取的方法是首先进行<code>kubeadm init</code>操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --apiserver-advertise-address=&lt;你的服务器ip&gt; --kubernetes-version=v1.7.5 --pod-network-cidr=10.244.0.0/12</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.</span><br><span class="line">[init] Using Kubernetes version: v1.7.5</span><br><span class="line">[init] Using Authorization modes: [Node RBAC]</span><br><span class="line">[preflight] Skipping pre-flight checks</span><br><span class="line">[kubeadm] WARNING: starting in 1.8, tokens expire after 24 hours by default (if you require a non-expiring token use --token-ttl 0)</span><br><span class="line">[certificates] Using the existing CA certificate and key.</span><br><span class="line">[certificates] Using the existing API Server certificate and key.</span><br><span class="line">[certificates] Using the existing API Server kubelet client certificate and key.</span><br><span class="line">[certificates] Using the existing service account token signing key.</span><br><span class="line">[certificates] Using the existing front-proxy CA certificate and key.</span><br><span class="line">[certificates] Using the existing front-proxy client certificate and key.</span><br><span class="line">[certificates] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/admin.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/scheduler.conf&quot;</span><br><span class="line">[apiclient] Created API client, waiting for the control plane to become ready</span><br></pre></td></tr></table></figure></p><p>初始化的过程卡在了上面输出的地方。其实想想这个过程绝对是会卡住的，毕竟现在<code>kubelet</code>都没有跑起来。如果你的kubelet已经跑起来了，但是这个<code>kubeadm init</code>还是会卡住，那么就有可能是你的<strong>docker的cgroup driver的类型与kubelet启动参数中指定的cgroup driver类型不一致导致的</strong>,你需要做的就是统一这两者之间的类型。</p><p>现在，让我们<code>Ctrl+C</code>终止上述的<code>kubeadm init</code>过程，然后重新启动我们的kubelet:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure></p><p>查看kubelet的状态，kubelet已经跑起来了，乐乐乐:&gt;)</p><p>下面我们再次<code>kubeadm init</code>,注意这次我们需要加上<code>--skip-preflight-checks</code>跳过前期检查。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --apiserver-advertise-address=&lt;你的服务器ip&gt; --kubernetes-version=v1.7.5 --pod-network-cidr=10.244.0.0/12 --skip-preflight-checks</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.</span><br><span class="line">[init] Using Kubernetes version: v1.7.5</span><br><span class="line">[init] Using Authorization modes: [Node RBAC]</span><br><span class="line">[preflight] Skipping pre-flight checks</span><br><span class="line">[kubeadm] WARNING: starting in 1.8, tokens expire after 24 hours by default (if you require a non-expiring token use --token-ttl 0)</span><br><span class="line">[certificates] Using the existing CA certificate and key.</span><br><span class="line">[certificates] Using the existing API Server certificate and key.</span><br><span class="line">[certificates] Using the existing API Server kubelet client certificate and key.</span><br><span class="line">[certificates] Using the existing service account token signing key.</span><br><span class="line">[certificates] Using the existing front-proxy CA certificate and key.</span><br><span class="line">[certificates] Using the existing front-proxy client certificate and key.</span><br><span class="line">[certificates] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/admin.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/scheduler.conf&quot;</span><br><span class="line">[apiclient] Created API client, waiting for the control plane to become ready</span><br><span class="line">[apiclient] All control plane components are healthy after 40.004549 seconds</span><br><span class="line">[token] Using token: xxxxxxxxxxxxxxxxx</span><br><span class="line">[apiconfig] Created RBAC rules</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line">[addons] Applied essential addon: kube-dns</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run (as a regular user):</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  http://kubernetes.io/docs/admin/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join --token xxxxx x.x.x.x:6443</span><br></pre></td></tr></table></figure></p><p>这下,<code>kubeadm init</code>终于成功了、了、了…</p><p>正如上面的输出所示，如果你需要让非root用户能够使用你的集群，你需要以该非root用户身份执行下面的命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure></p><p>现在你可以使用下面的命令来查看你的集群的运行状况了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namepaces</span><br><span class="line">$ kubectl get nodes </span><br><span class="line">$ kubectl get cs</span><br></pre></td></tr></table></figure></p><p>在笔者的机器上，kube-system中的kube-dns对应的pod的状态一直处于异常。这个就需要配置<code>overlay network</code>来解决。</p><h1 id="配置overlay-network"><a href="#配置overlay-network" class="headerlink" title="配置overlay network"></a>配置overlay network</h1><p>笔者开始的时候采用的是flannel来配置的<code>overlay network</code>,但是flannel并没有解决kube-dns对应的pod的异常状态，并且网上有声音说flannel与阿里云的主机兼容性不好。所以后面是根据<a href="https://medium.com/@jmarhee/note-on-troubleshooting-kubeadm-managed-kubernetes-cluster-setups-2b2c8248a4e8" target="_blank" rel="noopener">文章</a>来配置的Weave。但是目前团队的生产环境的集群的<code>overlay network</code>使用的是flannel，跑的也挺好的。所以我感觉这个东西也是具有很大的差异性的:&gt;),这里就一并写一下使用flannel、weave来配置集群<code>overlay network</code>的命令。下面的命令都是可以直接使用的。</p><h2 id="使用flannel"><a href="#使用flannel" class="headerlink" title="使用flannel"></a>使用flannel</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --namespace kube-system apply -f https://raw.githubusercontent.com/coreos/flannel/v0.8.0/Documentation/kube-flannel-rbac.yml</span><br><span class="line">$ rm -rf kube-flannel.yml </span><br><span class="line">$ wget https://raw.githubusercontent.com/coreos/flannel/v0.8.0/Documentation/kube-flannel.yml</span><br><span class="line">$ sed -i <span class="string">'s/quay.io\/coreos\/flannel:v0.8.0-amd64/registry.cn-hangzhou.aliyuncs.com\/szss_k8s\/flannel:v0.8.0-amd64/g'</span> ./kube-flannel.yml</span><br><span class="line">$ kubectl --namespace kube-system apply -f ./kube-flannel.yml</span><br></pre></td></tr></table></figure><h2 id="使用weave"><a href="#使用weave" class="headerlink" title="使用weave"></a>使用weave</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> kubever=$(kubectl version | base64 | tr -d <span class="string">'\n'</span>)</span><br><span class="line">$ kubectl apply -f <span class="string">"https://cloud.weave.works/k8s/net?k8s-version=<span class="variable">$kubever</span>"</span></span><br></pre></td></tr></table></figure><p>由于我是改用weave才就kube-dns的pod才正常工作，所以我推荐大家使用weave来配置。</p><h1 id="最后一个问题"><a href="#最后一个问题" class="headerlink" title="最后一个问题"></a>最后一个问题</h1><p>至此，我们的单节点kubernetes集群就搭建完成了。大家在部署应用的时候可能还会遇到另外的一个问题。当你创建了deployment,service之后，查看你的应用的pod，你会发现所有的pod都处于<code>pending</code>的状态，<code>kubectl describe</code>发现这些pod都没有被调度。这是怎么回事呢？原来，我们现在只有一个节点，而kubernets的调度策略默认是不支持在master节点上放置应用pod的，具体的可以查看这个<a href="(https://github.com/kubernetes/kubernetes/issues/49440">issue</a>,可以使用下面的命令，来去掉这样的调度限制:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint nodes &lt;nodeName&gt; node-role.kubernetes.io/master:NoSchedule-</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大致总结一下安装kubernetes集群的流程：</p><ul><li>准备系统环境</li><li>安装Docker</li><li>安装Kubernetes相关组件</li><li>Kubeadm init Master节点</li><li>安装Overlay Network</li><li>Join Node节点</li></ul><p>这里，由于只有一台主机，所以最后一步没有进行。在整个安装过程中，大致流程是不会改变的。但是可能还是会遇到各种各样的问题。这一次安装的过程让我深刻的体会到认真查看log的重要性，还有依据log去google的重要性。不管什么问题，只要你坚持，最终肯定会找到解决问题的方法。最后，感谢万能的互联网。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubeadm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL重难点总结</title>
      <link href="/2018/04/11/something-about-SQL/"/>
      <url>/2018/04/11/something-about-SQL/</url>
      
        <content type="html"><![CDATA[<p>最近在看数据库的书籍，对数据库的操作，尤其是SQL语言更加熟悉了，概念方面理顺了许多。对以前比较陌生的东西也不再有畏惧感。所以写这篇博客把重难点的部分一并总结一下。</p><p>以下的SQL基于<strong>SQL必知必会</strong>书上的五张表:Vendors,Products,Customers,Orders,OrderItems.</p><h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>如下我们可以计算供应商DLL01提供的产品数目：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="string">"DLL01"</span>;</span><br></pre></td></tr></table></figure></p><p>那如果我们需要分别计算每一个供应商的提供的产品的数量呢?这个时候就是分组大显身手的时候了。<strong>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算</strong>。如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure></p><p>上面的SELECT语句指定了两个列：vend_id包含产品供应商的ID,num_prods为计算字段(用COUNT(*)函数建立)。<code>GROUP BY</code>子句指示DBMS按照vend_id排序并分组数据。这就会对每个vend_id而不是整个表计算一次num_prods.</p><h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>除了可以使用<code>GROUP BY</code>进行分组之外，还可以过滤分组，决定那些分组需要，那些分组可以滤去。过滤分组通过HAVING子句进行。例如下面过滤出产品数大于等于2的分组:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id </span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>上面的语句中只有产品数目大于等于2的分组才能够被选择出来。</p><h2 id="HAVING-VS-WHERE"><a href="#HAVING-VS-WHERE" class="headerlink" title="HAVING VS WHERE"></a>HAVING VS WHERE</h2><p>众所周知，<code>WHERE</code>子句具有过滤的作用，但是<code>WHERE</code>子句指定的是过滤而不是分组，事实上<code>WHERE</code>没有分组的概念。<code>HAVING</code>非常类似于<code>WHERE</code>,目前绝大多数的<code>WHERE</code>子句都可以用<code>HAVING</code>来替代，唯一的差别是，<code>WHERE</code>过滤行，而<code>HAVING</code>过滤分组。另一种理解方式是：<code>WHERE</code>在数据分组前进行过滤，<code>HAVING</code>在数据分组后进行过滤。<code>WHERE</code>排除的行不包括在分组中。这可能会改变计算值，从而影响<code>HAVING</code>子句中基于这些值过滤掉的分组。<code>HAVING</code>与<code>WHERE</code>非常类似，如果不指定<code>GROUP BY</code>,则大多数的DBMS会同等的对待他们。不过我们自己还是需要区分这一点的，使用<strong>HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤</strong>。</p><h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><table><thead><tr><th style="text-align:center">子句</th><th style="text-align:center">　说明　</th><th style="text-align:center">　是否必须使用　</th></tr></thead><tbody><tr><td style="text-align:center">SELECT</td><td style="text-align:center">要返回的列或表达式</td><td style="text-align:center">是　</td></tr><tr><td style="text-align:center">FROM</td><td style="text-align:center">从中检索数据的表</td><td style="text-align:center">　仅在从表选择数据时使用　</td></tr><tr><td style="text-align:center">WHERE</td><td style="text-align:center">行级过滤</td><td style="text-align:center">　否　</td></tr><tr><td style="text-align:center">GROUP BY</td><td style="text-align:center">分组说明</td><td style="text-align:center">　仅在按组计算聚集时使用　</td></tr><tr><td style="text-align:center">HAVING</td><td style="text-align:center">组级过滤</td><td style="text-align:center">　否　</td></tr><tr><td style="text-align:center">ORDER BY</td><td style="text-align:center">输出排序顺序</td><td style="text-align:center">　否　</td></tr></tbody></table><h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>SQL最强大的功能之一就是能在数据查询的执行中联结(join)表，联结是利用SQL的SELECT能执行的最重要的操作。为什么要使用联结操作呢？将数据分解为多个表能更有效的存储，更方便的处理，并且可伸缩性更好，这是关系型数据库的最大的特点。但是这些好处是有代价的。我们需要通过联结多个表返回一组输出，联结在运行时关联表中的正确的行。</p><h2 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors,Products</span><br><span class="line"><span class="keyword">WHERE</span> Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure><p>如上，我们用<code>WHERE</code>子句将Products表的外键vend_id与它所引用的Vendors表的主键vend_id关联起来,这样就建立了这两张表的联结。上面的联结的大致执行过程是这样的：首先对于Vendors表中的每一个元组，都去比对Products表中的每一个元组，如果满足Vendors.vend_id = Products.vend_id,就从这两个元组中提取出指定的列，然后放到输出中，接着就去取Vendors表中的下一个元组，重复上面的过程。Vendors表中的所有元组执行完毕。这里有一个问题需要注意：对于Vendors表中的一个元组，如果在Products表中找不到满足Vendors.vend_id = Products.vend_id的元组(也就是该供应商没有提供产品)，这时候Vendors表中的这个元组放不放到输出中呢？对于上面的SQL，这样的元组不会放到输出中。</p><p>上面使用的联结称为<strong>等值联结(equijoin)</strong>，它基于两个表之间的相等测试。这种联结也称为<strong>内连接(inner join)</strong>。其实，可以对这种联结使用稍微不同的语法，明确指定联结类型，就像下面这样:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Products</span><br><span class="line"><span class="keyword">ON</span> Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure></p><p>这条SQL语句和前面的那条语句所起的作用是等价的。这里，两个表之间的关系是以<code>INNER JOIN</code>指定的部分<code>FROM</code>子句，在使用这种语法时，联结条件用特定的<code>ON</code>子句而不是<code>WHERE</code>子句给出，传递给<code>ON</code>的实际条件与传递给<code>WHERE</code>的相同。</p><h2 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h2><p>SQL不限制一条SELECT语句中可以联结的表的数目，创建联结的基本规则也相同，首先列出所有表，然后定义表之间的关系，就像下面这样：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,vend_name,prod_price,quantity</span><br><span class="line"><span class="keyword">FROM</span> OrderItems,Products,Vendors</span><br><span class="line"><span class="keyword">WHERE</span> Products.vend_id = Vendors.vend_id</span><br><span class="line"><span class="keyword">AND</span> OrderItems.prod_id = Products.prod_id</span><br><span class="line"><span class="keyword">AND</span> order_num = <span class="number">20007</span>;</span><br></pre></td></tr></table></figure></p><p>上面我们使用的只是内联结(也叫等值联结)的简单联结，下面我们看其他联结：自联结(self-join)、外联结(outer join).</p><h2 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h2><p>使用表别名能够在一个SELECT语句中不止一次的引用相同的表，我们可以使用利用表别名来完成同一个表的自联结。如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1.cust_id, c1.cust_name,c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">AS</span> c1,Customers <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name = c2.cust_name</span><br><span class="line"><span class="keyword">AND</span> c2.cust_contact = <span class="string">"Jim Jones"</span>;</span><br></pre></td></tr></table></figure></p><p>这条语句检索出的就是和Jim Jones在同一家公司工作的的雇员的信息。</p><h2 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h2><p>内连接是将一个表中的行与另一个表中的行相关联，但有时候需要关联没有关联行的那些行。例如可能需要使用联结完成以下工作：<br>－　对每一个顾客下的订单数进行计数，包括那些至今尚未下订单的顾客；<br>－　列出所有产品以及订购数量，包括没有人订购的产品；<br>－　计算平均销售规模，包括那些至今尚未下订单的顾客。<br>在上述例子中，联结包含了那些在相关表中没有关联行的行。这种联结称为<strong>外联结</strong>。如下的例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure></p><p>这条SELECT语句使用了关键字<code>OUTER JOIN</code>来指定了联结类型。与内连接关联两个表中的行不同，外联结还包括没有关联的行。在使用<code>OUTER JOIN</code>语法时，必须使用RIGHT或者LEFT关键字指定包括其所有行的表(<code>RIGHT</code>指出的是<code>OUTER JOIN</code>右边的表，而<code>LEFT</code>指出的是<code>OUTER JOIN</code>左边的表)，上面的例子使用<code>LEFT OUTER JOIN</code>从<code>FROM</code>子句左边的表(Customers)中选择所有行。为了从右边的表中选择所有的行，需要使用<code>RIGHT OUTER JOIN</code>,如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers　<span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure></p><h2 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h2><p>如下，按照顾客的id分组，查询每个顾客的订单数。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,</span><br><span class="line">    <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders </span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br></pre></td></tr></table></figure></p><p>这里使用的是内联结，所以不会包含没有下订单的顾客分组。如果要包含他们就需要使用<code>LEFT OUTER JOIN</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>限制资源访问</title>
      <link href="/2018/03/09/limiting-use/"/>
      <url>/2018/03/09/limiting-use/</url>
      
        <content type="html"><![CDATA[<p>昨天爬了一下小幸运，爬取了大约4000条左右的愿望信息。爬取的过程中我没有设置代理和设置延迟，任由代码迅速的发送请求。爬取的过程相当顺利。这说明小幸运的服务端没有做限制来访IP请求频率的处理。这很容易引发DDOS(分布式拒绝服务)攻击。基于此，我研究了一下对客户端请求限制的方法。收获记录如下!</p><p>NGINX有多个内建的模块可以帮助我们控制客户端对应用的使用。比如:限制连接数，限制请求和响应的速率，限制带宽等。</p><h2 id="限制连接"><a href="#限制连接" class="headerlink" title="限制连接"></a>限制连接</h2><p>我们可以通过某一个预定义的变量来限制某一客户端的连接数，通常这个预定义的变量是客户端的IP地址。我们可以构建一个共享内存的域来存储连接指标，然后使用<strong>limit_conn</strong>指令来限制打开的连接数，具体的配置如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=limitbyaddr:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">limit_conn_status</span> <span class="number">429</span>;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">limit_conn</span> limitbyaddr <span class="number">40</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述配置文件创建了一个共享内存区域(zone)并命名为limitbyaddr。使用的预定义的变量是<strong>$binary_remote_addr</strong>,也就是客户端的IP地址的二进制形式。共享内存区域的大小被设置为了10MB.<strong>limit_conn</strong>指令需要两个参数：一个是<strong>limit_conn_zone</strong>的名字，第二个是允许的最大连接数。<strong>limit_conn_status</strong>指令设置连接数超过指定值之后的服务器响应,默认的响应是503(service unavailable)，在上述配置中如果同一个客户端同时打开的连接数超过40,那么就会收到429响应(too many requests)。<strong>limit_conn_zone</strong>只在http指令块中可用，<strong>limit_conn</strong>和<strong>limit_conn_status</strong>在http,server,location指令块中都可用。</p><h2 id="限制请求速率"><a href="#限制请求速率" class="headerlink" title="限制请求速率"></a>限制请求速率</h2><p>通过预定义的变量可以来限制请求的速率，通常这个预定义的变量也是客户端的IP地址。利用rate-limiting模块来限制请求的速率。配置如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=limitbyaddr:<span class="number">10m</span> rate=1r/s;</span><br><span class="line">    <span class="attribute">limit_req_status</span> <span class="number">429</span>;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">limit_req</span> zone=limitbyaddr burst=<span class="number">10</span> nodelay;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个参数:设置使用哪个配置区域来做限制，与上面limit_req_zone 里的name对应<br>第二个参数：burst=5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区，当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内<br>第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回<strong>limit_req_status</strong>的值，如果没有设置，则所有请求会等待排队</p><p>上述配置创建了一个共享内存的区域(zone)并将其命名为limitbyaddr.预定义的键是客户端的IP地址的二进制形式。共享内存区域的大小被设置成了10MB,这个共享内存区域还设置了rate的关键字参数，用来指定允许客户端请求的频率上限。<strong>limit_req</strong>指令需要两个可选的关键字参数：zone,burst。zone指明了使用的共享内存区域。当某一个共享内存区域的请求速率达到了之后，请求就会被延迟处理，直到达到burst值。burst值默认为0.<strong>limit_req</strong>的第三个可选参数是:<strong>nodelay</strong>,此参数使客户端在受限制之前无延迟地使用其突发。</p><h2 id="限制带宽"><a href="#限制带宽" class="headerlink" title="限制带宽"></a>限制带宽</h2><p>如果你需要限制每个客户端的下载带宽，你可以使用NGINX的<strong>limit_rate</strong>和<strong>limit_rate_after</strong>指令来实现:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /download/ &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">limit_rate_after</span> <span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">limit_rate</span> <span class="number">1m</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的配置指明了对于/download/开头的URL的请求，在成功返回10MB的数据之后，开始以每秒1MB的速率传输数据至客户端。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>木犀后端分享--hexo博客搭建</title>
      <link href="/2018/03/04/build-a-blog-with-hexo/"/>
      <url>/2018/03/04/build-a-blog-with-hexo/</url>
      
        <content type="html"><![CDATA[<p>用hexo搭建一个博客的简要步骤.</p><h1 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h1><ul><li>github账号</li><li>git</li><li>nodeJS和npm</li></ul><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><p>1.通过<a href="https://www.jianshu.com/p/8671e439a811" target="_blank" rel="noopener">下载nvm</a>来下载和管理node和npm(推荐)<br>2.在github上新建一个名为“&lt;你的github用户名&gt;.github.io”的仓库<br>3.在系统某处依次运行下列命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>这时，你如果访问<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a> 就可以发现你的博客已经在本地跑起来了。<br>4.修改博客根目录下<strong>_config.yml</strong>配置文件,改动两个地方:url,deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Hexo</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: John Doe</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://yoursite.com   #比如，改成我的配置 url: http://andrewpqc.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line">  </span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &apos;&apos;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line">  </span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br><span class="line"></span><br><span class="line">#上面的deploy的配置改成我的就是下面的这样:</span><br><span class="line">#deploy: </span><br><span class="line">#  type: git</span><br><span class="line">#  repo: https://github.com/Andrewpqc/Andrewpqc.github.io.git</span><br><span class="line">#  branch: master</span><br></pre></td></tr></table></figure></p><p>5.下载git部署插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>6.部署<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g <span class="comment">#生成并部署</span></span><br></pre></td></tr></table></figure></p><p>此时打开浏览器，输入https://&lt;你的github用户名&gt;.github.io就会发现你的博客已经远端部署成功了。</p><h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">$ hexo p == hexo publish</span><br><span class="line">$ hexo g == hexo generate               <span class="comment">#生成</span></span><br><span class="line">$ hexo s == hexo server                 <span class="comment">#启动服务预览</span></span><br><span class="line">$ hexo d == hexo deploy                 <span class="comment">#部署</span></span><br><span class="line">$ hexo server                           <span class="comment">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span></span><br><span class="line">$ hexo server -s                        <span class="comment">#静态模式</span></span><br><span class="line">$ hexo server -p 5000                   <span class="comment">#更改端口</span></span><br><span class="line">$ hexo server -i 192.168.1.1            <span class="comment">#自定义IP</span></span><br><span class="line">$ hexo clean                            <span class="comment">#清除缓存，网页正常情况下可以忽略此条命令</span></span><br></pre></td></tr></table></figure><p>更多具体命令请看-&gt;<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">这儿</a></p><h1 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h1><p>hexo有很多的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>可以使用，使用起来也非常简单。<strong>hexo init</strong>之后，博客文件夹中默认安装了landscape主题。如果我们还想要使用其他的主题可以直接到github上把该主题的仓库克隆到landscape所在的目录。然后更改博客根目录下的_config.yml中的theme配置选项即可实现主题的切换。</p><p>hexo主题的页面布局、配色、功能等方面一般都给了用户较大的自定义权限，用户可以通过修改主题文件夹下的_config.yml配置文件和下载插件的形式来实现自定义。<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">1</a><br>接下来，就开始探索你的博客吧!</p><h1 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h1><p>1.备份很重要。<br>2.hexo消失了怎么办。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baoyuzhang.github.io/2017/05/12/【Hexo搭建独立博客全纪录】（三）使用Hexo搭建博客/" target="_blank" rel="noopener">使用Hexo搭建博客</a><br><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br><a href="http://tengj.github.io/2016/02/26/hexo2/" target="_blank" rel="noopener">hexo主题下载及配置</a><br><a href="https://pengbinlee.github.io/NexT-主题的安装及个性化设置/" target="_blank" rel="noopener">NexT主题个性化配置</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go语言并发编程——goroutine和通道</title>
      <link href="/2018/02/23/go-concurrency/"/>
      <url>/2018/02/23/go-concurrency/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/go.jpeg" alt="go"><br>Go语言有两种并发编程的风格：一种是goroutine和通道，它们支持通信顺序进程(Communicating Sequential Process,CSP),CSP是一种并发的模式，可以在不同的执行体(goroutine)之间传递值，但是变量本身局限于单一的执行体。另一种是共享内存多线程的传统模型，它们和在其他的主流语言中使用的线程类似。在这里主要介绍goroutine和通道。</p><h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="概念及本质"><a href="#概念及本质" class="headerlink" title="概念及本质"></a>概念及本质</h2><p>在Go语言中每一个并发执行的活动称为goroutine.这一概念初看上去和线程有些相似，但实际上<strong>goroutine并不是线程，它只是对线程的多路复用</strong>。一个goroutine在<strong>启动时只需要一个非常小的栈</strong>，并且这个栈可以按需扩展和缩小(在GO1.4中，goroutine启动时的栈大小仅为2KB)。正是因为<strong>goroutine的轻量级</strong>，所以<strong>goroutine的数量可以比线程的数量多得多</strong>。当一个goroutine被阻塞时，它也会阻塞所复用的操作系统线程，而运行时环境(runtime)则会把位于被阻塞线程上的其他goroutine移动到其他未阻塞的线程上继续运行。</p><h2 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h2><p>goroutine的用法非常简单:只要把go关键字添加到任意一个具名函数或者匿名函数的前面，该函数就会成为一个goroutine。特殊的，当一个程序启动时，有一个goroutine来调用main函数，称它为主goroutine。其他的新的goroutine都是通过go语句进行创建。go语句本身的执行立即完成，并不会阻塞程序继续向下执行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f()   <span class="comment">//调用f();等待它返回</span></span><br><span class="line"><span class="keyword">go</span> f()<span class="comment">//新建一个调用f()的goroutine,不用等待</span></span><br></pre></td></tr></table></figure></p><p>下面是一个使用goroutine的例子:主goroutine中新建了一个goroutine用于指示程序仍然在运行，而主goroutine本身仍然在进行求45个斐波那契数的计算。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    fmt.Println(fib(<span class="number">45</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"\r%"</span>, d)</span><br><span class="line">            time.Sleep(delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(a<span class="number">-1</span>) + fib(a<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过运行该程序我们可以发现，提示符在运行的那一刻起就开始了，与此同时程序在进行着计算，几秒钟之后程序打印出第45个斐波那契数，然后主goroutine退出，我们发现主goroutine创建的goroutine也被暴力的直接终结了。</p><h2 id="等待goroutine"><a href="#等待goroutine" class="headerlink" title="等待goroutine"></a>等待goroutine</h2><p>我们来看下面这个并发程序：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetters</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="string">'A'</span>;i&lt;<span class="number">10</span>+<span class="string">'A'</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"% "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> printNumbers()</span><br><span class="line">    <span class="keyword">go</span> printLetters()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们运行程序，发现程序并没有产生任何输出！这是因为在该用例中，主goroutine在它的两个goroutine能够产生输出之前就已经结束了，结束之前还暴力的终结了刚刚创建的两个goroutine。显然，我们需要一种机制使程序可以在确保所有goroutine都已经执行完毕的情况下，再执行下一项工作。</p><p>为此，GO语言在<strong>sync</strong>包中提供了一种名为<strong>等待组</strong>(WaitGroup)的机制，它的运作方式非常简单直接:</p><ul><li>声明一个等待组；</li><li>使用<strong>Add</strong>方法为等待组的计时器设置值;</li><li>当一个goroutine完成它的工作时，使用<strong>Done</strong>方法对等待组的计时器执行减一操作；</li><li>调用<strong>Wait</strong>方法，该方法将一直阻塞，直达等待组计数器的值变为0.</li></ul><p>下面是添加等待的版本:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(wg *sync.WaitGroup)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetters</span><span class="params">(wg *sync.WaitGroup)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="string">'A'</span>;i&lt;<span class="number">10</span>+<span class="string">'A'</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"% "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    g.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> printNumbers(&amp;wg)</span><br><span class="line">    <span class="keyword">go</span> printLetters(&amp;wg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出(您的输出可能有所不同):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A B C D E F G H I J </span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><p>如上，程序产生了我们期望的输出:&gt;)</p><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>在上面我们已经知道怎样通过go关键字将普通函数转换成goroutine以便让其独立运行，还知道可以设置等待组来同步独立运行的多个goroutine。下面我们将要学习如何使用通道在多个不同的goroutine之间通信。</p><h2 id="基本语法及性质"><a href="#基本语法及性质" class="headerlink" title="基本语法及性质"></a>基本语法及性质</h2><p>通道是一种带有类型的值，它可以让不同的goroutine互相通信。通道用make函数创建，该函数在被调用之后将返回一个指向底层数据结构的引用作为结果值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unbufferedChannel:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">bufferChannel:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>如上，我们创建了两个可以容纳int类型值的通道，一个是<strong>无缓冲通道</strong>，一个是<strong>有缓冲通道</strong>。如果用户在创建通道的时候，向make函数提供了可选的第三个参数，那么make函数将创建出一个带有给定大小缓冲区的缓冲通道;未给定可选参数或者可选参数给定的为0,创建的都是无缓冲通道，也叫做<strong>同步通道</strong>。</p><p>像map一样，通道是一个使用make创建的数据结构的引用，当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用同一份数据结构。</p><p>通道有两个主要操作，发送和接收，发送语句从一个goroutine传输一个值到另一个在执行接收表达式的goroutine。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x <span class="comment">//把x发送到通道ch</span></span><br><span class="line">a:= &lt;-ch <span class="comment">//从通道ch取值赋给变量a</span></span><br><span class="line">&lt;-ch    <span class="comment">//从通道ch取一个值，并丢弃。</span></span><br></pre></td></tr></table></figure></p><p>通道还支持第三个操作：关闭。关闭操作设置一个标志位来指示值当前已经发送完毕，这个通道后面没有值了。针对关闭后的通道的发送操作将导致宕机。在一个已经关闭的通道上进行接收操作，将获取所有已经发送的值，直到通道为空，这时任何接收操作会立即完成，同时获取到一个通道元素对应的零值。关闭通道使用内置的close函数完成：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></p><h2 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h2><p>无缓冲通道上的发送操作将会阻塞，直到另一个goroutine在对应的通道上执行接收操作，这时值传送完成，两个goroutine都可以继续执行。相反，如果接收操作先执行，接收方goroutine将阻塞，直到另一个goroutine在通道上发送一个值。</p><p>使用无缓冲通道进行通信导致发送和接收goroutine同步化，因此，无缓冲通道才被称为同步通道。</p><p>利用无缓冲通道的同步化特点，我们也可以也可以实现上面等待组实现的功能:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    ch&lt;<span class="number">-1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetters</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="string">'A'</span>;i&lt;<span class="number">10</span>+<span class="string">'A'</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"% "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    ch&lt;<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch1,ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> printNumbers(ch1)</span><br><span class="line">    <span class="keyword">go</span> printLetters(ch2)</span><br><span class="line">    &lt;-ch1</span><br><span class="line">    &lt;-ch2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h2><p>缓冲通道有一个元素队列，队列的最大长度在创建的时候通过make的容量参数来设置，如下可以创建一个可以容纳三个字符串的缓冲通道:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>缓冲通道上的发送操作在队列的尾部插入一个元素，接收操作从队列的头部移除一个元素。如果通道满了，发送操作将会阻塞所在goroutine直到另一个goroutine对它进行接收操作来留出可用的空间。反过来，如果通道是空的，执行接收操作的goroutine阻塞，直到另一个goroutine在通道上发送数据。</p><p>通道既不满也不空时，接收操作和发送操作都不会阻塞，通过这种方式，通道的缓冲区将发送和接收操作进行了解耦。</p><p>有时，程序需要知道缓冲通道的缓冲区的容量或者当前存储的元素个数，可以通过内置的<strong>cap</strong>,<strong>len</strong>函数求得：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n:=<span class="built_in">cap</span>(ch)<span class="comment">//求缓冲通道的容量</span></span><br><span class="line">m:=<span class="built_in">len</span>(ch)<span class="comment">//求缓冲通道当前元素个数</span></span><br></pre></td></tr></table></figure></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>通道可以用来连接goroutine,这样一个输出是另一个的输入。这种情形叫<strong>管道</strong>(pipeline)。下面的程序由三个goroutine组成，它们被两个通道连接起来，从而形成了一个三级管道。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> x:=<span class="number">0</span>;;x++&#123;</span><br><span class="line">            naturals&lt;-x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            x:=&lt;-naturals</span><br><span class="line">            squares&lt;-x*x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printer(在主goroutine中)</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,&lt;-squares)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>counter产生连续的自然数，通过管道传输到squarer进行平方，平方后的结果又通过管道传输到printer打印出来。正如我们所预料的那样，程序输出了无限的平方序列0,1,4,9，…</p><p>如果我们想生成有限的数字怎么办呢？<br>如果发送方知道没有更多的数据需要发送了，告诉接受者所在goroutine可以停止等待是很有用的，这可以通过调用内置的close函数来关闭通道：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></p><p>在通道关闭后，任何后续的发送操作将会导致应用崩溃。当被关闭的通道被读完(就是最后一个发送值被接收)后，所有后续的接收操作顺畅进行，只是获取的是对应通道元素类型的零值。</p><p>没有一个直接的方式来判断是否通道已经关闭，但是这里有接收操作的一个变种，它产生两个结果：一个是接收到的通道值，另一个是一个布尔值(通常称之为ok),它为true时代表接收成功，为false代表当前的接收操作在一个关闭并且读完的通道上。利用这一特性我们可以修改squarer:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sqarer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        x,ok:=&lt;-naturals</span><br><span class="line">        <span class="keyword">if</span> !ok&#123;<span class="comment">//naturals通道已经关闭，并且值接收完成</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        squares&lt;-x*x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的语法比较笨拙，而模式比较通用，所以go语言提供了range循环语法以在通道上迭代。这个语法更方便接收在通道上所有发送值，接受完最后一个值后关闭循环。下面是利用这一特性改写之后的程序：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> x:=<span class="number">0</span>;x&lt;<span class="number">10</span>;x++&#123;</span><br><span class="line">            naturals&lt;-x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(naturals)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> x:=<span class="keyword">range</span> naturals&#123;</span><br><span class="line">            squares&lt;-x*x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(squares)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printer(在主goroutine中)</span></span><br><span class="line">    <span class="keyword">for</span> m:=<span class="keyword">range</span> squares&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结束时关闭每一个通道并不是必需的，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。</p><h2 id="缓冲与无缓冲的选择"><a href="#缓冲与无缓冲的选择" class="headerlink" title="缓冲与无缓冲的选择"></a>缓冲与无缓冲的选择</h2><p>缓冲通道和无缓冲通道的选择、缓冲通道容量的选择都会对程序的正确性产生影响。无缓冲通道提供强同步保障，因为每一次发送都需要和对应的接收同步；对于缓冲通道，这些操作则是解耦的。在通常情况下，如果我们知道要发送的值数量的上限，我们会创建一个容量为此上限的缓冲通道，在接收第一个值之前就完成所有的发送。</p><h1 id="goroutine和通道应用技巧"><a href="#goroutine和通道应用技巧" class="headerlink" title="goroutine和通道应用技巧"></a>goroutine和通道应用技巧</h1><h2 id="通用的并行循环模式"><a href="#通用的并行循环模式" class="headerlink" title="通用的并行循环模式"></a>通用的并行循环模式</h2><p>我们来看看一些通用的并行模式，来并行执行所有的循环迭代。考虑一个生成全尺寸图片缩略图的程序，下面的程序在每一个图像文件名字列表上进行循环，然后给每一个图像产生一副缩略图:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        <span class="keyword">if</span> _,err:=thumbnail.ImageFile(f);err!=<span class="literal">nil</span>&#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很显然，处理文件的顺序没有关系，因为每一个缩放操作和其他的操作独立。像这样由一些完全独立的子问题组成的问题称为<strong>高度并行</strong>。高度并行的问题是最容易实现并行的，有许多并行机制来实现线性扩展。如下，我们给每一个任务一个go关键字:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails2</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        <span class="keyword">go</span> thumbnail.ImageFile(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>让这些任务并行去执行。如果我们运行这个函数，会发现它运行的实在是太快了，快的让人不敢相信，并且它也没有按照我们的预期生成缩略图。原因是函数在没有完成想要完成的事情之前就已经返回了。它启动了所有的goroutine,每一个文件一个，但是没有等他们执行完毕。</p><p>要想解决上面的问题，方法就是使用上文中已经提到的<strong>同步通道</strong>或<strong>等待组</strong>。用这两种方法的示例代码如下:<br><strong>使用同步通道</strong>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails3</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    for_,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">            thumbnail.ImageFile(f)</span><br><span class="line">            ch&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> filenames&#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用等待组</strong>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails3</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    for_,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            thumbnail.ImageFile(f)</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="限制并发数量"><a href="#限制并发数量" class="headerlink" title="限制并发数量"></a>限制并发数量</h2><p>我们来看一个简单的网络爬虫,它以广度优先的顺序来探索网页的链接：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="keyword">string</span>)</span>[]<span class="title">string</span></span>&#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    list,err:=links.Extract(url)</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    worklist:=<span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;worklist&lt;-os.Args[<span class="number">1</span>:]&#125;()</span><br><span class="line"></span><br><span class="line">    seen:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> list:=<span class="keyword">range</span> worklist&#123;</span><br><span class="line">        <span class="keyword">for</span> _,url:=<span class="keyword">range</span> list&#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[url]&#123;</span><br><span class="line">                seen[url]=<span class="literal">true</span></span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">                    worklist&lt;-crawl(url)</span><br><span class="line">                &#125;(url)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序首先从命令行收集起始的url，然后并发的爬取这些页面并且从中提取出页面的新url,如果是之前已经爬取的页面则不再爬取，并且将这些新的url发送至通道中，供程序继续爬取。可见我们是通过对crawl的独立调用从而充分的利用了Web上的I/O并行机制。</p><p>这个爬虫高度并发，但是它有两个问题。一个是程序的并行度太高，一下子会创建太多的网络连接，超过程序能打开文件的限制。第二是这个程序永远不会结束。</p><p>无限制的并行通常不是一个好主意，因为系统中总有限制因素。例如对于计算型应用CPU核数，对于磁盘I/O操作磁头和磁盘的个数，下载流所使用的网络带宽，或者Web服务本身的容量等等。解决高并行的方法就是根据资源的可用情况限制并发的个数，以匹配合适的并行度。对于上面的程序我们有一个简单的方法就是确保对于<em>links.Extract()</em>的同时调用不超过n个。我们可以使用容量为n的缓冲通道来建立一个并发原语，称为<strong><em>计数信号量</em></strong>。概念上，对于缓冲通道中的n个空闲槽，每一个代表一个令牌，持有者可以执行，通过发送一个值到通道中领取令牌，从通道中接受一个值来释放令牌，创建一个新的空闲槽。这保证了在没有接收操作的时候，最多同时有n个发送。因为通道元素的类型在这里并不重要，所以我们使用struct{},它所占用的空间的大小为0.</p><p>同时，为了让程序终止，当任务列表为空且爬取goroutine都结束以后，需要从主循环退出。基于以上两点我们可以做出如下的改进:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="keyword">string</span>)</span>[]<span class="title">string</span></span>&#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    tokens&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;<span class="comment">//获取令牌</span></span><br><span class="line">    list,err:=links.Extract(url)</span><br><span class="line">    &lt;-tokens　　　　　　<span class="comment">//释放令牌</span></span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    worklist:=<span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    n ++  <span class="comment">//n用来记录任务列表中的任务个数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;worklist&lt;-os.Args[<span class="number">1</span>:]&#125;()</span><br><span class="line">    seen:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> ;n&gt;<span class="number">0</span>;n--&#123;</span><br><span class="line">        list := &lt;-worklist</span><br><span class="line">        <span class="keyword">for</span> _,link:=<span class="keyword">range</span> list&#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link]&#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(link <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">                    worklist&lt;-crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="节拍器"><a href="#节拍器" class="headerlink" title="节拍器"></a>节拍器</h2><p>在go语言的<strong>time包</strong>中内置了节拍器,time.Tick函数返回一个通道，它定期发送事件，像一个节拍器一样。每个事件的值是一个时间戳，一般我们不关心通道里面的内容，而是把它当做执行定时任务的工具:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Commencing countdown."</span>)</span><br><span class="line">    tick:=time.Tick(<span class="number">1</span>*time.Second)<span class="comment">//时间间隔为１s</span></span><br><span class="line">    <span class="keyword">for</span> countdown:=<span class="number">10</span>;countdown&gt;<span class="number">0</span>;countdown--&#123;</span><br><span class="line">        fmt.Println(countdown)</span><br><span class="line">        &lt;-tick</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，我们利用节拍器实现了一个倒计时的功能，每一次for循环会被阻塞一秒，这样程序就是一秒输出一个数字。</p><p>Tick函数很方便使用，但是它仅仅在应用的整个生命周期中都需要时才合适，否则我们就需要使用这个模式:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ticker:=time.NewTicker(<span class="number">1</span>*time.Second)</span><br><span class="line">&lt;-ticker.C    <span class="comment">//从ticker的通道里面接收</span></span><br><span class="line">ticker.Stop()　<span class="comment">//当不需要该节拍器之后，可以显式的停止它</span></span><br></pre></td></tr></table></figure></p><h2 id="使用select多路复用"><a href="#使用select多路复用" class="headerlink" title="使用select多路复用"></a>使用select多路复用</h2><p>现在我要给上面的倒计时程序加一个需求，在倒计时的过程中，如果用户按下键盘，则倒计时终止。下面的程序实现了这个需求:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    abort:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        os.Stdin.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1</span>))</span><br><span class="line">        abort&lt;-<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Commencing countdown."</span>)</span><br><span class="line">    tick:=time.Tick(<span class="number">1</span>*time.Second)<span class="comment">//时间间隔为１s</span></span><br><span class="line">    <span class="keyword">for</span> countdown:=<span class="number">10</span>;countdown&gt;<span class="number">0</span>;countdown--&#123;</span><br><span class="line">        fmt.Println(countdown)</span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            <span class="comment">//什么都不做</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-abort:</span><br><span class="line">            fmt.Println(<span class="string">"abort...!"</span>)</span><br><span class="line">            <span class="keyword">return</span><span class="comment">//返回，终止  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一次倒计时迭代需要等待事件到达两个通道中的一个：计时器通道(前提是一切顺利，即用户没有按键)，中止事件通道(前提是有异常，即用户按键)。<br>如上，我们使用了一个select语句实现了该功能,下面是select语句的通用形式:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">//code block 1</span></span><br><span class="line"><span class="keyword">case</span> z:&lt;-ch2:</span><br><span class="line">    <span class="comment">//code block 2</span></span><br><span class="line"><span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">    <span class="comment">//code block 3</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//code block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像switch语句一样，它有一系列的情况和一个可选的默认分支，每一个情况指定一次通信(在一些通信上进行发送或者接收操作)，和相关联的一段代码块。接收表达式操作可能出现在它本身，像第一种情况，或者在一个短变量声明中，像第二种情况，第二种形式可以让你引用你所接收的值。</p><p>select一直等待，直到一次通信来告知有一些情况可以执行。然后，它进行它进行这次通信，执行此情况所对应的语句；其他的通信将不会发生。对于没有对应情况的select语句，它将会永远等待。当有多个情况同时满足的时候，select随机选择一个，这样保证每一个通道有相同的机会被选中。</p>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goroutine </tag>
            
            <tag> channel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>平衡二叉树(AVL)</title>
      <link href="/2018/01/09/binary-search-tree-avl/"/>
      <url>/2018/01/09/binary-search-tree-avl/</url>
      
        <content type="html"><![CDATA[<p>上文中谈到朴素的二叉搜索树在进行插入节点，删除节点等动态操作的时候会影响到树的形态，可能致使树走向低效，影响后续操作的效率。今天就介绍一下二叉搜索树的一个变种——平衡二叉树(AVL)。AVL树是一种自平衡的二叉搜索树，在进行动态操作时可以维持自身形态的平衡，从而保证基本操作的时间复杂度维持在O(logn)。<br>下图为一个低效的二叉查找树的示意图，它已经退化成了链表，完全失去了二叉查找树的优势。<br><img src="/images/loweffective.gif" alt="低效的二叉查找树示意图"></p><h1 id="什么是平衡二叉树？"><a href="#什么是平衡二叉树？" class="headerlink" title="什么是平衡二叉树？"></a>什么是平衡二叉树？</h1><p>1962年，Adelson-Velsikii和Landis提出了一种结点在高度上相对平衡的二叉查找树，又称为AVL树。其平均和最坏情况下的查找时间都是O(logn)。同时，插入和删除的时间复杂性也会保持O(logn)。平衡二叉树的定义如下:</p><ul><li>它或者是一棵空二叉树。</li><li>或者是具有如下性质的二叉查找树：其左子树和右子树都是高度平衡的二叉树，且左子树和右子树的高度之差的绝对值不超过1。</li></ul><p>如果将二叉树上结点的<strong>平衡因子</strong>BF（Balanced Factor）定义为<strong>该结点的左子树与右子树的高度之差</strong>，根据AVL树的定义，AVL树中的任意结点的平衡因子只可能是-1（右子树高于左子树）、0或者1（左子树高于右子树）。</p><p>AVL树通过为每个节点设置并维护一个height(当前节点的高度)属性并且在执行动态操作的时候监控平衡因子BF的值，来监控自身的形态变化，从而实现<strong>自平衡</strong>。在动态操作执行后，如果某一个节点的BF值不在正常范围内(-1,0,1)时,AVL树自身可以通过<strong>旋转</strong>来调整子树的高度，使不符合AVL定义的部分重新符合定义。</p><h1 id="平衡二叉树的基本操作"><a href="#平衡二叉树的基本操作" class="headerlink" title="平衡二叉树的基本操作"></a>平衡二叉树的基本操作</h1><p>平衡二叉树本质上还是一棵二叉搜索树，所以在大多数的操作上两者是几乎相同的。唯一不同的是平衡二叉树在插入节点和删除节点等动态操作上增加了自平衡的操作(通过旋转)。以免和上一篇文章重复，在这里我们只讨论平衡二叉树的插入和删除操作。</p><p>要想实现平衡二叉树的带自平衡功能的插入和删除操作，我们首先要来研究一下AVL实现自平衡的机制－－<strong>旋转</strong>。</p><p>首先定义平衡二叉树节点结构体和几个功能宏函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEIGHT(n) (((n) == NULL) ? 0 : (n)-&gt;h)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &lt; (b) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">avl_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> h;　<span class="comment">//这里增加了h的属性，用来记录当前节点的高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avl_node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avl_node</span> *<span class="title">left</span>;</span></span><br><span class="line">&#125; node, *avl_node_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_bf</span><span class="params">(avl_node_ptr node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> HEIGHT(node-&gt;left)-HEIGHT(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>在AVL树的平衡化操作中，存在两种基本旋转操作，左旋和右旋。在一次平衡化操作中，左旋和右旋这两个基本旋转操作可能被执行一次或多次。并且是从<strong>最小不平衡二叉树</strong>的根节点开始的。(即从离插入节点最近的，平衡因子超过1的祖先节点开始)</p><h3 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h3><p>1.右旋操作(LL_right_rotate)<br><img src="/images/ll.png" alt="右旋示意图"><br>如上图，新插入了节点1,我们从新插入的节点开始向上寻找它的祖先节点，发现了第一个失衡节点3。也就找到了这里的最小不平衡二叉树就是以3为根节点的那棵树。也就是<strong>新插入的节点出现在失衡节点的左孩子的左子树上</strong>,此时我们需要对他们进行右旋操作(LL_right_rotate)。如上图，将根节点的左孩子2提升为新的根节点,而旧的根节点3则作为新根节点2的右孩子存在。</p><p>下面看一个复杂一些的需要右旋的情况：<br><img src="/images/ll2.png" alt="右旋示意图"><br>新插入的节点为1,同样的，我们从1开始依次向上检查其祖先节点，第一个找到了5是不平衡的节点。由于新插入的节点1出现在失衡节点5的左孩子的左子树上，我们需要对其进行右旋操作(LL_right_rotate)。但这种情况似乎与上面那种简单情形不同。具体的旋转细节如下:<br><img src="/images/ll3.png" alt="右旋示意图"><br>我们仍然是将失衡节点5的左孩子3提升为新的根节点，旧的根节点5则作为3的右孩子，所增加的是:还需要将新根节点3原本的右孩子作为旧根节点5的左孩子。</p><p>仔细分析发现，复杂情况中所增加的操作在简单情况中就是将NULL挂到NULL上，也就是说上面的简单的情形和复杂的情形的本质是统一的，我们可以将这两种情况总结成下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//root为最小不平衡二叉树的根节点，插入的节点插在root的左孩子的左子树上</span></span><br><span class="line"><span class="comment">//需要将root的左孩子作为新的根节点,右旋</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">LL_right_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    avl_node_ptr new_root = root-&gt;left;</span><br><span class="line">    root-&gt;left = new_root-&gt;right;</span><br><span class="line">    new_root-&gt;right = root;</span><br><span class="line">    new_root-&gt;h = MAX(HEIGHT(new_root-&gt;left), HEIGHT(new_root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;h = MAX(HEIGHT(root-&gt;left), HEIGHT(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.左旋操作(RR_left_rotate)<br>左旋和右旋是镜像对称的,当<strong>插入的节点位于离他最近的失衡节点的右孩子的右子树上</strong>时，我们就需要对其进行左旋操作(RR_left_rotate),示意图如下:<br><img src="/images/rr.png" alt="左旋示意图"><br>实现如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入的节点位于root的右孩子的右子树上，root的右孩子作为新的根节点，左旋</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">RR_left_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    avl_node_ptr new_root = root-&gt;right;</span><br><span class="line">    root-&gt;right = new_root-&gt;left;</span><br><span class="line">    new_root-&gt;left = root;</span><br><span class="line">    new_root-&gt;h = MAX(HEIGHT(new_root-&gt;left), HEIGHT(new_root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;h = MAX(HEIGHT(root-&gt;left), HEIGHT(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="复合旋转"><a href="#复合旋转" class="headerlink" title="复合旋转"></a>复合旋转</h3><p>1.先左旋再右旋(LR_left_right_rotate)<br><img src="/images/lr.png" alt=""><br>如上图所示，我们在树上插入了节点5,然后从5开始依次向上寻找失衡节点，找到失衡节点8,观察新插入的节点与该失衡节点的位置关系我们可以发现，<strong>新插入的节点位于其最近的失衡节点的左孩子的右子树上</strong>。这不是我们刚才讨论的单旋转中的任何一种情况，我们怎样才能将这种情况的树调整会平衡状态呢?如图，要调整这种情形，我们要<strong>首先将失衡节点的左子树进行左旋，然后对以失衡节点为根节点的树进行右旋</strong><br>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新插入的节点位于root的左孩子rootl的右子树上，</span></span><br><span class="line"><span class="comment">//那么首先需要先对以rootl为根节点的子树进行左旋(RR_left_rotate)</span></span><br><span class="line"><span class="comment">//然后对以root为根节点的子树进行右旋(LL_right_rotate)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">LR_left_right_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    root-&gt;left = RR_left_rotate(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> LL_right_rotate(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.先右旋再左旋(RL_right_left_rotate)<br>下面的这种情况是<strong>插入节点出现在离他最近的失衡节点的右孩子的左子树上</strong>,和上面的情况是对称的，这里直接给出代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">RL_right_left_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    root-&gt;right = LL_right_rotate(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> RR_left_rotate(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="再平衡"><a href="#再平衡" class="headerlink" title="再平衡"></a>再平衡</h2><p>上面在讨论旋转时讨论了四种失衡的场景以及每种场景对应的平衡调整方法，下面我们做个小小的总结:在代码中我们应该如何判定对应的失衡场景，又该如何调整呢？<strong>根据当前破坏平衡的结点的平衡因子，以及其孩子结点的平衡因子来判定，通过旋转来调整。</strong></p><p><img src="/images/all_avl.png" alt=""></p><table><thead><tr><th style="text-align:center">失衡场景</th><th style="text-align:center">判定准则</th><th style="text-align:center">调整方法　</th></tr></thead><tbody><tr><td style="text-align:center">LL型失衡</td><td style="text-align:center">current.bf&gt;1 &amp;&amp; current.left.bf&gt;0</td><td style="text-align:center">LL_right_rotate</td></tr><tr><td style="text-align:center">LR型失衡</td><td style="text-align:center">current.bf&gt;1 &amp;&amp; current.left.bf&lt;0</td><td style="text-align:center">LR_left_right_rotate</td></tr><tr><td style="text-align:center">RR型失衡</td><td style="text-align:center">current.bf&lt;-1 &amp;&amp; current.right.bf&lt;0</td><td style="text-align:center">RR_left_rotate</td></tr><tr><td style="text-align:center">RL型失衡</td><td style="text-align:center">current.bf<-1 &&="" current.right.bf="">0</-1></td><td style="text-align:center">RL_right_left_rotate</td></tr></tbody></table><p>由上，我们可以得出调整失衡的函数如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node为当前失衡节点</span></span><br><span class="line"><span class="function">avl_node_ptr <span class="title">re_balance</span><span class="params">(avl_node_ptr node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">int</span> bf=get_bf(node);</span><br><span class="line">    <span class="keyword">int</span> bf_l=get_bf(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> bf_r=get_bf(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(bf&gt;<span class="number">1</span> &amp;&amp; bf_l&gt;<span class="number">0</span>)</span><br><span class="line">        node=LL_right_rotate(node);</span><br><span class="line">    <span class="keyword">if</span>(bf&gt;<span class="number">1</span> &amp;&amp; bf_l&lt;<span class="number">0</span>&gt;)</span><br><span class="line">        node=LR_left_right_rotate(node);</span><br><span class="line">    <span class="keyword">if</span>(bf&lt;<span class="number">-1</span> &amp;&amp; bf_r&lt;<span class="number">0</span>)</span><br><span class="line">        node=RR_left_rotate(node);</span><br><span class="line">    <span class="keyword">if</span>(bf&lt;<span class="number">-1</span> &amp;&amp; bf_r&gt;<span class="number">0</span>)</span><br><span class="line">        node=RL_right_left_rotate(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了上面的一些工具函数和平衡调整函数并且利用递归我们可以非常容易的实现插入和删除操作。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><iframe width="640" height="360" src="https://www.youtube.com/embed/ygZMI2YIcvk" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">avl_node_ptr <span class="title">avl_insert</span><span class="params">(avl_node_ptr node,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">        node=<span class="keyword">new</span> avl_node;</span><br><span class="line">        node-&gt;key=k;</span><br><span class="line">        node-&gt;height=<span class="number">1</span>;</span><br><span class="line">        node-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;node-&gt;key)</span><br><span class="line">        node-&gt;left=avl_insert(node-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;node-&gt;key)</span><br><span class="line">        node-&gt;right=avl_insert(node-&gt;right,k);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"can't insert a key that already esixt!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先调整高度，然后再平衡</span></span><br><span class="line">    node-&gt;height=max(get_height(node-&gt;left),get_height(node-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    node=re_balance(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><iframe width="623" height="374" src="https://www.youtube.com/embed/4zQV3j2X9mU" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">avl_node_ptr  <span class="title">avl_delete</span><span class="params">(avl_node_ptr node,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;node-&gt;key)</span><br><span class="line">        node-&gt;left=avl_delete(node-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;node-&gt;key)</span><br><span class="line">        node-&gt;right=avl_delete(node-&gt;right,k);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到需要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>||node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//删除的节点只有一个孩子或者没有孩子</span></span><br><span class="line">            avl_node_ptr temp=(node-&gt;left==<span class="literal">NULL</span>)?node-&gt;right:node-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">//没有孩子的情况</span></span><br><span class="line">                temp=node;</span><br><span class="line">                node=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//一个孩子</span></span><br><span class="line">                node=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//删除的节点有两个孩子</span></span><br><span class="line">            avl_node_ptr temp=node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>)<span class="comment">//找到node的右子树的最小关键字节点</span></span><br><span class="line">                temp=temp-&gt;left;</span><br><span class="line">            node-&gt;key=temp-&gt;key;</span><br><span class="line">            node-&gt;right=avl_delete(node-&gt;right,temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    node-&gt;height=max(get_height(node-&gt;left),get_height(node-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> re_balance(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.geeksforgeeks.org/?p=17679" target="_blank" rel="noopener">GeeksforGeeks</a><br><a href="http://btechsmartclass.com/DS/U5_T2.html" target="_blank" rel="noopener">btechsmartclass</a><br><a href="http://www.cnblogs.com/penghuwan/p/8166133.html" target="_blank" rel="noopener">【算法】论平衡二叉树（AVL）的正确种植方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> data structure </tag>
            
            <tag> binary search tree </tag>
            
            <tag> AVL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2018/01/07/binary-search-tree/"/>
      <url>/2018/01/07/binary-search-tree/</url>
      
        <content type="html"><![CDATA[<p><code>二叉搜索树</code>(binary search tree)支持许多动态集合操作，包括插入节点构建树，查找(最大值，最小值，前驱，后继，指定值)节点，遍历(前中后序遍历)树，删除节点等。在树上进行的操作所花费的时间与树的高度成正比，对于有n的节点的一个完全二叉树，这些操作的最坏运行时间为Θ(lg n).但是如果这棵树是一个n个节点连接而成的线性链，那么同样的操作的最坏运行时间就为Θ(n).为了尽量避免这种低效的二叉树，可以在构造树时采用随机构造的方式。随机构造的二叉树的期望高度O(lg n),因此在这样的一棵二叉树上的操作的平均运行时间就为Θ(lg n).但实际上，随机化的构造树的方式也不能完全杜绝最坏情况的出现，所以还有一些二叉搜索树的变种，如红黑树，B树等，他们可以保证基本操作具有好的最坏情况性能。<br>在本文中，不讨论红黑树和B树，我们只讨论二叉搜索树的各种操作。</p><h1 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树?"></a>什么是二叉搜索树?</h1><p>一棵二叉搜索树就是以一个二叉树来组织的，树上的每一个节点就是一个对象，对象中除了key和卫星数据之外，还有用于维护二叉树结构的三个属性left,right,parent(在c语言中他们是三个指针),他们分别指向节点的左孩子，右孩子和父节点。其中key被称为节点的关键字，它是二叉搜索树中确定节点之间大小关系的关键属性，一般可以设置为整型类型。如果某一个节点的没有左孩子，右孩子或父节点，那么就将对应的属性指针置空即可。该树的根节点是整棵树中唯一一个parent属性为空的节点。这些置空的指针通常被用来确定树的边界。二叉搜索树之所以可以具有灵活高效的操作，是因为它具有如下的性质：</p><ul><li>如果节点的左子树不空，则左子树上所有结点的值均小于等于它的根结点的值；</li><li>如果节点的右子树不空，则右子树上所有结点的值均大于等于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉搜索树</li></ul><p><img src="/images/bst.png" alt="二叉搜索树示意图"></p><h1 id="二叉搜索树的基本操作"><a href="#二叉搜索树的基本操作" class="headerlink" title="二叉搜索树的基本操作"></a>二叉搜索树的基本操作</h1><p>本文重点讨论的就是二叉搜索树上的操作，下面我们来逐一的讨论。首先声明:为了减少讨论的复杂度，<code>假设树上的所有节点的关键字均不相同</code>，下面我的代码也基于此，对于节点关键字有重复的情况，调整代码即可。下面我们先定义节点的数据结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;<span class="comment">//节点数据,同时也是节点的关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的为二叉搜索树的维护数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">parent</span>=<span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">left</span>=<span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">right</span>=<span class="title">NULL</span>;</span></span><br><span class="line">&#125;BST,*BST_p;</span><br></pre></td></tr></table></figure></p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>我们想要实现在二叉搜索树上的操作，那么首先我们就需要构建出一棵二叉搜索树.我们可以从一个数组中构建二叉搜索树，逐个的从数组中读取数据，然后以插入的方式将数据插入到树中，即我们需要一个将数据插入到树中的操作。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="递归插入"><a href="#递归插入" class="headerlink" title="递归插入"></a>递归插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归构造搜索二叉树</span></span><br><span class="line"><span class="comment"> * root：指向树的根节点的指针</span></span><br><span class="line"><span class="comment"> * k:待插入的key</span></span><br><span class="line"><span class="comment"> * parent:父节点的指针</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bst_insert</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k,BST_p parent=<span class="literal">NULL</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前二叉搜索树为空，则当前的待插入的值就为根节点中存放的值</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> BST;</span><br><span class="line">        root-&gt;key=k;</span><br><span class="line">        root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点没有父节点</span></span><br><span class="line">        root-&gt;parent=parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//关键字比root节点中存放的关键字大，那么该节点应该被存放在root节点的右子树</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;root-&gt;key)</span><br><span class="line">            bst_insert(root-&gt;right,k,root);</span><br><span class="line">        <span class="comment">//关键字比root节点中存放的关键字小，那么该节点应该被存放在root节点的左子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bst_insert(root-&gt;left,k,root); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归插入"><a href="#非递归插入" class="headerlink" title="非递归插入"></a>非递归插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归插入操作</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bst_insert_nonRecur</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    BST_p pre=<span class="literal">NULL</span>;<span class="comment">//记录上一个节点</span></span><br><span class="line">    BST_p t=root;<span class="comment">//不能直接使用root操作，这里的root为主函数中的全局root的引用，对他的更改会影响全局的root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照规则找到key应该插入的位置，并用pre记录该位置的上一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre = t;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; t-&gt;key)&#123;</span><br><span class="line">            t = t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BST_p node = <span class="keyword">new</span> BST;</span><br><span class="line">    node-&gt;key = k;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;parent = pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将node连接到树上</span></span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="literal">NULL</span>)<span class="comment">//若为空树，node即为根节点</span></span><br><span class="line">        root = node;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//树非空，则判断node应该被连接到pre的左子树还是右子树</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; pre-&gt;key)&#123;</span><br><span class="line">            pre-&gt;left = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建二叉查找树"><a href="#构建二叉查找树" class="headerlink" title="构建二叉查找树"></a>构建二叉查找树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_bst</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> * a ,<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="comment">// bst_insert(root,a[i]);</span></span><br><span class="line">        bst_insert_nonRecur(root,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的这几个函数，我们就可以像下面这样来构建一个二叉搜索树：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    BST_p root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    init_bst(root,a,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//some operating</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二叉搜索树的性质允许我们通过一个简单的递归算法来按序输出二叉搜索树中的所有关键字，这种算法称之为<strong>中序遍历</strong>(inorder walk tree),这样命名的原因是输出的子树根的关键字位于其左子树的递归调用语句和右子树的递归调用语句之间。类似的<strong>先序遍历</strong>，<strong>后续遍历</strong>也是根据关键字输出语句与其左右子树递归调用语句之间的先后关系确定的。<br>下面是三种遍历的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历二叉搜索树</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_tree_walk</span><span class="params">(BST_p root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        inorder_tree_walk(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inorder_tree_walk(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历二叉树</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_tree_walk</span><span class="params">(BST_p root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preorder_tree_walk(root-&gt;left);</span><br><span class="line">        preorder_tree_walk(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_tree_walk</span><span class="params">(BST_p root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        postorder_tree_walk(root-&gt;left);</span><br><span class="line">        postorder_tree_walk(root-&gt;right);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="string">" "</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中的中序遍历可以按照从小到大的顺序依次输出树中所有节点的关键字。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>在二叉查找树中可以快速的查找元素，下面我们就来看看在二叉查找树中各种查找操作都是如何进行的。</p><h3 id="查找最大值与最小值"><a href="#查找最大值与最小值" class="headerlink" title="查找最大值与最小值"></a>查找最大值与最小值</h3><p>找具有最值关键字的节点在二叉查找树中非常的直接。比如要找具有最小关键字的节点，我们可以从根节点一直向左查找，如果一个节点具有左孩子，那么它的左孩子的关键字一定比它本身的关键字小，这时就可以迭代的去查看其左孩子，直到某一节点的左孩子为空，这样就是找到了树中最左边的节点，也就具有最小关键字的节点。上述寻找最小值的代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找最小值，一直向左找，直到找到最左边的一个节点</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">minimum</span><span class="params">(BST_p&amp; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"该树为空，没有最小值!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BST_p t=root;<span class="comment">//不能用root直接操作</span></span><br><span class="line">        <span class="comment">//找到最左边的那个节点</span></span><br><span class="line">        <span class="keyword">while</span>(t-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同理，找最大值的代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找最大值,一直向右找，直到找到最右边的一个节点</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">maximum</span><span class="params">(BST_p&amp; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"该树为空，没有最大值"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BST_p t=root;<span class="comment">//不能用root直接操作</span></span><br><span class="line">        <span class="comment">//找到最右边的那个节点</span></span><br><span class="line">        <span class="keyword">while</span>(t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查找前驱与后继"><a href="#查找前驱与后继" class="headerlink" title="查找前驱与后继"></a>查找前驱与后继</h3><p>给定一棵二叉搜索树中的节点，有时需要按照<strong>中序遍历</strong>的次序(从小到大)查找它的<strong>后继</strong>(successor)或<strong>前驱</strong>(predecessor)。找前驱和后继在逻辑上是对称的，我们这里以找一个节点的后继节点作为例子讲解。按照定义我们可以知道，找节点a的后继节点就是找树中关键字比a的关键字大的所有节点中的最小关键字节点(虽然很绕，但就是这个道理:)。如何才能找到它呢？我们需要分两种情况讨论:</p><ul><li><p>给定的节点a具有右孩子<br>在这种情况下，a的后继节点必定存在于a的右子树中，并且为右子树中的关键字最小节点。</p></li><li><p>给定的节点a没有右孩子<br>在这种情况下，a的后继节点在哪里呢？为了找到a的后继节点，我们就要从a节点开始追根溯源，向上找它的祖先，直到找到第一个这样的祖先s:s的左孩子s’也是ａ的祖先，那么节点s就是这种情况下a的后继节点。</p></li></ul><p>下面是上述两种找后继节点的示意图。声明:<code>这两张图片借自别人的博客</code>(读书人的东西怎么能叫偷呢:)!<br><img src="/images/bst_successor1.gif" alt="找后继1"><br><img src="/images/bst_successor2.gif" alt="找后继2"></p><p>下面是找后继节点的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BST_p <span class="title">successor</span><span class="params">(BST_p node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">//有右孩子，直接返回指向右子树的最小关键字节点的指针</span></span><br><span class="line">        <span class="keyword">return</span> minimum(node-&gt;right);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//没有右孩子</span></span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;node!=p-&gt;left)&#123;</span><br><span class="line">            node=node-&gt;parent;</span><br><span class="line">            p=p-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>找前驱节点的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BST_p <span class="title">perdecessor</span><span class="params">(BST_p node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> maximum(node-&gt;left);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;node!=p-&gt;right)&#123;</span><br><span class="line">            node=node-&gt;parent;</span><br><span class="line">            p=p-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查找具有指定关键字的节点"><a href="#查找具有指定关键字的节点" class="headerlink" title="查找具有指定关键字的节点"></a>查找具有指定关键字的节点</h3><p>给定一个节点和一个关键字的值，找到树中关键字的值与给定值相等的节点。这个可以用递归和非递归两种方式实现。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找包含关键字k的节点，并返回指向该节点的指针</span></span><br><span class="line"><span class="comment"> * 这里假设树中的key不重复</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">bst_search</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span> || k==root-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;root-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> bst_search(root-&gt;left,k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> bst_search(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归查找</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">bst_search_nonRecur</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//为空时，直接返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//不为空</span></span><br><span class="line">    BST_p t=root;</span><br><span class="line">    <span class="keyword">while</span>(k!=t-&gt;key)&#123;<span class="comment">//依次遍历，直到k与t指向的key相等</span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;t-&gt;key)<span class="comment">//如果k小于当前节点的key，那么就需要到当前节点的左子树中去找</span></span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果k大于当前节点的key，那么就需要到当前节点的右子树中去找</span></span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>给定一个树中的节点a，要求删除该节点并且保持二叉搜索树的结构。删除这一操作根据给定节点a的情况的不同，可分成一下三种情况讨论:</p><ul><li>节点a没有孩子节点<br>对于节点a没有孩子节点的情况，我们只需要做以下操作：通过比较a节点的关键字与其父结点的关键字大小从而确定a节点是其父结点的左孩子还是右孩子，然后将a的父节点的对应指针置空，并且释放a所指向节点所占用的内存。<br><img src="/images/delete0.gif" alt="示意图"></li><li>节点a只有一个孩子节点<br>对这种情况，首先要确定a是其父结点的左孩子还是右孩子，然后根据此信息将a的父节点的对应指针指向a的那个唯一的孩子节点，并且将a的孩子节点的父指针指向a的父节点，最后释放a所指向的节点占用的内存。<br><img src="/images/delete1.gif" alt="示意图"></li><li>节点a有两个孩子节点<br>首先找到节点a的后继节点b，然后根据b是否是a的右孩子分两种情况讨论：<br>1.b是a的右孩子<br>如果b是a的右孩子，将b提升到a节点的位置，并且将原来a节点的左子树，连接到b节点的左支上(b节点的左支初始时为空)，最后释放a所指向的节点的内存。<br><img src="/images/delete21.gif" alt="示意图"><br>2.b不是a的右孩子<br>首先将b节点的右孩子提升到b的位置，即将b的右孩子连接到b的父节点的左支上(想一想为什么一定是左支上呢?因为b是a的后继节点，而且现在的讨论又是在b不是a的右孩子的基础上)。然后将原来a节点的左子树连接到b节点的左支上(该支初始时为空)，最后将b提升到a的位置，并且释放a节点占用的内存。<br><img src="/images/delete22.gif" alt="示意图"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树删除node指向的节点</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bst_delete</span><span class="params">(BST_p node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node没有孩子节点</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>&amp;&amp;node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key&lt;p-&gt;key)<span class="comment">//这里说明node节点是其父节点的左节点</span></span><br><span class="line">            p-&gt;left=<span class="literal">NULL</span>;<span class="comment">//置空左指针</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;right=<span class="literal">NULL</span>;<span class="comment">//置空右指针</span></span><br><span class="line">        <span class="comment">//释放node指向的内存块的内存</span></span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node只有一个孩子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span> || node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key&gt;p-&gt;key)&#123;<span class="comment">//node是p的右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                p-&gt;right=node-&gt;left;</span><br><span class="line">                node-&gt;left-&gt;parent=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;right=node-&gt;right;</span><br><span class="line">                node-&gt;right-&gt;parent=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                p-&gt;left=node-&gt;left;</span><br><span class="line">                node-&gt;left-&gt;parent=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;left=node-&gt;right;</span><br><span class="line">                node-&gt;right-&gt;parent=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node有两个孩子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>&amp;&amp; node-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST_p left=node-&gt;left;<span class="comment">//左子树的根节点</span></span><br><span class="line">        BST_p right=node-&gt;right;<span class="comment">//右子树的根节点</span></span><br><span class="line">        BST_p parent=node-&gt;parent;<span class="comment">//父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//node节点的后继节点,由于存在右子树，所以这里直接使用了求右子树的最小节点的函数</span></span><br><span class="line">        BST_p successor=minimum(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后继节点就是node的右孩子，这里假设树中不存在key值相同的节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor-&gt;key==right-&gt;key)&#123;</span><br><span class="line">            <span class="comment">//将node的左支连接到后继节点的左孩子上(初始时该节点为空)</span></span><br><span class="line">            successor-&gt;left=left;</span><br><span class="line">            left-&gt;parent=successor;</span><br><span class="line">            <span class="comment">//将后继节点提升到node的位置</span></span><br><span class="line">            <span class="comment">//这里首先需要判断node是其父节点的左孩子还是右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key&gt;parent-&gt;key)&#123;</span><br><span class="line">                <span class="comment">//node是其父节点的右节点</span></span><br><span class="line">                parent-&gt;right=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//node是其父节点的左节点</span></span><br><span class="line">                parent-&gt;left=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//后继节点successor不是node的右孩子</span></span><br><span class="line">            <span class="comment">//首先将successor的右节点提升到successor的位置，然后将node的左支连接到</span></span><br><span class="line">            <span class="comment">//successor的左支上(初始为空支)，然后将successor提升到node的位置</span></span><br><span class="line"></span><br><span class="line">            BST_p succ_parent=successor-&gt;parent;<span class="comment">//后继节点的父节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里后继节点一定位于其父节点的左支，所以直接将后继节点的右节点连接到</span></span><br><span class="line">            <span class="comment">//后继节点的父节点的左支上</span></span><br><span class="line">            succ_parent-&gt;left=successor-&gt;right;</span><br><span class="line">            successor-&gt;right-&gt;parent=succ_parent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将node的左子树连接到后继节点的左支上(该支初始时为空)</span></span><br><span class="line">            successor-&gt;left=left;</span><br><span class="line">            left-&gt;parent=successor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将successor提升到node的位置，同样的需要判断node位于其父结点的左还是右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key&gt;parent-&gt;key)&#123;</span><br><span class="line">                <span class="comment">//node是其父节点的右节点</span></span><br><span class="line">                parent-&gt;right=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//node是其父节点的左节点</span></span><br><span class="line">                parent-&gt;left=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="随机构建"><a href="#随机构建" class="headerlink" title="随机构建"></a>随机构建</h1><p>在文章开头介绍了，如果一棵二叉树是一个n个节点连接而成的线性链，那么该二叉树的效率就极其的低下，它就与链表无异了，无法发挥出搜索二叉树的威力。就拿我们上面的<code>init_bst</code>函数为例吧，我们是以用户提供的数组来初始化我们的二叉搜索树的，假如用户提供了这样的一个数组{1,2,3,4,5},或者是这样的{9,8,6,4,3,2}，大家想想我们给构造出来的是一什么样的二叉树呢？第一个数组构造出来的二叉搜索树的每个节点只有右孩子没有左孩子，而第二个构造出来的二叉搜索树的每个节点则只有左孩子没有右孩子。这就是极其低效的二叉树。怎样去避免这样的问题呢？</p><p>显然，我们不应该对用户的输入做任何限制，那么我们就只能改变自己来适应用户了:)。我们可以在用户提供的数组中通过不重复无遗漏的随机取元素的方法来构造一个随机序列，然后用该序列来构造一个随机二叉搜索树。代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span>  </span>&#123;  </span><br><span class="line"><span class="keyword">int</span> tmp = a;  </span><br><span class="line">a = b;  </span><br><span class="line">b = tmp;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_init_bst</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> * a ,<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);</span><br><span class="line">        bst_insert_nonRecur(root,a[j]);<span class="comment">//插入</span></span><br><span class="line">        swap(arr[j], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述随机构建二叉搜索树的方法，在初始化构建树的时候，确实可以降低因用户给定的数组有序而创建低效二叉搜索树的情况，但是它无法做出保证。并且我们在对二叉搜索树这一动态集合进行插入删除等动态操作时，搜索二叉树的形态仍然可能走向低效。前面的动态操作会降低后面操作的效率。怎么办呢?这就要看其他的一些二叉搜索树的变体了！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Introduction to Algorithm (Third Edition)<br><a href="https://lufficc.com/blog/binary-search-tree" target="_blank" rel="noopener">多动态图详细讲解二叉搜索树聪聪的个人网站</a><br><a href="https://songlee24.github.io/2015/01/13/binary-search-tree/" target="_blank" rel="noopener">二叉查找树（BST） | 神奕的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> data structure </tag>
            
            <tag> binary search tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>木犀后端分享——网络爬虫</title>
      <link href="/2017/11/26/Web-Crawler/"/>
      <url>/2017/11/26/Web-Crawler/</url>
      
        <content type="html"><![CDATA[<h1 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h1><h2 id="先来两张图撑场子！"><a href="#先来两张图撑场子！" class="headerlink" title="先来两张图撑场子！"></a>先来两张图撑场子！</h2><p><img src="/images/网络体系结构.png" alt="计算机网络体系结构"></p><p><img src="/images/数据处理流程.png" alt="信息处理流程"></p><p>计算机网络体系结构是分层的，分层的目的就是为了各司其职，每一层协议就负责处理好自己的工作，而不用去担心别人的事情。</p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><blockquote><p>从字面意义上讲，有人可能会认为TCP/IP是指TCP和IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。他们与TCP或IP的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP为网际协议群。</p></blockquote><p>就我本人的理解，TCP/IP就代表着一大堆的协议，这些协议就是具体负责网络中信息的传递。他们确保了数据可以被准确无误的传输到目的地。既传的远又传的准。也就是说，TCP/IP就帮你<strong>完美的解决了数据传输的问题</strong>，其他的协议就不需要再考虑数据传不远，传不到的问题了。</p><p>更多详细的内容看－&gt;<a href="http://www.jianshu.com/p/9f3e879a4c9c" target="_blank" rel="noopener">TCP/IP协议</a>，上面的引用也出自此处。</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><blockquote><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p></blockquote><p>HTTP协议是构建在TCP/IP协议之上的应用层的协议，它不必再关心数据的是否可以准确无误的到达目的地的问题，它关心和解决的是<strong>在什么时候传什么数据给谁</strong>的问题。</p><p>更多详细内容请看－&gt;<a href="http://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">HTTP协议</a>,上面的引用也出自此处。</p><h1 id="网络爬虫简介"><a href="#网络爬虫简介" class="headerlink" title="网络爬虫简介"></a>网络爬虫简介</h1><p><strong>网络爬虫</strong>:又被称为网页蜘蛛，网络机器人等。是一种按照一定的规则，<strong>自动</strong>地抓取万维网信息的程序或者脚本。大家可以理解为在网络上爬行的一只蜘蛛。互联网就比作一张大网，而爬虫便是在这张网上爬来爬去的蜘蛛，如果它遇到资源，那么它就会抓取下来。想抓取什么？这个由你来控制它。爬虫技术是数据挖掘,测试技术的重要组成部分，是搜索引擎技术的核心。</p><p>说白了,爬虫技术就是一种<strong>自动化</strong>去请求下载并处理网络信息资源(html页面,css,js,pdf,word,excel，图片，音视频等)的技术。在实际中处理的比较多的网络信息资源是html页面，然后获取页面中有价值的文字信息。</p><p>要学好网络爬虫我们就需要解决两个问题:怎样下载？怎样处理？</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="去哪里下载？"><a href="#去哪里下载？" class="headerlink" title="去哪里下载？"></a>去哪里下载？</h2><p>网络信息资源分布在服务提供者的服务器上，我们要去下载它，第一个要解决的问题就是要知道它在哪里。</p><h3 id="URL-URI-URN是什么鬼？"><a href="#URL-URI-URN是什么鬼？" class="headerlink" title="URL,URI,URN是什么鬼？"></a>URL,URI,URN是什么鬼？</h3><p><strong>URL</strong>:(Uniform Resource Locator,统一资源定位符)是一个Web地址，用来在Web上定位一个文档，或者调用一个CGI程序来为客户端生成一个文档。<br><strong>URI</strong>:(Uniform Resource Identifier,统一资源标识符)是URL的超集，可以应对将来可能出现的标识符命名约定。一个URL是一个简单的URI,它使用已有的协议或方案(http,ftp等)作为地址的一部分。<br><strong>URN</strong>:(Uniform Resource Name,统一资源名称)URN用来描述非URL的URI,只作为可能会用到的XML标识符。</p><p><code>URI = URL + URN</code><br>现在唯一使用的URI只有URL,而很少听到URI和URN.</p><p>我们在浏览器的地址栏里输入的网站地址就是URL。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>URL使用这种格式：<br><code>protocol_schema://net_location/path;params?query#frag</code></p><table><thead><tr><th style="text-align:center">URL组件</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">protocol_schema</td><td style="text-align:center">网络协议或下载方案</td></tr><tr><td style="text-align:center">net_location</td><td style="text-align:center">服务器所在地(也许含有用户信息)</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">使用’/‘分割的文件的路径或CGI应用的路径</td></tr><tr><td style="text-align:center">params</td><td style="text-align:center">可选参数</td></tr><tr><td style="text-align:center">query</td><td style="text-align:center">连接符’&amp;’分割的一系列键值对</td></tr><tr><td style="text-align:center">frag</td><td style="text-align:center">指定文档内特定锚的部分</td></tr></tbody></table><p>net_location可以进一步拆分成多个组件:<br><code>user:password@host:port</code></p><table><thead><tr><th style="text-align:center">net_location组件</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">user</td><td style="text-align:center">用户名</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">用户密码</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">运行web服务器的节点地址(必须的)</td></tr><tr><td style="text-align:center">port</td><td style="text-align:center">端口号(如果没有则默认为80)</td></tr></tbody></table><p>在net_location的四个组件中host最为重要，port只有在web服务器运行其他非默认端口号时才会使用，用户名和密码只有在使用FTP连接是才有可能用到，而即便是FTP，大多数的连接都是匿名的，这时不需要用户名和密码。</p><h2 id="用什么下载？"><a href="#用什么下载？" class="headerlink" title="用什么下载？"></a>用什么下载？</h2><h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p>urllib是python标准库提供的一个高级的Web通信库，支持基本的Web协议，如Http,Ftp,Gopher,同时也支持对本地文件的访问。具体来说urllib模块的功能就是利用这些协议从因特网，局域网，本地主机上下载数据。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的这种导入是错误的：</span></span><br><span class="line"><span class="comment">#import urllib</span></span><br></pre></td></tr></table></figure><h4 id="下载并保存你的第一个网页"><a href="#下载并保存你的第一个网页" class="headerlink" title="下载并保存你的第一个网页"></a>下载并保存你的第一个网页</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">file=request.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">myfirstpage=file.read()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"myfirstpage.html"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(myfirstpage)</span><br></pre></td></tr></table></figure><p>urlopen()传入一个URL string,会打开这个string所指向的url,下载对应的网页，返回该网页的文件对象(这里我把它赋值给了file变量)。如果没有给定协议或者下载方案，或者传入‘file’方案，urlopen()会打开一个本地文件。</p><p>urlopen()返回的文件对象(即上面代码中的file)还有一些实用方法：</p><table><thead><tr><th style="text-align:center">urlopen()返回的对象的方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">file.read([bytes])</td><td style="text-align:center">从file中读出所有或者bytes个字节，以字符串返回</td></tr><tr><td style="text-align:center">file.readline()</td><td style="text-align:center">从file中读取一行，以字符串返回</td></tr><tr><td style="text-align:center">file.readlines()</td><td style="text-align:center">从file中读出所有行，以列表返回，每一行作为列表中的一项</td></tr><tr><td style="text-align:center">file.close()</td><td style="text-align:center">关闭file的url连接</td></tr><tr><td style="text-align:center">file.fileno()</td><td style="text-align:center">返回file的文件句柄</td></tr><tr><td style="text-align:center">file.info()</td><td style="text-align:center">获得file的MIME头文件</td></tr><tr><td style="text-align:center">file.geturl()</td><td style="text-align:center">返回当前请求的url</td></tr><tr><td style="text-align:center">file.getcode()</td><td style="text-align:center">返回响应的状态码</td></tr></tbody></table><p>例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">f=request.urlopen(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(f.fileno())</span><br><span class="line">print(f.getcode())</span><br><span class="line">print(f.geturl())</span><br><span class="line">print(f.info())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">200</span><br><span class="line">http://www.baidu.com</span><br><span class="line">Date: Wed, 29 Nov 2017 03:58:52 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: Close</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Set-Cookie: BAIDUID=B06CDC6F062BA8B6D50F401E830F6B5A:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BIDUPSID=B06CDC6F062BA8B6D50F401E830F6B5A; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: PSTM=1511927932; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BDSVRTM=0; path=/</span><br><span class="line">Set-Cookie: BD_HOME=0; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=1440_19036_21116_18560_17001_25178_25145_22157; path=/; domain=.baidu.com</span><br><span class="line">P3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">Cache-Control: private</span><br><span class="line">Cxy_all: baidu+14ee1d71cc2cf84997fda3c20bcc1684</span><br><span class="line">Expires: Wed, 29 Nov 2017 03:58:18 GMT</span><br><span class="line">X-Powered-By: HPHP</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">X-UA-Compatible: IE=Edge,chrome=1</span><br><span class="line">BDPAGETYPE: 1</span><br><span class="line">BDQID: 0xe0db52f000003afc</span><br><span class="line">BDUSERID: 0</span><br></pre></td></tr></table></figure></p><h4 id="更优雅的下载并保存"><a href="#更优雅的下载并保存" class="headerlink" title="更优雅的下载并保存"></a>更优雅的下载并保存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="comment">#下载并保存</span></span><br><span class="line">filename,mime_hdrs=request.urlretrieve(url=<span class="string">'http://www.douban.com'</span>,filename=<span class="string">"mysecondpage.html"</span>)</span><br><span class="line"><span class="comment">#清除缓存</span></span><br><span class="line">request.urlcleanup()</span><br></pre></td></tr></table></figure><p>urlretrieve()函数只需要传入资源对应的url和要将其保存在本地的位置，就可以实现下载并保存。这个方法不仅可以实现html页面的下载保存，对于所有网络信息资源都可以，包括图片，视音频等。</p><p>urlretrieve()执行的过程中会产生一些缓存，如果我们想要清除这些缓存信息，可以使用urlcleanup()进行清除。</p><h4 id="url的编码"><a href="#url的编码" class="headerlink" title="url的编码"></a>url的编码</h4><p>一般来说，必须要对某些不能打印的或者不被web服务器作为有效URL接收的特殊字符串进行转换。在一个URL中，逗号，下划线，句号，斜线，字母，数字这类符号不需要转化，其他的均需要转化。转换过程中那些url不能使用的字符前面会被加上%,同时转换成16进制，例如”=”将被转换成’%3d’,’3d’就是’=’的ASCLL码的16进制。urllib.request中提供的url转换的api就三个<code>quote()</code>,<code>unquote()</code>,<code>unquote_to_bytes()</code>，后两个做相反的工作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">sourceUrl=<span class="string">"http://www.baidu.com/?key1=hhh&amp;key2=a b"</span></span><br><span class="line">quoteUrl=request.quote(sourceUrl)</span><br><span class="line"><span class="comment"># http%3A//www.baidu.com/%3Fkey1%3Dhhh%26key2%3Da%20b</span></span><br><span class="line">unquoteUrl=request.unquote(quoteUrl)</span><br><span class="line"><span class="comment"># http://www.baidu.com/?key1=hhh&amp;key2=a b</span></span><br><span class="line">unquotetobyte=request.unquote_to_bytes(quoteUrl)</span><br><span class="line"><span class="comment"># b'http://www.baidu.com/?key1=hhh&amp;key2=a b'</span></span><br></pre></td></tr></table></figure></p><p>Tips：如果你在写爬虫时遇到类似下面的保错：<br>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 14-15: ordinal not in range(128)<br>基本上就说明你的url需要转换了。如果你的url有中文，那就一定错了。一般来说，我们在浏览器地址栏中复制url时，浏览器就已经帮你做好转换了，所以一般不会遇到这种问题。但是，在自己构造url时就需要注意了。</p><h4 id="url参数的编码"><a href="#url参数的编码" class="headerlink" title="url参数的编码"></a>url参数的编码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">d=&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="string">"h?h"</span>,<span class="string">'c'</span>:<span class="string">"哈哈"</span>&#125;</span><br><span class="line">print(urlencode(d))</span><br><span class="line"><span class="comment">#输出　c=%E5%93%88%E5%93%88&amp;a=1&amp;b=h%3Fh</span></span><br></pre></td></tr></table></figure><p>urllib.parse.urlencode()可以从一个字典构造出查询字符串，并且自动做了url编码。</p><h4 id="urllib请求头的添加"><a href="#urllib请求头的添加" class="headerlink" title="urllib请求头的添加"></a>urllib请求头的添加</h4><p>在urllib中添加请求头有两种方式，使用<code>build_opener()</code>,使用<code>add_header()</code><br>1.使用build_opener()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">headers=[(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>),</span><br><span class="line">    (<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36"</span>)]</span><br><span class="line">opener=request.build_opener()</span><br><span class="line">opener.addheader=headers</span><br><span class="line">data=opener.open(<span class="string">"http://www.baidu.com"</span>).read()</span><br></pre></td></tr></table></figure></p><p>2.使用add_header()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">headers=[(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>),</span><br><span class="line">    (<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36"</span>)]</span><br><span class="line">req=request.Request(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">req.add_header(headers)</span><br><span class="line">data=request.urlopen(req).read()</span><br></pre></td></tr></table></figure></p><h4 id="代理服务器的设置"><a href="#代理服务器的设置" class="headerlink" title="代理服务器的设置"></a>代理服务器的设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">proxy=request.ProxyHandler(&#123;<span class="string">"http"</span>:<span class="string">"localhost:9999"</span>&#125;)</span><br><span class="line">opener=request.build_opener(proxy,request.HTTPHandler)</span><br><span class="line">request.install_opener(opener)</span><br><span class="line">data=request.urlopen(<span class="string">"http://www.baidu.com"</span>).read()</span><br></pre></td></tr></table></figure><h3 id="神器——urllib3"><a href="#神器——urllib3" class="headerlink" title="神器——urllib3"></a>神器——urllib3</h3><p><a href="https://urllib3.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">urllib3</a></p><blockquote><p>urllib3 is a powerful, sanity-friendly HTTP client for Python. Much of the Python ecosystem already uses urllib3 and you should too. urllib3 brings many critical features that are missing from the Python standard libraries:</p><ul><li>Thread safety.</li><li>Connection pooling.</li><li>Client-side SSL/TLS verification.</li><li>File uploads with multipart encoding.</li><li>Helpers for retrying requests and dealing with HTTP redirects.</li><li>Support for gzip and deflate encoding.</li><li>Proxy support for HTTP and SOCKS.</li><li>100% test coverage.</li></ul></blockquote><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="第一个urllib3例子"><a href="#第一个urllib3例子" class="headerlink" title="第一个urllib3例子"></a>第一个urllib3例子</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">response=http.request(<span class="string">'GET'</span>,<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.headers)</span><br><span class="line">print(response.status)</span><br><span class="line">print(response.data.decode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPHeaderDict(&#123;&apos;Set-Cookie&apos;: &apos;BAIDUID=DAB4C909697193545FA8395524CF0963:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com, BIDUPSID=DAB4C909697193545FA8395524CF0963; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com, PSTM=1511944442; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com&apos;, &apos;Server&apos;: &apos;BWS/1.1&apos;, &apos;Cache-control&apos;: &apos;no-cache&apos;, &apos;Last-Modified&apos;: &apos;Wed, 22 Nov 2017 02:22:00 GMT&apos;, &apos;P3P&apos;: &apos;CP=&quot; OTI DSP COR IVA OUR IND COM &quot;&apos;, &apos;Accept-Ranges&apos;: &apos;bytes&apos;, &apos;Date&apos;: &apos;Wed, 29 Nov 2017 08:34:02 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;X-UA-Compatible&apos;: &apos;IE=Edge,chrome=1&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Content-Length&apos;: &apos;14613&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Vary&apos;: &apos;Accept-Encoding&apos;&#125;)</span><br><span class="line">200</span><br><span class="line">&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">......此处省略部分输出</span><br></pre></td></tr></table></figure></p><h5 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h5><p>如上面的例子所示，你需要通过一个PoolManager实例来发起请求，这个实例对象会处理所有的和连接池，线程安全有关的细节。然后在这个PoolManager对象上调用request()方法，就可以发起请求。request()方法返回一个HttpResponse对象。通过该对象可以获取响应的内容。</p><h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><p>request()方法返回的HttpResponse对象有status,data和headers三个属性，分别来获取响应的状态码，响应的数据，和响应头。其中data属性获取的是bytes类型的数据，我们要使用它就要先对它进行解码(decode).</p><h5 id="请求头的设置"><a href="#请求头的设置" class="headerlink" title="请求头的设置"></a>请求头的设置</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">response=http.request(<span class="string">'GET'</span>,<span class="string">"http://www.baidu.com"</span>,headers=&#123;<span class="string">'X-Something'</span>: <span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure><p>请求头的信息在request()方法的headers参数中设置。</p><h5 id="查询参数的设置"><a href="#查询参数的设置" class="headerlink" title="查询参数的设置"></a>查询参数的设置</h5><p>对于GET,HEAD,DELETE请求，你可以直接将参数作为一个字典传个request()的fields参数，就像下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">response=http.request(<span class="string">'GET'</span>,<span class="string">"http://www.baidu.com"</span>,fields=&#123;<span class="string">'arg'</span>: <span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>但对于POST和PUT请求，你需要手动的编码查询参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">encoded_args = urlencode(&#123;<span class="string">'arg'</span>: <span class="string">'value'</span>&#125;)</span><br><span class="line">url = <span class="string">'http://httpbin.org/post?'</span> + encoded_args</span><br><span class="line">response = http.request(<span class="string">'POST'</span>, url)</span><br></pre></td></tr></table></figure></p><h5 id="提交表单数据"><a href="#提交表单数据" class="headerlink" title="提交表单数据"></a>提交表单数据</h5><p>就表单数据而言，主要使用的是POST,PUT两种提交方式，urllib3会自动的编码fields参数提供的字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">response = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,fields=&#123;<span class="string">'field'</span>: <span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="发送JSON给服务器"><a href="#发送JSON给服务器" class="headerlink" title="发送JSON给服务器"></a>发送JSON给服务器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">data = &#123;<span class="string">'attribute'</span>: <span class="string">'value'</span>&#125;</span><br><span class="line">encoded_data = json.dumps(data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">r = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,body=encoded_data,headers=&#123;<span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>&#125;)</span><br></pre></td></tr></table></figure><p>将需要发送给服务器的json数据编码后传递给request()的body参数，然后在请求头中设置Content-Type字段为application/json.</p><h5 id="发送文件或二进制数据"><a href="#发送文件或二进制数据" class="headerlink" title="发送文件或二进制数据"></a>发送文件或二进制数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'example.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    file_data = fp.read()</span><br><span class="line">r = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,fields=&#123;<span class="string">'filefield'</span>: (<span class="string">'example.txt'</span>, file_data,<span class="string">'text/plain'</span>)&#125;)</span><br></pre></td></tr></table></figure><p>在fields中的filefield对应的元组中，文件名的指定并不是严格必须的。为了匹配浏览器的行为，强烈建议在这个元组中传递第三个参数来指明文件的MIME类型。</p><p>对于原始二进制数据(raw binary data)的发送可以简单的指定body参数。同样为了匹配浏览器的行为，建议要设置请求头中的Content-Type字段。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'example.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">     binary_data = fp.read()</span><br><span class="line">r = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,body=binary_data,headers=&#123;<span class="string">'Content-Type'</span>: <span class="string">'image/jpeg'</span>&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="设置证书验证"><a href="#设置证书验证" class="headerlink" title="设置证书验证"></a>设置证书验证</h5><p>官方强烈建议我们总是使用<a href="https://zh.wikipedia.org/wiki/傳輸層安全性協定" target="_blank" rel="noopener">SSL</a>证书验证。这样能够保证我们与服务器之间的通信的安全。默认情况下，urllib3不验证HTTPS请求。<br>为了启用验证你需要一些根证书。最简单和最可靠的方法是使用<strong>certifi</strong>包。这个包提供了Mozilla的根证书包。在使用之前需要安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install certifi</span><br></pre></td></tr></table></figure></p><p>如果你在安装urllib3时使用了下面的命令，那么你的系统中就已经安装了certifi:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install urllib3[secure]</span><br></pre></td></tr></table></figure></p><p>这条命令在安装urllib3的同时会安装certifi.<br>如果你使用的是python2可能会需要其他的一些包。</p><p>一旦你安装了证书验证所需要的依赖，你在创建PoolManager对象的时候，就可以传入相应的参数，在请求的时候来启用证书验证。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> certifi</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(cert_reqs=<span class="string">"CERT_REQUIRED"</span>,ca_certs=certifi.where())</span><br><span class="line"><span class="comment">#下面请求https://google.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://google.com'</span>)<span class="comment">#没有任何错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面请求https://expired.badssl.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://expired.badssl.com'</span>)</span><br><span class="line"><span class="comment">#抛出urllib3.exceptions.SSLError：[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)的错误，说明该网站没有配置安全证书。</span></span><br></pre></td></tr></table></figure></p><p>在实例化PoolManager对象时做出上述配置后，PoolManager对象就会自动处理证书验证，如果验证失败就会抛出urllib3.exceptions.SSLError的异常。</p><p>如果需要的话，你也可以使用操作系统提供的证书，只需要将上述的ca_certs参数的值指定为你的系统中安全证书包所在的绝对路径即可。例如，在大多数的Linux操作系统中，安全证书存储在<code>/etc/ssl/certs/ca-certificates.crt</code>中。其他的操作系统可能会有些许不同。上述验证改为使用操作系统提供的证书后如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> certifi</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(cert_reqs=<span class="string">"CERT_REQUIRED"</span>,ca_certs=<span class="string">"/etc/ssl/certs/ca-certificates.crt"</span></span><br><span class="line"><span class="comment">#下面请求https://google.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://google.com'</span>)<span class="comment">#没有任何错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面请求https://expired.badssl.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://expired.badssl.com'</span>)</span><br><span class="line"><span class="comment">#抛出urllib3.exceptions.SSLError：[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)的错误，说明该网站没有配置安全证书。</span></span><br></pre></td></tr></table></figure></p><p><a href="https://urllib3.readthedocs.io/en/latest/user-guide.html#certificate-verification" target="_blank" rel="noopener">在python2中为urllib3应用添加证书验证功能</a></p><h5 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h5><p>设置超时时间可以让你控制你的请求最长等待的时间，超过你设置的时间服务器还没有响应，那么就抛出异常。<br>简单的,你可以给PoolManager对象的request()方法的timeout参数制定一个浮点数来制定本次请求的超时时间。就像下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,timeout=<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure></p><p>如果你需要更加细粒度的控制超时时间，你可以使用一个TimeOut实例来分别指定连接超时和读取超时：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line"><span class="comment">#只限制连接超时时间为2.0秒，对读取时间不做限制</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,</span><br><span class="line">        timeout=urllib3.Timeout(connect=<span class="number">2.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#限制连接超时时间为1.0秒，读取超时时间为2.0秒</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">        timeout=urllib3.Timeout(connect=<span class="number">1.0</span>,read=<span class="number">2.0</span>))</span><br></pre></td></tr></table></figure></p><p>如果你需要对所有的请求做同样的超时设置，那么你可以直接在PoolManager的层面上做配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http1=urllib3.PoolManager(timeout=<span class="number">3.0</span>)</span><br><span class="line">http2=urllib3.PoolManager(timeout=</span><br><span class="line">    urllib3.Timeout(connect=<span class="number">1.0</span>,read=<span class="number">2.0</span>))</span><br></pre></td></tr></table></figure></p><p>这样某一个PoolManager对象的所有的request()使用的默认超时设置就是它的PoolManager的超时设置。<strong>当然你仍然可以在request()方法中重载这个配置。</strong></p><h5 id="设置重试次数"><a href="#设置重试次数" class="headerlink" title="设置重试次数"></a>设置重试次数</h5><p>urllib3在默认情况下，再一次请求中，能够自动的重试３次，自动跟进３次重定向。你通过request()方法的retries参数控制重试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面的情况是重试次数为１０，最多跟进３次重定向</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.bidu.com"</span>,retries=<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>如果你要禁用重试<strong>和</strong>重定向跟进的功能的话，只需要将retries指定为False:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#禁用重定向跟进和重试功能</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,retries=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><p>如果你要禁用重定向跟进，但是保留默认的３次重试的话，你只需要将request()的redirect参数指定为False：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#禁用重定向的跟进功能，保留了３次的重试功能</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,redirect=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><p>同设置超时时间一样，如果你需要对重试次数和重定向跟进次数做更加细粒度的控制的话，你需要使用一个Retry实例，例如下面的例子就是最多做三次重试，两次重定向跟进：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,retires=</span><br><span class="line">    urllib3.Retry(<span class="number">3</span>,redirect=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>你可以通过下面的配置，来禁掉应重定向次数过多而造成的抛出错误这一行为，转而返回302的状态码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r=http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">    retries=urllib3.Retry(redirect=<span class="number">2</span>,raise_on_redirect=<span class="keyword">False</span>))</span><br><span class="line">print(r.status)</span><br><span class="line"><span class="comment">#这里如果重定向到次数超过两次的话，程序不会抛出错误，而是状态码返回302</span></span><br></pre></td></tr></table></figure></p><p>同样的，如果你想要为某一个PoolManager对象的所有request()配置同样的重试次数和重定向跟进次数的话，你可以在PoolManager层面上做配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http1=urllib3.PoolManager(retries=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">http2=urllib3.PoolManager(retries=urllib3.Retry(<span class="number">5</span>,redirect=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>这样某一个PoolManager对象的所有的request()使用的默认重试次数和重定向跟进次数就是它的PoolManager的重定向次数和重定向跟进次数。<strong>当然你仍然可以在request()方法中重载这个配置。</strong></p><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,retries=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">except</span> urllib3.exceptions.NewConnectorError <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">"Connection failed!"</span>,f)</span><br></pre></td></tr></table></figure><p>异常处理在爬虫中非常重要!更多关于urllib3中的异常可以查看其源码或者<a href="https://urllib3.readthedocs.io/en/latest/reference/index.html#module-urllib3.exceptions" target="_blank" rel="noopener">看这里</a></p><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>依靠标准库的logging,可以实现日志的记录：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.getLogger(<span class="string">"urllib3"</span>).setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure></p><h4 id="进阶话题"><a href="#进阶话题" class="headerlink" title="进阶话题"></a>进阶话题</h4><h5 id="自定义池行为"><a href="#自定义池行为" class="headerlink" title="自定义池行为"></a>自定义池行为</h5><p>PoolManager类自动帮你管理着ConnectionPool类的实例创建工作，一个ConnectionPool管理着发送给一个host的所有请求。默认情况下一个PoolManager最多管理10个ConnectionPool.如果在你的程序中需要向不止10个host同时发送请求的话，你可以更改以适量增加一个PoolManager最多可以管理的ConnectionPool数目，这样做可以提高urllib3的性能。但是同时这也会带来更多的内存和套接字消耗。更改的方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(num_pools=<span class="number">50</span>)</span><br></pre></td></tr></table></figure></p><p>这样就把一个PoolManager实例最多可以管理的ConnectionPool数目从默认的10改为了50。</p><p>同样的，一个ConnectionPool类管理着一个由多个HttpConnection实例组成的http连接池，每一个HttpConnection实例将会用于一个请求。当请求完成之后，连接就会返回到连接池中。默认情况下只有一个连接将会被保存以重用。如果你需要同时向一个host发送很多请求的话，你可以更改以适量增加一个连接池中将会被保存以重用的连接数目，这样有助于提高性能。更改的方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(maxsize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者,使用下面这种方式单独实例化一个对goole.com这一host的连</span></span><br><span class="line"><span class="comment">#接池,并且限定连接池中保存以重用的连接数为１０</span></span><br><span class="line">http=urllib3.HttpCoonnectionPool(<span class="string">"google.com"</span>,maxsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>默认情况下，对某一个host的一个新的请求发起了，如果此时这个host所对应的连接池中没有可用的连接，那么就会创建一个新的连接。然而如果此时连接池中被保存以重用的连接的数目不小于maxsize设定的值的话，这个新创建的连接将不会被保存以重用。也就是说，maxsize指定的数字不是决定一个连接池中最多可以存在的连接数目的多少，它仅仅指定了这个连接池中被保存以重用的连接数的最大值。但是，如果你指定了参数block=True的话，那么maxsize的值就也限制了某个host所对应的连接池中的最大连接个数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http = urllib3.PoolManager(maxsize=<span class="number">10</span>, block=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># Alternatively</span></span><br><span class="line">http = urllib3.HTTPConnectionPool(<span class="string">'google.com'</span>, maxsize=<span class="number">10</span>, block=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>这样的话，每一个新的请求将会被阻塞直到对应连接池中有一个连接可用为止。这样可以有效防止在多线程应用中，请求某一host的连接过于泛滥(多)的问题。</p><h5 id="流式处理大额响应"><a href="#流式处理大额响应" class="headerlink" title="流式处理大额响应"></a>流式处理大额响应</h5><p>当我们请求的是一个大文件，比方说是一部电影的数据的话，我们就需要对响应的内容做流式处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">r=http.request(<span class="string">"GET"</span>,<span class="string">"http://httpbin.org/bytes/1024"</span>,</span><br><span class="line">    preload_content=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> r.stream(<span class="number">32</span>):</span><br><span class="line">    print(chunk)</span><br><span class="line">r.release_conn()</span><br></pre></td></tr></table></figure></p><p>在request()方法中，将preload_content参数设为False意味着urllib3将会流式处理响应的内容。request()方法返回的HTTPResponse对象的stream()方法可以让你对响应的内容做迭代。</p><p>当你使用了<code>preload_content=False</code>这一选项时，你最后应该调用HTTPResponse对象的release_conn()方法来释放本次连接，让其返回连接池以重用。</p><p>你也可以把这个HTTPResponse对象当做一个类文件对象，这允许你做缓冲处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = http.request(</span><br><span class="line">     <span class="string">'GET'</span>,</span><br><span class="line">     <span class="string">'http://httpbin.org/bytes/1024'</span>,</span><br><span class="line">     preload_content=<span class="keyword">False</span>)</span><br><span class="line">r.read(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p>直接对read()方法的调用将会阻塞，直到有更多的响应内容可用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line">reader=io.BufferedReader(r,<span class="number">8</span>)</span><br><span class="line">reader.read(<span class="number">4</span>)</span><br><span class="line">r.release_conn()</span><br></pre></td></tr></table></figure></p><p>你可以利用这个类文件对象来做一些事情，比如用codecs来解码响应内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs,json</span><br><span class="line">reader=codecs.getreader(<span class="string">"utf-8"</span>)</span><br><span class="line">r=http.request(<span class="string">"GET"</span>,<span class="string">"http://httpbin.org/ip"</span>,preload_content=<span class="keyword">False</span>)</span><br><span class="line">data=json.load(reader(r))</span><br><span class="line">r.release_conn()</span><br></pre></td></tr></table></figure></p><h5 id="设置网络代理"><a href="#设置网络代理" class="headerlink" title="设置网络代理"></a>设置网络代理</h5><p>你可以使用ProxyManager通过HTTP代理来传输你的请求：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">proxy=urllib3.ProxyManager(<span class="string">"http://localhost:3128"</span>)</span><br><span class="line">proxy.request(<span class="string">"GET"</span>,<span class="string">"http://google.com/"</span>)</span><br></pre></td></tr></table></figure></p><p>ProxyManager的用法和PoolManager是一样的</p><p>你也可以使用SOCKSProxyManager来连接到SOCK4或者SOCKS5代理。为了启用SOCKS代理，你需要安装<a href="https://pypi.python.org/pypi/PySocks" target="_blank" rel="noopener">PySocks</a>或者安装urllib3的socks扩展:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install PySocks</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">$ pip3 install urllib3[socks]</span><br></pre></td></tr></table></figure></p><p>一旦你安装了PySocks，你就可以在你的代码中使用SOCKSProxyManager:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib3.contrib.socks <span class="keyword">import</span> SOCKSProxyManager</span><br><span class="line">proxy=SOCKSProxyManager(<span class="string">'socks5://localhost:8889/'</span>)</span><br><span class="line">proxy.request(<span class="string">'GET'</span>, <span class="string">'http://google.com/'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>剩下几个主题可能大家不会遇到，这里就不再介绍了，丢个<a href="https://urllib3.readthedocs.io/en/latest/advanced-usage.html#custom-ssl-certificates-and-client-certificates" target="_blank" rel="noopener">链接</a></p><h3 id="神器－－requests"><a href="#神器－－requests" class="headerlink" title="神器－－requests"></a>神器－－requests</h3><p><a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">requests</a>: HTTP for Humans<br>requests是另外一个HTTP客户端编程的神器，它构建在urllib3的基础之上，不仅继承了urllib3的优秀特质，并且全面自动的支持HTTP/1.1请求，带持久 Cookie和Session等,对我们用户来讲，它还拥有更加人性化的API设计。</p><p><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html#cookie" target="_blank" rel="noopener">Cookie处理</a></p><h2 id="反爬虫者与反反爬虫者之间的恩怨情仇"><a href="#反爬虫者与反反爬虫者之间的恩怨情仇" class="headerlink" title="反爬虫者与反反爬虫者之间的恩怨情仇"></a>反爬虫者与反反爬虫者之间的恩怨情仇</h2><p>爬虫对于网站拥有者来说并不是一个令人高兴的存在，因为爬虫的肆意横行意味着自己的网站资料泄露，资源消耗，甚至是自己刻意隐藏在网站的隐私的内容也会泄露。面对这样的状况，作为网站的维护者或者拥有者，要么抵御爬虫，通过各种反爬虫的手段阻挡爬虫，要么顺从爬虫，自动提供可供爬虫使用的接口。事实上，大多数的网站既会采取一些必要的反爬虫措施，也会提供一些开放的api供开发者获取数据。但是绝大多数的开放平台所提供的api都有各种各样的限制：无法完全满足你的需求，需要收费等。所以很多人更愿意自己到网站上去爬取数据，在这种情况之下伟大的反爬虫运动与反反爬虫运动之间的斗争就开始了。</p><h3 id="各种反爬虫手段及因对措施"><a href="#各种反爬虫手段及因对措施" class="headerlink" title="各种反爬虫手段及因对措施"></a>各种反爬虫手段及因对措施</h3><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p><code>原理</code>：对于比较简陋的爬虫程序来讲一般没有设置请求头，而浏览器等客户端工具一般会自动帮我们加上请求头，那么服务器就可以检查客户端发来的请求的请求头中的某些字段是否存在从而识别出客户端是爬虫程序。一般情况下，服务器会检查请求头的User-Agent字段。</p><p><code>应对</code>：这个应对的方法比较简单，我们只需要为请求添加请求头即可(主要是添加User-Agent字段)。这个过程在爬虫中叫做<strong>浏览器伪装</strong>。在这里给大家推荐一个简单实用的python包<a href="https://pypi.python.org/pypi/fake-useragent" target="_blank" rel="noopener">fake-useragent</a>，它可以方便的帮你生成User-Agent信息，这样你就不需要自己到处去复制了。</p><h4 id="IP限制"><a href="#IP限制" class="headerlink" title="IP限制"></a>IP限制</h4><p><code>原理</code>：如果是个人编写的爬虫，没做特殊处理的话，IP是固定的，那么服务器发现某个IP请求的频率超过了某一阈值，就可以判断这个客户端是爬虫程序了，网站的管理或者运维人员，一般的处理方式就是暂时封掉该IP,那么也就是说这个IP发出的请求在短时间(一般是数小时)内不能再访问这个网站了，也就暂时挡住了爬虫。</p><p><code>应对</code>：对于这种手段我们一般采取两种处理方式：设置延时和使用网络代理。<strong>设置延时</strong>很简单，就是让请求与请求之间停留一小段时间，让请求的频率降下来，这样就达不到请求频率的阈值，也就不会触发服务器的封IP行为了。使用<strong>HTTP代理</strong>之后，在服务器上显示的就是你的代理服务器的IP地址了，即使是封掉了IP封掉的也是代理服务器的地址，这时你换一个代理服务器就OK了。在实际中，我们会先准备大量的可用IP,从而建立一个IP池，每次请求都从IP池中任意选取一个IP去访问。<br>代理IP从<a href="http://www.xicidaili.com/wn/" target="_blank" rel="noopener">这儿</a>找,在选的时候大家尽量选择验证时间比较短，反应速度比较快的ip.</p><h4 id="Ajax动态加载"><a href="#Ajax动态加载" class="headerlink" title="Ajax动态加载"></a>Ajax动态加载</h4><p><code>原理</code>：对于网站来说，使用Ajax动态加载技术可以提高网站的工作效率，提升用户体验，在用户需要某个数据时(某一特定条件发生时)才发送这些数据到客户端，然后通过js在不刷新整个页面的情况下将这些数据渲染到页面上。但对于数据采集者来说，这却带来了巨大的麻烦。使用传统的请求工具无法得到想要的完整的数据。下面给大家看几个动态加载页面的例子：<a href="http://pythonscraping.com/pages/javascript/ajaxDemo.html" target="_blank" rel="noopener">特定时间后页面变化</a>，<a href="https://www.zhihu.com/#signin" target="_blank" rel="noopener">用户点击后页面变化</a></p><p><code>应对</code>：对于动态加载页面的爬取最好的处理方式是：<strong>PhantomJs+Selenium</strong>,这个在下面的高级主题中介绍。</p><h4 id="验证码反爬虫"><a href="#验证码反爬虫" class="headerlink" title="验证码反爬虫"></a>验证码反爬虫</h4><p><code>原理</code>：有些网站会对站内特殊的数据做额外的保护，你只有正确填写验证码之后才能访问到该网页，在这种情况下爬取的难度就非常大了。但是也不是不能爬取，主要要看它使用的是何种验证方式。<br><code>应对</code>：如果是普通的填写它给出的图片上的字符，那么可以使用图像识别的技术来处理，但其实现在的验证码往往都加了许多的干扰线，噪点之类的，连人类有时候都有可能识别错误，何况是机器呢！更厉害的是像12306的那种请点击以下所有包含海洋的图片，或者知乎的请点击下图中所有倒立的汉字等等，我只能说遇到类似这样的爬虫任务的话，你就只能认命了！</p><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>在上面的一部分中，我们讨论了如何下载，下面要讨论的则是下载到网页之后我们怎样从网页中提取数据的问题了。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>在计算机的世界中很多东西归根结底都可以归结到字符串的处理上，其中在某一字符串中提取另一种模式的字符串又是其中的重要组成部分。正则表达式解决的就是模式的描述的问题。python中的re模块提供了许多优秀的API,使Python语言拥有全部的正则表达式功能。详情参考<a href="http://cuiqingcai.com/977.html" target="_blank" rel="noopener">这里</a></p><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">BeautifulSoup</a></p><h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><p><a href="http://lxml.de/" target="_blank" rel="noopener">Xpath</a></p><h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><h2 id="动态页面的爬取"><a href="#动态页面的爬取" class="headerlink" title="动态页面的爬取"></a>动态页面的爬取</h2><p>先看两个例子:<a href="">自动登录发表文章</a>，<a href="">搜索并下载歌曲</a>。体会下phantomjs+selenium可以做啥！</p><h3 id="phantomJS"><a href="#phantomJS" class="headerlink" title="phantomJS"></a>phantomJS</h3><p><a href="http://phantomjs.org/quick-start.html" target="_blank" rel="noopener">phantomjs</a>是一个无界面的,可脚本编程的WebKit浏览器引擎。它原生支持多种web标准：DOM操作，CSS选择器，JSON，Canvas 以及SVG。可以帮助我们像浏览器一样渲染JS处理的页面。</p><p>这么使用phantomjs呢？看－&gt;<a href="http://javascript.ruanyifeng.com/tool/phantomjs.html" target="_blank" rel="noopener">这里</a>或<a href="http://cuiqingcai.com/2577.html" target="_blank" rel="noopener">这里</a>.</p><h3 id="selenium-python-bindings"><a href="#selenium-python-bindings" class="headerlink" title="selenium python bindings"></a>selenium python bindings</h3><p>首先推荐一个<a href="https://huilansame.github.io/huilansame.github.io/page3/" target="_blank" rel="noopener">博客</a>,这个人的博客写的全是selenium python的内容。</p><p><a href="http://selenium-python.readthedocs.io/" target="_blank" rel="noopener">selenium</a>是一个web测试自动化的工具。Selenium Python bindings 提供了一个简单的API，让你使用Selenium WebDriver来编写功能/校验测试。通过Selenium Python的API，你可以非常直观的使用Selenium WebDriver的所有功能。Selenium Python bindings 使用非常简洁方便的API让你去使用像Firefox, IE, Chrome, Remote等等这样的Selenium WebDrivers（Selenium web驱动器）。在生产环境中我们一般使用phantomjs这样的轻量级浏览器作为selenium web驱动。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>可以从PyPI的官方库中下载该selenium支持库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install selenium</span><br></pre></td></tr></table></figure></p><h4 id="你的第一个selenium应用"><a href="#你的第一个selenium应用" class="headerlink" title="你的第一个selenium应用"></a>你的第一个selenium应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">driver = webdriver.PhantomJS(executable_path=<span class="string">'/usr/local/bin/phantomjs'</span>)</span><br><span class="line">driver.get(<span class="string">"http://www.python.org"</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Python"</span> <span class="keyword">in</span> driver.title</span><br><span class="line">elem = driver.find_element_by_name(<span class="string">"q"</span>)</span><br><span class="line">elem.clear()</span><br><span class="line">elem.send_keys(<span class="string">"pycon"</span>)</span><br><span class="line">elem.send_keys(Keys.RETURN)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><h4 id="使用普通浏览器"><a href="#使用普通浏览器" class="headerlink" title="使用普通浏览器"></a>使用普通浏览器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># driver = webdriver.FireFox()</span></span><br><span class="line"><span class="comment"># driver =webdriver.IE()</span></span><br><span class="line">driver.get(<span class="string">"http://www.python.org"</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Python"</span> <span class="keyword">in</span> driver.title</span><br><span class="line">elem = driver.find_element_by_name(<span class="string">"q"</span>)</span><br><span class="line">elem.clear()</span><br><span class="line">elem.send_keys(<span class="string">"pycon"</span>)</span><br><span class="line">elem.send_keys(Keys.RETURN)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p>使用普通的浏览器需要安装浏览器驱动程序，并且保证这些驱动程序在你的环境变量中。常见的浏览器及其驱动下载地址如下：</p><table><thead><tr><th style="text-align:center">浏览器</th><th style="text-align:center">驱动下载地址</th></tr></thead><tbody><tr><td style="text-align:center">Chrome</td><td style="text-align:center"><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></td></tr><tr><td style="text-align:center">Edge</td><td style="text-align:center"><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/</a></td></tr><tr><td style="text-align:center">Firefox</td><td style="text-align:center"><a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></td></tr><tr><td style="text-align:center">Safari</td><td style="text-align:center"><a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/" target="_blank" rel="noopener">https://webkit.org/blog/6900/webdriver-support-in-safari-10/</a></td></tr></tbody></table><h4 id="打开一个页面"><a href="#打开一个页面" class="headerlink" title="打开一个页面"></a>打开一个页面</h4><p>你想做的第一件事也许是使用WebDriver打开一个链接。常规的方法是调用get方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"http://www.google.com"</span>)</span><br></pre></td></tr></table></figure></p><p>WebDriver 将等待，直到页面完全加载完毕（其实是等到 onload 方法执行完毕）， 然后返回继续执行你的脚本.</p><h4 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h4><p>selenium with python给我们提供了大量的用于在页面中定位元素的API，有了这些API，你可以在页面上找到任何你需要的元素。详细内容看－&gt;<a href="https://selenium-python-zh.readthedocs.io/en/latest/locating-elements.html" target="_blank" rel="noopener">这里</a></p><h4 id="页面交互"><a href="#页面交互" class="headerlink" title="页面交互"></a>页面交互</h4><h5 id="填写表单"><a href="#填写表单" class="headerlink" title="填写表单"></a>填写表单</h5><p>首先找到表单元素对象，然后对表单元素对象调用send_keys(data)方法就可以把data填写到input框中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"http://auth.muxixyz.com/login/"</span>)</span><br><span class="line">username_elem=driver.find_element_by_id(<span class="string">"username"</span>)</span><br><span class="line">username_elem.send_keys(<span class="string">"阿超"</span>)</span><br><span class="line">password_elem=driver.find_element_by_id(<span class="string">"password"</span>)</span><br><span class="line">password_elem.send_keys(<span class="string">"this is my pwd"</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"submit"</span>).click()</span><br><span class="line">WebDriverWait(driver,<span class="number">3</span>).until(<span class="keyword">lambda</span> x:x.find_element_by_xpath(<span class="string">"//a[@href='http://share.muxixyz.com/']"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#截取当前页面的图片</span></span><br><span class="line">driver.driver.get_screenshot_as_file(<span class="string">"1.png"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"1.html"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment">#获取当前页面的源码</span></span><br><span class="line">    f.write(driver.page_source)</span><br></pre></td></tr></table></figure></p><p>上述代码就是以我的账号密码登录木犀内网，然后将跳转之后的页面的图截下来保存为1.png，将当前页面的源码保存为1.html.</p><h4 id="键盘模拟"><a href="#键盘模拟" class="headerlink" title="键盘模拟"></a>键盘模拟</h4><p><a href="http://selenium-python-zh.readthedocs.io/en/latest/api.html#module-selenium.webdriver.common.keys" target="_blank" rel="noopener">键盘模拟</a><br>当调用一个元素对象的send_keys()方法的时候，不光可以向这个元素传递数据，也可以传递selenium.webdriver.common.keys．Keys的实例来模拟键盘的操作<br>，这可以用来测试网站的快捷键设置是否正确。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line">driver.get(<span class="string">"http://www.douban.com"</span>)</span><br><span class="line">driver.get_screenshot_as_file(<span class="string">"douban.png"</span>)</span><br><span class="line">username = driver.find_element_by_name(<span class="string">"form_email"</span>)</span><br><span class="line">password = driver.find_element_by_name(<span class="string">"form_password"</span>)</span><br><span class="line">submit=driver.find_element_by_class_name(<span class="string">"bn-submit"</span>)</span><br><span class="line">username.send_keys(<span class="string">"13636038496"</span>)</span><br><span class="line">password.send_keys(<span class="string">"this is my pwd"</span>)</span><br><span class="line">submit.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面的三行代码也可以写成下面这样</span></span><br><span class="line"><span class="comment"># username.send_keys("13636038496")</span></span><br><span class="line"><span class="comment"># password.send_keys("this is my pwd"，Keys.RETURN)</span></span><br></pre></td></tr></table></figure></p><p>一般网站的表单填写完了之后，都可以直接通过按下回车键提交表单,上面注释的代码就是模拟了这个过程。</p><h4 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">currentWin = driver.current_window_handle</span><br><span class="line"><span class="comment">#跳转到另一个新页面</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//p[@id='nv']/a[3]"</span>).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#获取所有窗口的句柄</span></span><br><span class="line">handles = driver.window_handles</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> handles:</span><br><span class="line">    <span class="keyword">if</span> currentWin == i:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#将driver与新的页面绑定起来</span></span><br><span class="line">        driver = driver.switch_to_window(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to_window(<span class="string">"windowName"</span>)</span><br><span class="line">driver.switch_to_frame(<span class="string">"frameName"</span>)</span><br><span class="line">alert = driver.switch_to_alert()</span><br></pre></td></tr></table></figure><h4 id="历史记录和定位"><a href="#历史记录和定位" class="headerlink" title="历史记录和定位"></a>历史记录和定位</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.forward()</span><br><span class="line">driver.back()</span><br></pre></td></tr></table></figure><h4 id="cookie处理"><a href="#cookie处理" class="headerlink" title="cookie处理"></a>cookie处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置cookie</span></span><br><span class="line">cookie = &#123;<span class="string">'name'</span>:<span class="string">'foo'</span>,<span class="string">'value'</span>:<span class="string">'bar'</span>&#125;</span><br><span class="line">driver.add_cookie(cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出当前url下可用的cookie</span></span><br><span class="line">driver.get_cookies()</span><br></pre></td></tr></table></figure><h4 id="设置等待"><a href="#设置等待" class="headerlink" title="设置等待"></a>设置等待</h4><p>现在的app有许多都在使用ajax(Asynchronous Javascript And XML)技术,这使得在一个页面中的元素的出现时间会产生差异，这给元素的定位带来了不小的困难。如果一个元素还没有出现在DOM中，那么你用一个定位函数去定位这个元素的时候就会产生<code>ElementNotVisibleException</code>的错误。使用等待可以解决这个问题。Selenium Webdriver提供了两种等待：显式等待(Explicit Waits)和隐式等待(Implicit Waits).</p><h5 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>)  <span class="comment"># 隐性等待，最长等30秒</span></span><br><span class="line">driver.get(<span class="string">'https://huilansame.github.io'</span>)</span><br><span class="line"></span><br><span class="line">print(driver.current_url)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。注意这里有一个弊端，那就是程序会一直等待整个页面加载完成，也就是一般情况下你看到浏览器标签栏那个小圈不再转，才会执行下一步，但有时候页面想要的元素早就在加载完成了，但是因为个别js之类的东西特别慢，我仍得等到页面全部完成才能执行下一步，我想等我要的元素出来之后就下一步怎么办？有办法，这就要看selenium提供的另一种等待方式——显性等待wait了。<br>Tip:隐性等待对整个driver的周期都起作用，所以只要设置一次即可</p><h5 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h5><p>显示等待是你在你的代码中设置的等待某一个条件发生之后才继续向下执行的等待。selenium提供了一些方便的方法来帮助你设置你的等待，并且可以让等待只花所需要的时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://somedomain/url_that_delays_loading"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">"myDynamicElement"</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure></p><p>上面的例子中的意思是通过id来获取”myDynamicElement”元素，如果当前DOM中没有这个元素，那么就等待，最长等待的时间是10秒，如果十秒钟之后该元素仍然没有出现，则抛出<code>TimeoutException</code>错误。如果在等待的过程中该元素加载出来了，那么该函数就立即返回，停止等待。默认情况下，selenium webdriver每500毫秒，检查一下预期条件。</p><p>selenium with python提供了许多的常用的期望条件来帮助你操控你的浏览器。常用的预期条件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">selenium.webdriver.support.expected_conditions（模块）</span><br><span class="line"></span><br><span class="line">这两个条件类验证title，验证传入的参数title是否等于或包含于driver.title</span><br><span class="line">title_is</span><br><span class="line">title_contains</span><br><span class="line"></span><br><span class="line">这两个人条件验证元素是否出现，传入的参数都是元组类型的locator，如(By.ID, &apos;kw&apos;)</span><br><span class="line">顾名思义，一个只要一个符合条件的元素加载出来就通过；另一个必须所有符合条件的元素都加载出来才行</span><br><span class="line">presence_of_element_located</span><br><span class="line">presence_of_all_elements_located</span><br><span class="line"></span><br><span class="line">这三个条件验证元素是否可见，前两个传入参数是元组类型的locator，第三个传入WebElement</span><br><span class="line">第一个和第三个其实质是一样的</span><br><span class="line">visibility_of_element_located</span><br><span class="line">invisibility_of_element_located</span><br><span class="line">visibility_of</span><br><span class="line"></span><br><span class="line">这两个人条件判断某段文本是否出现在某元素中，一个判断元素的text，一个判断元素的value</span><br><span class="line">text_to_be_present_in_element</span><br><span class="line">text_to_be_present_in_element_value</span><br><span class="line"></span><br><span class="line">这个条件判断frame是否可切入，可传入locator元组或者直接传入定位方式：id、name、index或WebElement</span><br><span class="line">frame_to_be_available_and_switch_to_it</span><br><span class="line"></span><br><span class="line">这个条件判断是否有alert出现</span><br><span class="line">alert_is_present</span><br><span class="line"></span><br><span class="line">这个条件判断元素是否可点击，传入locator</span><br><span class="line">element_to_be_clickable</span><br><span class="line"></span><br><span class="line">这四个条件判断元素是否被选中，第一个条件传入WebElement对象，第二个传入locator元组</span><br><span class="line">第三个传入WebElement对象以及状态，相等返回True，否则返回False</span><br><span class="line">第四个传入locator以及状态，相等返回True，否则返回False</span><br><span class="line">element_to_be_selected</span><br><span class="line">element_located_to_be_selected</span><br><span class="line">element_selection_state_to_be</span><br><span class="line">element_located_selection_state_to_be</span><br><span class="line"></span><br><span class="line">最后一个条件判断一个元素是否仍在DOM中，传入WebElement对象，可以判断页面是否刷新了</span><br><span class="line">staleness_of</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">element = wait.until(EC.element_to_be_clickable((By.ID, <span class="string">'someid'</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐性等待和显性等待可以同时用，但要注意：等待的最长时间取两者之中的大者</span></span><br><span class="line">driver.get(<span class="string">'https://huilansame.github.io'</span>)</span><br><span class="line">locator = (By.LINK_TEXT, <span class="string">'CSDN'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    WebDriverWait(driver, <span class="number">20</span>, <span class="number">0.2</span>).until(EC.presence_of_element_located(locator))</span><br><span class="line">    print(driver.find_element_by_link_text(<span class="string">'CSDN'</span>).get_attribute(<span class="string">'href'</span>))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.close()</span><br></pre></td></tr></table></figure><p>如果上述提供的期待条件没有满足你的需求，你也可以自定义期望条件：可以通过一个实现了<code>__call__()</code>方法的类来自定义一个等待的期望条件。这个<code>__call__()</code>方法在不匹配的情况下，返回False即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">element_has_css_class</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""An expectation for checking that an element has a particular css class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  locator - used to find the element</span></span><br><span class="line"><span class="string">  returns the WebElement once it has the particular css class</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, locator, css_class)</span>:</span></span><br><span class="line">    self.locator = locator</span><br><span class="line">    self.css_class = css_class</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, driver)</span>:</span></span><br><span class="line">    element = driver.find_element(*self.locator)   <span class="comment"># Finding the referenced element</span></span><br><span class="line">    <span class="keyword">if</span> self.css_class <span class="keyword">in</span> element.get_attribute(<span class="string">"class"</span>):</span><br><span class="line">        <span class="keyword">return</span> element</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait until an element with id='myNewInput' has class 'myCSSClass'</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">element = wait.until(element_has_css_class((By.ID, <span class="string">'myNewInput'</span>), <span class="string">"myCSSClass"</span>))</span><br></pre></td></tr></table></figure></p><p>除了上面介绍的几种等待的方式，使用<code>time.sleep()</code>也可以实现等待的效果，但是这种方法比较low,推荐不要使用。</p><h4 id="PhantomJS请求配置"><a href="#PhantomJS请求配置" class="headerlink" title="PhantomJS请求配置"></a>PhantomJS请求配置</h4><p>一般来讲，如果是做爬虫的话，使用的web driver都是PhantomJS，相较于大家桌面上的浏览器的话，它更轻量级，所以速度更快。在使用PhantomJS时，可以对其进行一些配置,比如设置请求头，设置网络代理等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line">ua = UserAgent()</span><br><span class="line"><span class="comment">#配置对象DesiredCapabilities</span></span><br><span class="line">dcap = dict(DesiredCapabilities.PHANTOMJS)</span><br><span class="line"><span class="comment">#从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器</span></span><br><span class="line">dcap[<span class="string">"phantomjs.page.settings.userAgent"</span>] = ua.random</span><br><span class="line"><span class="comment"># 不载入图片，爬页面速度会快很多</span></span><br><span class="line">dcap[<span class="string">"phantomjs.page.settings.loadImages"</span>] = <span class="keyword">True</span></span><br><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">service_args = [<span class="string">'--proxy=127.0.0.1:9999'</span>,<span class="string">'--proxy-type=socks5'</span>]</span><br><span class="line"><span class="comment">#打开带配置信息的phantomJS浏览器</span></span><br><span class="line">driver = webdriver.PhantomJS(phantomjs_driver_path, desired_capabilities=dcap,service_args=service_args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐式等待5秒，可以自己调节</span></span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项</span></span><br><span class="line"><span class="comment"># 以前遇到过driver.get(url)一直不返回，但也不报错的问题，这时程序会卡住，设置超时选项能解决这个问题。</span></span><br><span class="line">driver.set_page_load_timeout(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 设置10秒脚本超时时间</span></span><br><span class="line">driver.set_script_timeout(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="道德问题"><a href="#道德问题" class="headerlink" title="道德问题"></a>道德问题</h2><p>在互联网这个复杂的环境中，搜索引擎本身的爬虫，出于个人目的的爬虫，商业爬虫肆意横行，肆意掠夺网上的或者公共或者私人的资源。显然数据的收集并不是为所欲为，有一些协议或者原则还是需要每一个人注意。</p><h3 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h3><p>一般情况下网站的根目录下存在着一个robots.txt的文件，用于告诉爬虫那些文件夹或者哪些文件是网站的拥有者或者管理员不希望被搜索引擎和爬虫浏览的，或者是不希望被非人类的东西查看的。但是不仅仅如此，在这个文件中，有时候还会指明sitemap的位置，爬虫可以直接寻找sitemap而不用费力去爬取网站。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> urllib </tag>
            
            <tag> urllib3 </tag>
            
            <tag> requests </tag>
            
            <tag> bs4 </tag>
            
            <tag> xpath </tag>
            
            <tag> phantomjs </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/2017/11/22/Sort-Algorithm/"/>
      <url>/2017/11/22/Sort-Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h2><h3 id="按是否涉及数据的内外存交换分"><a href="#按是否涉及数据的内外存交换分" class="headerlink" title="按是否涉及数据的内外存交换分"></a>按是否涉及数据的内外存交换分</h3><p>在排序过程中，若整个文件都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为<strong>内部排序</strong>(简称内排序)；反之，若排序过程中要进行数据的内、外存交换，则称之为<strong>外部排序</strong>。<code>本文的内容均基于内部排序。</code></p><h3 id="在内排序基础上按策略分"><a href="#在内排序基础上按策略分" class="headerlink" title="在内排序基础上按策略分"></a>在内排序基础上按策略分</h3><p>可以分为五类：插入排序、选择排序、交换排序、归并排序和分配排序。</p><p><img src="/images/paixu.png" alt="排序"></p><h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>当待排序记录的关键字均不相同时，排序结果是惟一的，否则排序结果不唯一。</p><p>在待排序的文件中，若存在多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，该排序方法是稳定的；若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是不稳定的。</p><p>注意： 排序算法的稳定性是针对所有输入实例而言的。即在所有可能的输入实例中，只要有一个实例使得算法不满足稳定性要求，则该排序算法就是不稳定的。</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子文件中的适当位置，直到全部记录插入完成为止。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>待排序序列被人为的分为两部分：有序区和无序区。起始时刻第一个元素自成一个有序区，其他的n-1个元素组成无序区(n为待排序数据个数)。每趟循环从无序区取出一个元素，然后插入到有序区中，并且插入后仍然保持有序区的有序。这样的话，每次循环过后，有序曲的数据量加一，无序区的数据量减一，经过<code>n-1</code>次循环后，有序曲的数据量为n,无序区的数据量为０，排序也就完成了。</p><p>插入排序与打扑克时整理手上的牌非常类似。摸来的第 1 张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的 1 张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>就将一个数组a按照从小到大排列作为例子吧！首先，取无序区的第一个数据作为待插入的数据(由于是起始时刻，这里取得是a[1])，然后找到该数据在无序区中该插入的位置，进行插入即可。这里可以充分利用有序曲的数据已经有序的特点：如果取到的待插入的数据比有序区的最右边的数据大(这里即为有序曲中最大的数据)，则该数据当前所在的位置即为它该插入的位置，也就是说，此时什么也不用做，直接取下一个数据；如果取到的待插入数据比有序曲的最右边的那个数据小，则说明该数据的插入位置在它当前位置的左边，此时就需要找到这个位置。怎么找呢？我们可以首先把有序曲的最右边的数据(即最大的那个数据)右移一位(在右移之前要先用一个辅助变量保存我们的待插入数据，以防右移时覆盖了它)，然后比较有序区右边第二个数据与待插入数据的大小，如果这个数仍然大于待插入数据，则依然将这个数右移一位。重复上述过程，直到出现了下面两种情况之一：在有序区中找到了一个小于等于待插入数据的数据或者找到头都没有找到这么一个数据。待插入数据的位置也就找到了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>未引入哨兵：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[<span class="number">9</span>]=&#123;<span class="number">100</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> length=<span class="number">9</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//变量temp用于保存取到的数据，防止后面的移动而被覆盖</span></span><br><span class="line">       <span class="keyword">int</span> temp=a[i];<span class="comment">//待插入的数据(无序区左边的第一个元素)</span></span><br><span class="line">       <span class="keyword">int</span> j=i<span class="number">-1</span>;<span class="comment">//有序取右边的第一个元素</span></span><br><span class="line">       <span class="keyword">if</span>(a[j]&gt;temp)&#123;</span><br><span class="line">           <span class="comment">//如果a[j]&lt;=temp则说明temp插入的位置就是当前所在的位置，直接取下一个数，进入下一轮循环.</span></span><br><span class="line">           <span class="comment">//这里a[j]&gt;temp,说明temp插入的位置不在当前位置，而在更低位，下面就是要寻找这样的位置</span></span><br><span class="line">           <span class="keyword">do</span>&#123;</span><br><span class="line">               a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">               j--;</span><br><span class="line">           &#125;<span class="keyword">while</span>(a[j]&gt;temp&amp;&amp;j&gt;=<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//找到了头或者找到了一个小于等于temp的位置</span></span><br><span class="line">           <span class="comment">//找到了temp该插入的位置，插入temp</span></span><br><span class="line">           a[j+<span class="number">1</span>]=temp;</span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//打印输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引入哨兵:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lnsertSort</span><span class="params">(SeqList R)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">//对顺序表R中的记录R[1..n]按递增序进行插入排序  </span></span><br><span class="line">  <span class="keyword">int</span> i，j；  </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n；i++)&#123; <span class="comment">//依次插入R[2]，…，R[n]  </span></span><br><span class="line">    <span class="keyword">if</span>(R[i].key&lt;R[i<span class="number">-1</span>].key)&#123;<span class="comment">//若R[i].key大于等于有序区中所有的keys，则R[i]  </span></span><br><span class="line">                            <span class="comment">//应在原有位置上  </span></span><br><span class="line">      R[<span class="number">0</span>]=R[i];j=i<span class="number">-1</span>; <span class="comment">//R[0]是哨兵，且是R[i]的副本  </span></span><br><span class="line">      <span class="keyword">do</span>&#123; <span class="comment">//从右向左在有序区R[1．．i-1]中查找R[i]的插入位置  </span></span><br><span class="line">       R[j+<span class="number">1</span>]=R[j]； <span class="comment">//将关键字大于R[i].key的记录后移  </span></span><br><span class="line">       j-- ；  </span><br><span class="line">       &#125;<span class="keyword">while</span>(R[<span class="number">0</span>].key&lt;R[j].key)； <span class="comment">//有了哨兵，这里无需判断数组越界</span></span><br><span class="line">      R[j+<span class="number">1</span>]=R[<span class="number">0</span>]； <span class="comment">//R[i]插入到正确的位置上  </span></span><br><span class="line">     &#125;<span class="comment">//endif  </span></span><br><span class="line"> &#125;<span class="comment">//endfor</span></span><br><span class="line"> &#125;<span class="comment">//InsertSort</span></span><br></pre></td></tr></table></figure></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="关于哨兵"><a href="#关于哨兵" class="headerlink" title="关于哨兵"></a>关于哨兵</h4><p>2．哨兵的作用<br>算法中引进的附加记录 R[0]称监视哨或哨兵(Sentinel)。相比于未引入哨兵的代码，引入哨兵的代码中<code>do-while</code>循环中不需要检查每次j是否越界，这对于程序速度的提升作用巨大，特别是在数据量很大的情况之下。<br>这里哨兵有两个作用：</p><ul><li>进入查找(插入位置)循环之前，它保存了 R[i]的副本，使不致于因记录后移而丢失 R[i]的内容；</li><li>它的主要作用是：在查找循环中”监视”下标变量j是否越界。一旦越界(即 j=0)，因为 R[0].key和自己比较，循环判定条件不成立使得查找循环结束，从而避免了在该循环内的每一次均要检测j是否越界(即省略了循环判定条件”j&gt;=1”)</li></ul><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><p>时间复杂度：O(n)-O(n^2)<br>空间复杂度：O(n)<br>辅助空间复杂度：O(1)<br>是一个就地排序，稳定的排序方法</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell Sort)是插入排序的一种。因 D.L.Shell 于 1959 年提出而得名.相对直接排序有较大的改进。希尔排序又叫缩小增量排序</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj(i&lt;j)，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子序列进行直接插入排序。仅增量因子为1时，整个序列作为一个序列来处理，序列长度即为整个序列的长度</li></ul><p>我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 …..1} n为要排序数的个数<br>即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i &lt;&lt;”:”;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[j] &lt;&lt;” “;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    直接插入排序的一般形式</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">    @param int dk 缩小增量，如果是直接插入排序，dk=1</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= dk; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i-dk])&#123; <span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span></span><br><span class="line">            <span class="keyword">int</span> j = i-dk;</span><br><span class="line">            <span class="keyword">int</span> x = a[i]; <span class="comment">//复制为哨兵，即存储待排序元素</span></span><br><span class="line">            a[i] = a[i-dk]; <span class="comment">//首先后移一个元素</span></span><br><span class="line">            <span class="keyword">while</span>(x &lt; a[j])&#123; <span class="comment">//查找在有序表的插入位置</span></span><br><span class="line">                a[j+dk] = a[j];</span><br><span class="line">                j -= dk; <span class="comment">//元素后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[j+dk] = x; <span class="comment">//插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(a, n,i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    先按增量d（n/2,n为要排序数的个数进行希尔排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dk = n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>( dk &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">        ShellInsertSort(a, n, dk);</span><br><span class="line">        dk = dk/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//ShellInsertSort(a,8,1); //直接插入排序</span></span><br><span class="line">    shellSort(a,<span class="number">8</span>); <span class="comment">//希尔插入排序</span></span><br><span class="line">    print(a,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法</p><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>将被排序的记录数组 R[1..n]垂直排列，每个记录 R[i]看作是重量为 R[i].key 的气泡。根据轻气泡不能在重气泡之下的原则，从下往上扫描数组 R：凡扫描到违反本原则的轻气泡，就使其向上”飘浮”。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。</p><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><p>假如现在需要对长度为n的数组a从小到大排序，从右向左两两比较，遇到不符合规则的就交换。这样经过一次扫描之后，最小的数就一定到了最前面，经过第二次扫描之后第二小的数就一定到了第二的位置，以此类推，经过n-1次扫描之后，排序就完成了。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>改进前：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//外循环控制扫描的次数，只需要扫描n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=length<span class="number">-1</span>;j&gt;=i;j--)&#123;<span class="comment">//从底部扫描起，有不符合规则的则交换</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">                a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">                a[j<span class="number">-1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;length;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在经过n-1次外层循环之后，我们就保证一定可以达到序列有序的目标。但是，序列也有可能在中间的某层循环中就已经达到了有序，这时后面的剩下的循环就是做无用功。一个比较极端的例子，我们需要排序的数组已经就是从小到大排列的，那么会发生什么呢？这时里层循环中的判断条件<code>a[j]&lt;a[j-1]</code>永远不会成立，if语句内的内容永远不会执行。也就是说，在这种情况下，一次外层循环过后，就应该停止。我们可以基于这一点来做优化。</p><p>改进后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//外循环控制扫描的次数，只需要扫描n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=length<span class="number">-1</span>;j&gt;=i;j--)&#123;<span class="comment">//从底部扫描起，有不符合规则的则交换</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">                a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">                a[j<span class="number">-1</span>]=temp;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="comment">//说明此时数据已经有序，不必继续循环了。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;length;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>算法的最好时间复杂度<br>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：<br>Cmin=n-1<br>Mmin=0。<br>冒泡排序最好的时间复杂度为 O(n)。</p></li><li><p>算法的最坏时间复杂度<br>若初始文件是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>Cmax=n(n-1)/2=O(n^2)<br>Mmax=3n(n-1)/2=O(n^2)<br>冒泡排序的最坏时间复杂度为 O(n^2)。</p></li><li><p>算法的平均时间复杂度为 O(n2)<br>虽然冒泡排序不一定要进行 n-1 趟，但由于它的记录移动次数较多，故平均时间性能比直接插入排序要差得多。</p></li><li><p>算法稳定性<br>冒泡排序是就地排序，且它是稳定的。</p></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是 C.R.A.Hoare 于 1962 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>就以将序列按从小到大排列为例，任意取序列中的某一元素为基准元素，然后把比基准元素小的元素全放到基准元素的左边，把比基准元素大的元素全放到基准元素的右边。这样基准元素就归位了。基准元素左右两边分别得到了两个新的无序序列，我们可以对这两个无序序列做同样的操作，就这样递归下去，直到所有的元素都归位为止。</p><h3 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h3><p><img src="/images/qs1.png" alt="qs1"><br>假如我们以将上图的序列按照从小到大排列为例。由于基准元素的选取具有随机性，我在这里每次就直接以序列最左边的那个数作为基准元素(这里的基准元素就是６)。我们设定两个哨兵：ｉ和ｊ，分别指向序列的第一个元素和最后一个元素。然后将j向左移动(一定是ｊ先开始移动)，去找一个比６小的数，找到之后就停下。然后让ｉ向右移动，找到一个比６大的元素，找到之后也停下来。这时两个哨兵就可以交换两者的元素了。如下图：<br><img src="/images/qs2.png" alt="qs1"></p><p>交换后：<br><img src="/images/qs3.png" alt="qs1"></p><p>同样的这时仍然是j先开始向左移动，去找比６小的元素，找到后停下来。i开始向右移动，找到一个比6大的元素。然后交换。<br><img src="/images/qs4.png" alt="qs1"><br>交换后：<br><img src="/images/qs5.png" alt="qs1"></p><p>重复上面的j,i移动过程，但是这一次好像出现了一定小问题，i和j碰头了！<br><img src="/images/qs6.png" alt="qs1"><br>这时就需要把我们的基准元素和当前i,j共同指向的元素交换位置即可。<br><img src="/images/qs7.png" alt="qs1"><br>交换后：<br><img src="/images/qs8.png" alt="qs1"><br>至此，我们的基准元素就归位了，基准元素的两边的又得到了两个新的无序序列，我们只需要对他们使用同样的方法处理即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>快速排序可以使用两种方式实现，分别是递归法和迭代法。</p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>],n;<span class="comment">//定义全局变量，这两个变量需要在子函数中使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">                                    </span><br><span class="line">    temp=a[left]; <span class="comment">//temp中存的就是基准数</span></span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)</span><br><span class="line">    &#123;</span><br><span class="line">                   <span class="comment">//顺序很重要，要先从右边开始找</span></span><br><span class="line">                   <span class="keyword">while</span>(a[j]&gt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">                            j--;</span><br><span class="line">                   <span class="comment">//再找右边的</span></span><br><span class="line">                   <span class="keyword">while</span>(a[i]&lt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">                            i++;</span><br><span class="line">                   <span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line">                   <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">                   &#123;</span><br><span class="line">                            t=a[i];</span><br><span class="line">                            a[i]=a[j];</span><br><span class="line">                            a[j]=t;</span><br><span class="line">                   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终将基准数归位</span></span><br><span class="line">    a[left]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">                                 </span><br><span class="line">    quicksort(left,i<span class="number">-1</span>);<span class="comment">//继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">    quicksort(i+<span class="number">1</span>,right);<span class="comment">//继续处理右边的 ，这里是一个递归的过程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,t;</span><br><span class="line">    <span class="comment">//读入数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    quicksort(<span class="number">1</span>,n); <span class="comment">//快速排序调用</span></span><br><span class="line">                                 </span><br><span class="line">    <span class="comment">//输出排序后的结果</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max, <span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = a[min];</span><br><span class="line">    <span class="keyword">int</span> i = min;</span><br><span class="line">    <span class="keyword">int</span> j = max;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">myStack</span>[100];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    myStack[top].min = min;</span><br><span class="line">    myStack[top].max = max;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//min max 记录当前处理的这个区间的左极限和有极限</span></span><br><span class="line">        i = min = myStack[top].min;</span><br><span class="line">        j = max = myStack[top].max;</span><br><span class="line">        top--;</span><br><span class="line">        key = a[min];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; j) &amp;&amp; (key &lt;= a[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; j) &amp;&amp; (key &gt;= a[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//处理一次即将比绑定值小的全部放左边 比绑定值大的放右边</span></span><br><span class="line">        <span class="keyword">if</span> (min &lt; i - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            myStack[top].min = min;</span><br><span class="line">            myStack[top].max = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; i + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            myStack[top].min = i + <span class="number">1</span>;</span><br><span class="line">            myStack[top].max = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">14</span>] = &#123;<span class="number">20</span>,<span class="number">2</span>,<span class="number">52</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    quickSort(<span class="number">0</span>, <span class="number">13</span>, a);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>在数据量很大的情况下，快速排序是在时间和空间综合方面做的非常好的排序方法之一。<br>最坏时间复杂度：O(n^2)<br>最好时间复杂度：O(nlogn)<br>快速排序是不稳定的。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>依然以将序列从小到大排列为例，选择排序的思想是这样的：既然排序之后第一位一定是放着最小的元素，第二位是放着第二小的元素……那么我们就可以在序列中先找到最小的元素放在第一位，然后从第二位开始找余下的数据的最小值并且放在第二位，然后从第三位找余下的数据的最小值并且放在第三位，以此类推，直达排序完成。</p><h3 id="具体实现-4"><a href="#具体实现-4" class="headerlink" title="具体实现"></a>具体实现</h3><p>以数组a为例，外层循环从a[0]开始，里层循环从a[1]开始，如果a[1]小于a[0]则交换之，接着分别比较a[2],a[3],a[4]……和a[0]的大小，谁更小谁就去坐a[0]的位置。就这样经过一轮的循环，就选择出来了最小的元素放在了a[0]的位置，接下来外层循环从a[1]开始(看看剩下的元素中谁最小，谁就可以坐a[1]这个位置)，里层循环从a[2]开始，依次类推。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Select Sort</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[i];</span><br><span class="line">                a[i]=a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接选择排序的改进"><a href="#直接选择排序的改进" class="headerlink" title="直接选择排序的改进"></a>直接选择排序的改进</h3><p>简单选择排序的改进——二元选择排序<br>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,j , min ,max, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span> ;i &lt;= n/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 做不超过n/2趟选择排序</span></span><br><span class="line">        min = i; max = i ; <span class="comment">//分别记录最大和最小关键字记录位置</span></span><br><span class="line">        <span class="keyword">for</span> (j= i+<span class="number">1</span>; j&lt;= n-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r[j] &gt; r[max]) &#123;</span><br><span class="line">                max = j ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r[j]&lt; r[min]) &#123;</span><br><span class="line">                min = j ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//该交换操作还可分情况讨论以提高效率</span></span><br><span class="line">    tmp = r[i<span class="number">-1</span>]; r[i<span class="number">-1</span>] = r[min]; r[min] = tmp;</span><br><span class="line">    tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>关键字比较次数<br>无论文件初始状态如何，在第 i 趟排序中选出最小关键字的记录，需做 n-i 次比较，因此，总的比较次数为： n(n-1)/2=O(n2)</li><li>记录的移动次数<br>当初始文件为正序时，移动次数为 0<br>文件初态为反序时，每趟排序均要执行交换操作，总的移动次数取最大值 3(n-1)。<br>直接选择排序的平均时间复杂度为 O(n2)。<br>直接选择排序是一个就地排序</li><li>稳定性分析<br>直接选择排序是不稳定的</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>堆的定义如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足下面的条件时称之为堆。<br><img src="/images/defineheap.jpg" alt="堆定义"><br>由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆)或最大项(大顶堆)。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：<br>(a）大顶堆序列：（96, 83,27,38,11,09)<br>(b) 小顶堆序列：（12，36，24，85，47，30，53，91）</p><p><img src="/images/heap3.jpg" alt="heap3"><br>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树）， 调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。<br>因此，实现堆排序需解决两个问题：</p><ul><li>如何将n 个待排序的数建成堆；</li><li>输出堆顶元素后，怎样调整剩余n-1个元素，使其成为一个新堆。</li></ul><p>首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。<br>调整小顶堆的方法：<br>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。<br>2）将根结点与左、右子树中较小元素的进行交换。<br>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.<br>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.<br>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。<br>称这个自根结点到叶子结点的调整过程为筛选。如图：<br><img src="/images/heap2.jpg" alt="heap"></p><p>再讨论对n 个元素初始建堆的过程。<br>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。<br>1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。<br>2）筛选从第个结点为根的子树开始，该子树成为堆。<br>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。<br>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）<br><img src="/images/heapsort.jpg" alt="堆排序"><br><img src="/images/heaptail.jpg" alt="detail"><br>算法的实现：<br>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[j] &lt;&lt;” “;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    已知H[s…m]除了H[s] 外均满足堆的定义</span></span><br><span class="line"><span class="comment">    调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">    @param H是待调整的堆数组</span></span><br><span class="line"><span class="comment">    @param s是待调整的数组元素的位置</span></span><br><span class="line"><span class="comment">    @param length是数组的长度</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> s, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = H[s];</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span>*s+<span class="number">1</span>; <span class="comment">//左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(child+<span class="number">1</span> &lt;length &amp;&amp; H[child]&lt;H[child+<span class="number">1</span>])&#123; <span class="comment">// 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)</span></span><br><span class="line">            ++child ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(H[s]&lt;H[child]) &#123; <span class="comment">// 如果较大的子结点大于父结点</span></span><br><span class="line">            H[s] = H[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点</span></span><br><span class="line">            s = child; <span class="comment">// 重新设置s ,即待调整的下一个结点的位置</span></span><br><span class="line">            child = <span class="number">2</span>*s+<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        H[s] = tmp; <span class="comment">// 当前待调整的结点放到比其大的孩子结点位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    print(H,length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    初始堆进行调整</span></span><br><span class="line"><span class="comment">    将H[0..length-1]建成堆</span></span><br><span class="line"><span class="comment">    调整完之后第一个元素是序列的最小的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildingHeap</span><span class="params">(<span class="keyword">int</span> H[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//最后一个有孩子的节点的位置 i= (length -1) / 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (length <span class="number">-1</span>) / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; –i)</span><br><span class="line">        HeapAdjust(H,i,length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    堆排序算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始堆</span></span><br><span class="line">    BuildingHeap(H, length);</span><br><span class="line">    <span class="comment">//从最后一个元素开始对序列进行调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; –i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交换堆顶元素H[0]和堆中最后一个元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = H[i]; </span><br><span class="line">        H[i] = H[<span class="number">0</span>];</span><br><span class="line">        H[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整</span></span><br><span class="line">        HeapAdjust(H,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;”初始值：”;</span><br><span class="line">    print(H,<span class="number">10</span>);</span><br><span class="line">    HeapSort(H,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//selectSort(a, 8);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;”结果：”;</span><br><span class="line">    print(H,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p>设树深度为k,(k=(log<sub>2</sub>n)+1)。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式：<br>2[(log<sub>2</sub>(n-1))+(log<sub>2</sub>(n-2))+……+log<sub>2</sub>2] &lt; 2nlog<sub>2</sub>n<br>而建堆时的比较次数不超过4n次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn)</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br>归并排序示例：<br><img src="/images/mergesort.jpg" alt="mergesort"> </p><h2 id="具体实现-5"><a href="#具体实现-5" class="headerlink" title="具体实现"></a>具体实现</h2><p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i+1、n-m。</p><ol><li>j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标</li><li>若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束</li><li>//选取r[i]和r[j]较小的存入辅助数组rf<br>如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵<br>否则，rf[k]=r[j]； j++； k++； 转⑵</li><li>//将尚未处理完的子表中元素存入rf<br>如果i&lt;=m,将r[i…m]存入rf[k…n] //前一子表非空<br>如果j&lt;=n,将r[j…n] 存入rf[k…n] //后一子表非空</li><li>合并结束。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]  </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> j,k;  </span><br><span class="line">     <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123;  </span><br><span class="line">         <span class="keyword">if</span>(r[j] &lt; r[i]) </span><br><span class="line">            rf[k] = r[j++];  </span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">            rf[k] = r[i++];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">while</span>(i &lt;= m)  rf[k++] = r[i++];  </span><br><span class="line">     <span class="keyword">while</span>(j &lt;= n)  rf[k++] = r[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><h3 id="归并的迭代算法"><a href="#归并的迭代算法" class="headerlink" title="归并的迭代算法"></a>归并的迭代算法</h3><p>1个元素的表总是有序的。所以对n个元素的待排序列，每个元素可看成1个有序子表。对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1外，其余子表长度均为2。再进行两两合并，直到生成n个元素按关键码有序的表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[j] &lt;&lt;<span class="string">"  "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> j,k;  </span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(r[j] &lt; r[i]) rf[k] = r[j++];  </span><br><span class="line">        <span class="keyword">else</span> rf[k] = r[i++];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m)  rf[k++] = r[i++];  </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n)  rf[k++] = r[j++];  </span><br><span class="line">    print(rf,n+<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> lenght)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;  </span><br><span class="line">    ElemType *q = r ;  </span><br><span class="line">    ElemType *tmp ;  </span><br><span class="line">    <span class="keyword">while</span>(len &lt; lenght) &#123;  </span><br><span class="line">        <span class="keyword">int</span> s = len;  </span><br><span class="line">        len = <span class="number">2</span> * s ;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span>(i+ len &lt;lenght)&#123;  </span><br><span class="line">            Merge(q, rf,  i, i+ s<span class="number">-1</span>, i+ len<span class="number">-1</span> ); <span class="comment">//对等长的两个子表合并  </span></span><br><span class="line">            i = i+ len;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i + s &lt; lenght)&#123;  </span><br><span class="line">            Merge(q, rf,  i, i+ s <span class="number">-1</span>, lenght <span class="number">-1</span>); <span class="comment">//对不等长的两个子表合并  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        tmp = q; q = rf; rf = tmp; <span class="comment">//交换q,rf，以保证下一趟归并时，仍从q 归并到rf  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;  </span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>];  </span><br><span class="line">    MergeSort(a, b, <span class="number">10</span>);  </span><br><span class="line">    print(b,<span class="number">10</span>);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"结果："</span>;  </span><br><span class="line">    print(a,<span class="number">10</span>);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="两路归并的递归算法"><a href="#两路归并的递归算法" class="headerlink" title="两路归并的递归算法"></a>两路归并的递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElemType *r, ElemType *rf,<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ElemType *rf2;  </span><br><span class="line">    <span class="keyword">if</span>(s==t)</span><br><span class="line">        r[s] = rf[s];  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">int</span> m=(s+t)/<span class="number">2</span>;          <span class="comment">//平分p表 </span></span><br><span class="line">        MSort(r, rf2, s, m);        <span class="comment">//递归地将p[s…m]归并为有序的p2[s…m]  </span></span><br><span class="line">        MSort(r, rf2, m+<span class="number">1</span>, t);      <span class="comment">//递归地将p[m+1…t]归并为有序的p2[m+1…t]  </span></span><br><span class="line">        Merge(rf2, rf, s, m+<span class="number">1</span>,t);   <span class="comment">//将p2[s…m]和p2[m+1…t]归并到p1[s…t]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort_recursive</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//对顺序表*p 作归并排序</span></span><br><span class="line">    MSort(r, rf,<span class="number">0</span>, n<span class="number">-1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分配排序"><a href="#分配排序" class="headerlink" title="分配排序"></a>分配排序</h1><p>分配排序的基本思想：排序过程无须比较关键字，而是通过”分配”和”收集”过程来实现排序.它们的时间复杂度可达到线性阶：O(n)。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>设置若干个桶，依次扫描待排序的记录R[0]，R[1]，…，R[n-1]，把关键字等于k的记录全都装入到第k个箱子里(分配)，然后按序号依次将各非空的箱子首尾连接起来(收集)。这样就可以实现不经过比较，而经过分配和收集就排序成功。</p><p>例如：要将一副混洗的 52 张扑克牌按点数 A&lt;2&lt;…&lt;J&lt;Q&lt;K 排序，需设置 13 个”箱子”，排序时依次将每张牌按点数放入相应的箱子里，然后依次将这些箱子首尾相接，就得到了按点数递增序排列的一副牌。<br>又例如要对大小为[1..1000]范围内的n个整数A[1..n]排序：</p><ul><li>首先,可以把桶设为大小为10的范围，具体而言，设集合B[1]存储<code>[1..10]</code>的整数，集合B[2]存储<code>(10..20]</code>的整数，……集合B[i]存储<code>((i-1)*10,   i*10]</code>的整数，i=1,2,..100。总共有100个桶。  </li><li>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任何排序法都可以。</li><li>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。  </li></ul><p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是<br><code>O(n+m*n/m*log(n/m))=O(n+nlogn-nlogm)</code><br>从上式看出，当m接近n的时候，桶排序复杂度接近O(n)<br>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的,实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。  </p><p>前面说的几大排序算法,大部分时间复杂度都是O(n^2),也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O(n)的时间复杂度。但桶排序的缺点是：</p><ul><li>首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</li><li>其次待排序的元素都要在一定的范围内等等。</li></ul><p>桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。桶子的类型一般设为链表为宜。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="多关键码排序实例"><a href="#多关键码排序实例" class="headerlink" title="多关键码排序实例:"></a>多关键码排序实例:</h3><p>扑克牌中52张牌，可按花色和面值分成两个字段，其大小关系为：<br>花色： 梅花&lt; 方块&lt; 红心&lt; 黑心 <img src="/images/p1.jpg" alt="p1"><br>面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A<br>若对扑克牌按花色、面值进行升序排序，得到如下序列：<br><img src="/images/p2.jpg" alt="p2"><br><img src="/images/p3.jpg" alt="p3"><br>即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。</p><p>为得到排序结果，我们讨论两种排序方法。</p><ul><li>方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。</li><li>方法2：先按13个面值给出13个编号组(2 号，3 号，…，A 号),将牌按面值依次放入对应的编号组,分成13堆。再按花色给出4个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组,再将3号组中牌取出分别放入对应花色组，……，这样，4个花色组中均按面值有序，然后，将4个花色组依次连接起来即可。</li></ul><p>设n个元素的待排序列包含d个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和r<a href="1≤i≤j≤n">j</a>都满足下列有序关系：<br>(K<sub>i</sub><sup>1</sup>,K<sub>i</sub><sup>2</sup>,……,K<sub>i</sub><sup>d</sup>) &lt; (K<sub>j</sub><sup>1</sup>,K<sub>j</sub><sup>2</sup>,……,K<sub>i</sub><sup>d</sup>)<br>其中k1 称为最主位关键码，kd称为最次位关键码。</p><h3 id="两种多关键码排序方法："><a href="#两种多关键码排序方法：" class="headerlink" title="两种多关键码排序方法："></a>两种多关键码排序方法：</h3><p>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：</p><h4 id="最高位优先-Most-Significant-Digit-first-法，简称MSD法："><a href="#最高位优先-Most-Significant-Digit-first-法，简称MSD法：" class="headerlink" title="最高位优先(Most Significant Digit first)法，简称MSD法："></a>最高位优先(Most Significant Digit first)法，简称MSD法：</h4><p>1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。<br>2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。<br>3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。</p><h4 id="最低位优先-Least-Significant-Digit-first-法，简称LSD法："><a href="#最低位优先-Least-Significant-Digit-first-法，简称LSD法：" class="headerlink" title="最低位优先(Least Significant Digit first)法，简称LSD法："></a>最低位优先(Least Significant Digit first)法，简称LSD法：</h4><p>1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。<br>2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</p><h3 id="基于LSD方法的链式基数排序的基本思想"><a href="#基于LSD方法的链式基数排序的基本思想" class="headerlink" title="基于LSD方法的链式基数排序的基本思想"></a>基于LSD方法的链式基数排序的基本思想</h3><p>“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配 -收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克 牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值 的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。   </p><p>基数排序:<br>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。<br>算法实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">RadixSort</span><span class="params">(Node L[],length,maxradix)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> m,n,k,lsp;  </span><br><span class="line">   k=<span class="number">1</span>;m=<span class="number">1</span>;  </span><br><span class="line">   <span class="keyword">int</span> temp[<span class="number">10</span>][length<span class="number">-1</span>];  </span><br><span class="line">   Empty(temp); <span class="comment">//清空临时空间  </span></span><br><span class="line">   <span class="keyword">while</span>(k&lt;maxradix) <span class="comment">//遍历所有关键字  </span></span><br><span class="line">   &#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="comment">//分配过程  </span></span><br><span class="line">     &#123;  </span><br><span class="line">        <span class="keyword">if</span>(L[i]&lt;m)  </span><br><span class="line">           Temp[<span class="number">0</span>][n]=L[i];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">           Lsp=(L[i]/m)%<span class="number">10</span>; <span class="comment">//确定关键字  </span></span><br><span class="line">        Temp[lsp][n]=L[i];  </span><br><span class="line">        n++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    CollectElement(L,Temp); <span class="comment">//收集  </span></span><br><span class="line">    n=<span class="number">0</span>;  </span><br><span class="line">    m=m*<span class="number">10</span>;  </span><br><span class="line">    k++;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各种排序的稳定性，时间复杂度和空间复杂度总结：<br><img src="/images/sum.jpg" alt="sum"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>木犀后端分享——关系型数据库</title>
      <link href="/2017/10/30/something-about-database/"/>
      <url>/2017/10/30/something-about-database/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>数据库(DataBase, DB）</code>：是存放数据的仓库，只不过这些数据存在一定的关联，并按一定的格式存放在计算机上。</p><p><code>数据库管理系统(DataBase Management System, DBMS)</code>:是管理数据库的系统，它按一定的数据模型组织数据。DBMS应提供如下功能：<br>（1）数据定义功能可定义数据库中的数据对象。<br>（2）数据操纵功能可对数据库表进行基本操作，如插入、删除、修改、查询。<br>（3）数据的完整性检查功能保证用户输入的数据应满足相应的约束条件。<br>（4）数据库的安全保护功能保证只有赋予权限的用户才能访问数据库中的数据。<br>（5）数据库的并发控制功能使多个应用程序可在同一时刻并发地访问数据库的数据。<br>（6）数据库系统的故障恢复功能使数据库运行出现故障时进行数据库恢复，以保证数据库可靠运行。<br>（7）在网络环境下访问数据库的功能。<br>（8）方便、有效地存取数据库信息的接口和工具。编程人员通过程序开发工具与数据库的接口编写数据库应用程序。<code>数据库管理员（DataBase　Adminitrator，DBA）</code>通过提供的工具对数据库进行管理。</p><p><code>数据库系统(Database System,DBS)</code>:数据、数据库、数据库管理系统与操作数据库的应用程序，加上支撑它们的硬件平台、软件平台和与数据库有关的人员一起构成了一个完整的数据库系统.</p><p><img src="/images/db.png" alt="数据库系统"></p><p>从上面的这些概念中，我们可以知道平时我们讲的SQL Server、Oracle、MySQL、DB2、SyBase等，本身并不是数据库，他们是数据库管理系统。我们通过这个数据库管理系统创建的那个可以存储表的东西才是数据库。数据库中存储这一个或多个表，表之间存在着特定的关系。一个表由行和列组成，每一列代表一个字段(Field),每一行则代表着一条具有某种特别意义的记录。</p><p><img src="/images/db2.jpg" alt="表的结构"></p><p>作为程序员，我们所要知道的就是要怎样使用数据库管理系统？怎样通过数据库管理系统去创建和删除数据库？怎样在数据库中创建和删除表，怎样在表中实现数据的增删改查？下面我就以mysql这一个关系型数据库管理系统为例来讲解这些操作。</p><h1 id="mysql客户端工具基本操作"><a href="#mysql客户端工具基本操作" class="headerlink" title="mysql客户端工具基本操作"></a>mysql客户端工具基本操作</h1><h2 id="连接并登录"><a href="#连接并登录" class="headerlink" title="连接并登录"></a>连接并登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u &lt;NAME&gt; -h &lt;HOSTNAME&gt; -P &lt;PORT&gt; -p</span><br><span class="line">$ mysql -u &lt;NAME&gt; -p</span><br><span class="line"><span class="comment">#不指明主机和端口，则默认访问本地的3306端口</span></span><br></pre></td></tr></table></figure><p>在终端中输入上述命令，接着输入密码即可连接并登录指定主机指定端口的mysql服务器。(注意密码不回显)</p><h2 id="编码的修改"><a href="#编码的修改" class="headerlink" title="编码的修改"></a>编码的修改</h2><p>在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在/etc/my.cnf或者/etc/mysql/my.cnf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set = utf8</span><br><span class="line">[mysqld]</span><br><span class="line">default-storage-engine = INNODB</span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server = utf8_general_ci</span><br></pre></td></tr></table></figure></p><p><code>重启MySQL</code>后，可以通过MySQL的客户端命令行检查编码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor...</span><br><span class="line">...</span><br><span class="line">mysql&gt; show variables like <span class="string">'%char%'</span>;</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">| Variable_name            | Value                                                  |</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">| character_set_client     | utf8                                                   |</span><br><span class="line">| character_set_connection | utf8                                                   |</span><br><span class="line">| character_set_database   | utf8                                                   |</span><br><span class="line">| character_set_filesystem | binary                                                 |</span><br><span class="line">| character_set_results    | utf8                                                   |</span><br><span class="line">| character_set_server     | utf8                                                   |</span><br><span class="line">| character_set_system     | utf8                                                   |</span><br><span class="line">| character_sets_dir       | /usr/<span class="built_in">local</span>/mysql-5.1.65-osx10.6-x86_64/share/charsets/ |</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>看到utf8字样就表示编码设置正确。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查看当前所有的数据库："><a href="#查看当前所有的数据库：" class="headerlink" title="查看当前所有的数据库："></a>查看当前所有的数据库：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure><h3 id="切换数据库："><a href="#切换数据库：" class="headerlink" title="切换数据库："></a>切换数据库：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">use</span> &lt;DB <span class="keyword">NAME</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名;</span><br></pre></td></tr></table></figure><h3 id="建立数据表："><a href="#建立数据表：" class="headerlink" title="建立数据表："></a>建立数据表：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">USE</span> 库名;</span><br><span class="line">$ <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (字段名 <span class="built_in">VARCHAR</span>(<span class="number">20</span>), 字段名 <span class="built_in">CHAR</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">DROP</span> <span class="keyword">DATABASE</span> 库名;</span><br></pre></td></tr></table></figure><h3 id="删除数据表："><a href="#删除数据表：" class="headerlink" title="删除数据表："></a>删除数据表：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="查看当前数据库的所有的表："><a href="#查看当前数据库的所有的表：" class="headerlink" title="查看当前数据库的所有的表："></a>查看当前数据库的所有的表：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><h3 id="查看某一个表的结构："><a href="#查看某一个表的结构：" class="headerlink" title="查看某一个表的结构："></a>查看某一个表的结构：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ desc &lt;Table name&gt;;</span><br></pre></td></tr></table></figure><h3 id="查看某一张表的前10条数据："><a href="#查看某一张表的前10条数据：" class="headerlink" title="查看某一张表的前10条数据："></a>查看某一张表的前10条数据：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">select</span> * <span class="keyword">from</span> &lt;<span class="keyword">Table</span> <span class="keyword">name</span>&gt; <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>基本上上面的几条命令会是大家以后在mysql客户端中使用的最多的命令了。</p><h3 id="创建和管理用户"><a href="#创建和管理用户" class="headerlink" title="创建和管理用户"></a>创建和管理用户</h3><p>mysql支持数据库的多用户管理，并且可以对每个用户的权限进行管理。下面我们来看看怎样创建用户和管理用户的权限。</p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'username'</span>@<span class="string">'host'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul><p>例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'dog'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'pig'</span>@<span class="string">'192.168.1.101_'</span> IDENDIFIED <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'pig'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'pig'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'pig'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure></p><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">GRANT</span> <span class="keyword">privileges</span> <span class="keyword">ON</span> databasename.tablename <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'host'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">CREATE</span>,<span class="keyword">DROP</span>,<span class="keyword">ALTER</span>  <span class="keyword">ON</span> 数据库名.* <span class="keyword">TO</span> 用户名@localhost <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'密码'</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*<br>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> test.user <span class="keyword">TO</span> <span class="string">'pig'</span>@<span class="string">'%'</span>;</span><br><span class="line">$ <span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'pig'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure></li></ul><p>注意：<br>用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">GRANT</span> <span class="keyword">privileges</span> <span class="keyword">ON</span> databasename.tablename <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'host'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure><h4 id="设置和更改用户密码"><a href="#设置和更改用户密码" class="headerlink" title="设置和更改用户密码"></a>设置和更改用户密码</h4><p>命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">'username'</span>@<span class="string">'host'</span> = <span class="keyword">PASSWORD</span>(<span class="string">'newpassword'</span>);</span><br><span class="line">如果是当前登陆用户用:</span><br><span class="line">$ <span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">PASSWORD</span>(<span class="string">"newpassword"</span>);</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">'pig'</span>@<span class="string">'%'</span> = <span class="keyword">PASSWORD</span>(<span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="插销用户权限"><a href="#插销用户权限" class="headerlink" title="插销用户权限"></a>插销用户权限</h4><p>命令:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">REVOKE</span> privilege <span class="keyword">ON</span> databasename.tablename <span class="keyword">FROM</span> <span class="string">'username'</span>@<span class="string">'host'</span>;</span><br></pre></td></tr></table></figure></p><p>说明:<br>privilege, databasename, tablename：同授权部分</p><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> *.* <span class="keyword">FROM</span> <span class="string">'pig'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><p>注意：<br>假如你在给用户‘pig‘@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig‘@’%’，则在使用REVOKE SELECT ON <em>.</em> FROM ‘pig‘@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON <em>.</em> TO ‘pig‘@’%’;则REVOKE SELECT ON test.user FROM ‘pig‘@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。</p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">'username'</span>@<span class="string">'host'</span>;</span><br></pre></td></tr></table></figure><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作。虽然是一门标准的语言，不幸地是，存在着很多不同版本的 SQL 语言，但是为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>语法：SELECT 列名称 FROM 表名称;<br>SELECT 语句用于从表中选取数据。结果被存储在一个结果表中（称为结果集）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LastName,FirstName <span class="keyword">FROM</span> Persons;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons;</span><br></pre></td></tr></table></figure><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>语法：SELECT DISTINCT 列名称 FROM 表名称;<br>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。<br>关键词 DISTINCT 用于返回唯一不同的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> LastName <span class="keyword">FROM</span> Persons;</span><br></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>语法：SELECT 列名称 FROM 表名称 WHERE 列 运算符 值;<br>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。<br>下面的运算符可以在where子句中使用：</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;&gt;</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">BETWEEN</td><td style="text-align:center">在某个范围内</td></tr><tr><td style="text-align:center">LIKE</td><td style="text-align:center">搜索某种模式</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> City=<span class="string">'Beijing'</span>;</span><br><span class="line">请注意，我们在例子中的条件值周围使用的是单引号。</span><br><span class="line">SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。</span><br><span class="line">这是正确的：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> FirstName=<span class="string">'Bush'</span>;</span><br><span class="line">这是错误的：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> FirstName=Bush;</span><br><span class="line">这是正确的：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> <span class="keyword">Year</span>&gt;<span class="number">1965</span>;</span><br><span class="line">这是错误的：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> <span class="keyword">Year</span>&gt;<span class="string">'1965'</span>;</span><br></pre></td></tr></table></figure><h2 id="and-amp-or"><a href="#and-amp-or" class="headerlink" title="and &amp; or"></a>and &amp; or</h2><p>语法：AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> FirstName=<span class="string">'Thomas'</span> <span class="keyword">AND</span> LastName=<span class="string">'Carter'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> firstname=<span class="string">'Thomas'</span> <span class="keyword">OR</span> lastname=<span class="string">'Carter'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> (FirstName=<span class="string">'Thomas'</span> <span class="keyword">OR</span> FirstName=<span class="string">'William'</span>) <span class="keyword">AND</span> LastName=<span class="string">'Carter'</span>;</span><br></pre></td></tr></table></figure><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>语法：ORDER BY 语句用于根据指定的列对结果集进行排序。ORDER BY 语句默认按照升序对记录进行排序。如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以字母顺序显示公司名称：</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company;</span><br><span class="line">以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company, OrderNumber;</span><br><span class="line">以逆字母顺序显示公司名称：</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span>;</span><br><span class="line">以逆字母顺序显示公司名称，并以数字顺序显示顺序号：</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span>, OrderNumber <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure></p><h2 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into"></a>insert into</h2><p>语法：INSERT INTO 表名称 VALUES (值1, 值2,….);<br>我们也可以指定所要插入数据的列：INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….);</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Persons <span class="keyword">VALUES</span> (<span class="string">'Gates'</span>, <span class="string">'Bill'</span>, <span class="string">'Xuanwumen 10'</span>, <span class="string">'Beijing'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Persons (LastName, Address) <span class="keyword">VALUES</span> (<span class="string">'Wilson'</span>, <span class="string">'Champs-Elysees'</span>);</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值;<br>Update 语句用于修改表中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Person <span class="keyword">SET</span> FirstName = <span class="string">'Fred'</span> <span class="keyword">WHERE</span> LastName = <span class="string">'Wilson'</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> Person <span class="keyword">SET</span> Address = <span class="string">'Zhongshan 23'</span>, City = <span class="string">'Nanjing'</span> <span class="keyword">WHERE</span> LastName = <span class="string">'Wilson'</span>;</span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>DELETE 语句用于删除表中的行。<br>语法：DELETE FROM 表名称 WHERE 列名称 = 值;<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> LastName = <span class="string">'Wilson'</span> ;</span><br><span class="line">可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">DELETE</span> * <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure></p><h2 id="原生SQL在python代码中的使用"><a href="#原生SQL在python代码中的使用" class="headerlink" title="原生SQL在python代码中的使用"></a>原生SQL在python代码中的使用</h2><p>要想在你的python代码中操作mysql，那么据需要使用python链接mysql的驱动程序。MysqlDB是最常用的mysql驱动，但是至今没有支持python3.下表列出了python3中链接mysql的几个驱动程序：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">安装</th><th style="text-align:center">导入</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://dev.mysql.com/doc/connector-python/en/" target="_blank" rel="noopener">MYSQL Connector</a></td><td style="text-align:center">pip install mysql-connector-python</td><td style="text-align:center">mysql.connctor</td></tr><tr><td style="text-align:center"><a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="noopener">PYMYSQL</a></td><td style="text-align:center">pip install pymysql</td><td style="text-align:center">pymysql</td></tr></tbody></table><p>下面以MySQL Connector为例讲解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment"># conn = mysql.connector.connect(user='root', password='password', database='mydb')</span></span><br><span class="line">conn = mysql.connector.connect(user=<span class="string">'root'</span>, password=<span class="string">'password'</span>,</span><br><span class="line">                               database=<span class="string">'mydb'</span>,host=<span class="string">"120.220.235.23"</span>,port=<span class="number">32777</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 创建user表:</span></span><br><span class="line">cursor.execute(<span class="string">'create table user (id varchar(20) primary key, name varchar(20))'</span>)</span><br><span class="line"><span class="comment"># 插入一行记录，注意MySQL的占位符是%s:</span></span><br><span class="line">cursor.execute(<span class="string">'insert into user (id, name) values (%s, %s)'</span>, [<span class="string">'1'</span>, <span class="string">'Michael'</span>])</span><br><span class="line">print(cursor.rowcount)</span><br><span class="line"><span class="comment"># 输出　1</span></span><br><span class="line"><span class="comment"># 提交事务:</span></span><br><span class="line">conn.commit()</span><br><span class="line">cursor.close()</span><br><span class="line"><span class="comment"># 运行查询:</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(<span class="string">'select * from user where id = %s'</span>, (<span class="string">'1'</span>,))</span><br><span class="line">values = cursor.fetchall()</span><br><span class="line"><span class="comment"># 输出：[('1', 'Michael')]</span></span><br><span class="line"><span class="comment"># 关闭Cursor和Connection:</span></span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></p><h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><p>SQLAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简言之便是：将对象转换成SQL，然后使用数据库API执行SQL并获取执行结果。这是分了三层，上层和下面两层。ORM是用类来封装的，SQLALCHEMY Core 是用函数封装的，是核心层，不是执行数据库语句，是把写成的类，翻译成sql语句。DBAPI执行SQL从而获取执行结果或将数据持久化进磁盘。</p><p><img src="/images/orm.jpeg" alt="ORM"></p><p>SQLAlchemy本身无法操作数据库，其必须依赖pymysql，mysql-connector等第三方插件.Dialect用于和数据库API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作。SQLAlchemy为我们屏蔽了SQL语句的繁琐，统一了各种不同数据库的操作，极大的方便了数据库应用的开发。</p><h2 id="SQLAlchemy的基本使用"><a href="#SQLAlchemy的基本使用" class="headerlink" title="SQLAlchemy的基本使用"></a>SQLAlchemy的基本使用</h2><h3 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h3><p><code>dialect+driver://user:password@host:port/dbname</code><br>不同数据库和驱动条件下的连接配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MySQL-Python</span><br><span class="line">    mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;</span><br><span class="line">pymysql</span><br><span class="line">    mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]</span><br><span class="line">MySQL-Connector</span><br><span class="line">    mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;</span><br><span class="line">cx_Oracle</span><br><span class="line">    oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...]</span><br></pre></td></tr></table></figure></p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String</span><br><span class="line"><span class="comment"># 创建实例，并连接test库，echo=True 显示SQL语句</span></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>,</span><br><span class="line">                                    encoding=<span class="string">'utf-8'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#create_engine方法返回一个Engine实例，Engine实例只有直到触发数据库事件时才真正去连接数据库。#echo=True是回显命令，sqlalchemy与数据库通信的命令都将打印出来</span></span><br><span class="line">Base = declarative_base()  <span class="comment"># 生成orm基类</span></span><br><span class="line"><span class="comment">#declarative_base类维持了一个从类到表的关系，通常一个应用使用一个base实例，</span></span><br><span class="line"><span class="comment">#所有实体类都应该继承此类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'users'</span>  <span class="comment"># 表名</span></span><br><span class="line">    __table_args__ = &#123;<span class="string">"mysql_charset"</span>: <span class="string">"utf8"</span>&#125;</span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>)<span class="comment">#主键，自增id</span></span><br><span class="line">    name = Column(String(<span class="number">32</span>))</span><br><span class="line">    password = Column(String(<span class="number">64</span>))</span><br><span class="line">Base.metadata.create_all(engine) <span class="comment">#创建表结构 （这里是父类调子类）</span></span><br><span class="line"><span class="comment">#Base.metadata返回sqlalchemy.schema.MetaData对象，它是所有Table对象的集合，</span></span><br><span class="line"><span class="comment">#调用create_all()该对象会触发CREATE TABLE语句，如果数据库还不存在这些表的话。</span></span><br></pre></td></tr></table></figure><p>除了上面的创建方法之外，还有一种创建方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, MetaData, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> mapper</span><br><span class="line">metadata = MetaData()</span><br><span class="line">user = Table(<span class="string">'user'</span>, metadata,</span><br><span class="line">            Column(<span class="string">'id'</span>, Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>),</span><br><span class="line">            Column(<span class="string">'name'</span>, String(<span class="number">50</span>)),</span><br><span class="line">            Column(<span class="string">'fullname'</span>, String(<span class="number">50</span>)),</span><br><span class="line">            Column(<span class="string">'password'</span>, String(<span class="number">12</span>))</span><br><span class="line">        )</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, fullname, password)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.fullname = fullname</span><br><span class="line">        self.password = password</span><br><span class="line">mapper(User, user)  <span class="comment"># 类User 和 user关联起来</span></span><br><span class="line"><span class="comment"># the table metadata is created separately with the Table construct, </span></span><br><span class="line"><span class="comment"># then associated with the User class via the mapper() function</span></span><br><span class="line"><span class="comment"># 如果数据库里有，就不会创建了。</span></span><br></pre></td></tr></table></figure></p><p>在使用的时候建议使用第一种创建方式。</p><h3 id="Column构造函数常用参数"><a href="#Column构造函数常用参数" class="headerlink" title="Column构造函数常用参数"></a>Column构造函数常用参数</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th><th style="text-align:center">可选值</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">autoincrement</td><td style="text-align:center">是否自增</td><td style="text-align:center">Ture,False</td><td style="text-align:center">False</td></tr><tr><td style="text-align:center">primary_key</td><td style="text-align:center">主键</td><td style="text-align:center">Ture,False</td><td style="text-align:center">False</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">指定默认值</td><td style="text-align:center">自定义值</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">index</td><td style="text-align:center">是否建索引</td><td style="text-align:center">True,False</td><td style="text-align:center">False</td></tr><tr><td style="text-align:center">nullable</td><td style="text-align:center">字段可否可空</td><td style="text-align:center">Ture,False</td><td style="text-align:center">False</td></tr></tbody></table><h3 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, MetaData, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> mapper, sessionmaker</span><br><span class="line"><span class="comment"># 创建实例，并连接test库</span></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>,</span><br><span class="line">                                    encoding=<span class="string">'utf-8'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line">metadata = MetaData()</span><br><span class="line">user = Table(<span class="string">'user'</span>, metadata,</span><br><span class="line">            Column(<span class="string">'id'</span>, Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>),</span><br><span class="line">            Column(<span class="string">'name'</span>, String(<span class="number">50</span>)),</span><br><span class="line">            Column(<span class="string">'password'</span>, String(<span class="number">12</span>))</span><br><span class="line">        )</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name,  password)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.password = password</span><br><span class="line"><span class="comment"># the table metadata is created separately with the Table construct, then associated with the User class via the mapper() function</span></span><br><span class="line">mapper(User, user)</span><br><span class="line"><span class="comment"># 创建与数据库的会话session class ,注意,这里返回给session的是个class,不是实例.</span></span><br><span class="line">Session_class = sessionmaker(bind=engine)  <span class="comment"># 实例和engine绑定</span></span><br><span class="line">Session = Session_class()  <span class="comment"># 生成session实例，相当于游标</span></span><br><span class="line"><span class="comment">#Session是真正与数据库通信的handler，你还可以把他理解一个容器，add就是往容器中添加对象</span></span><br><span class="line">user_obj = User(name=<span class="string">"fgf"</span>,password=<span class="string">"123456"</span>)  <span class="comment"># 生成你要创建的数据对象</span></span><br><span class="line">print(user_obj.name,user_obj.id)  <span class="comment"># 此时还没创建对象呢，不信你打印一下id发现还是None</span></span><br><span class="line">Session.add(user_obj)  <span class="comment"># 把要创建的数据对象添加到这个session里， 一会统一创建</span></span><br><span class="line"><span class="comment"># Session.add_all([user1,user2,use3]) #add_all()添加多个对象，效率高</span></span><br><span class="line">print(user_obj.name,user_obj.id) <span class="comment">#此时也依然还没创建，id仍然为None</span></span><br><span class="line">Session.commit() <span class="comment">#现此才统一提交，创建数据</span></span><br></pre></td></tr></table></figure><h3 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h3><p>对象实例有四种状态，分别是：</p><ul><li>Transient（瞬时的)：这个状态的对象还不在session中，也不会保存到数据库中，主键为None（不是绝对的，如果Persistent对象rollback后虽然主键id有值，但还是Transient状态的）。</li><li>Pending（挂起的）：调用session.add()后，Transient对象就会变成Pending，这个时候它还是不会保存到数据库中，只有等到触发了flush动作才会存在数据库，比如query操作就可以出发flush。同样这个时候的实例的主键一样为None</li><li>Persistent（持久的）：session中，数据库中都有对应的一条记录存在，主键有值了。</li><li>Detached（游离的）：数据库中有记录，但是session中不存在，对这个状态的对象进行操作时，不会触发任何SQL语句。</li></ul><h3 id="Session对象缓存清理"><a href="#Session对象缓存清理" class="headerlink" title="Session对象缓存清理"></a>Session对象缓存清理</h3><p>Session对象在commit()方法调用时,在执行查询时和显式调用session的flush方法时清理缓存，从而保证查询结果能反映对象的最新状态。</p><p>Session是真正与数据库通信的handler，你还可以把他理解一个容器，add就是往容器中添加对象<br>执行完add方法后，ed_user对象处于pending状态，不会触发INSERT语句，当然ed_uesr.id也为None，如果在add方后有查询(session.query)，那么会flush一下，把数据刷一遍，把所有的pending信息先flush再执行query。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_user = Session.query(User).filter_by(name=<span class="string">"fgf"</span>).first()  <span class="comment"># 查询</span></span><br><span class="line">print(my_user) <span class="comment">#输出 &lt;__main__.User object at 0x7f0a5a3dea20&gt;</span></span><br><span class="line">print(my_user.id,my_user.name,my_user.password)</span><br><span class="line"><span class="comment"># 输出 1 fgf 123456</span></span><br></pre></td></tr></table></figure><p>不过刚才显示的内存对象对址没办法分清返回的是什么数据的，除非打印具体字段看一下，如果想让它变的可读，只需在定义表的类下面加上这样的代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;User(name='%s',  password='%s')&gt;"</span> % ( self.name, self.password)</span><br></pre></td></tr></table></figure></p><p>完整的查询代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, MetaData, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> mapper, sessionmaker</span><br><span class="line"><span class="comment"># 创建实例，并连接test库</span></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>,</span><br><span class="line">                                    encoding=<span class="string">'utf-8'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line">metadata = MetaData()</span><br><span class="line">user = Table(<span class="string">'user'</span>, metadata,</span><br><span class="line">            Column(<span class="string">'id'</span>, Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>),</span><br><span class="line">            Column(<span class="string">'name'</span>, String(<span class="number">50</span>)),</span><br><span class="line">            Column(<span class="string">'password'</span>, String(<span class="number">12</span>))</span><br><span class="line">        )</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, id, password)</span>:</span></span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line">        self.password = password</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User(name='%s',  password='%s')&gt;"</span> % (self.name, self.password)</span><br><span class="line">mapper(User, user)</span><br><span class="line"><span class="comment"># 创建与数据库的会话session class ,注意,这里返回给session的是个class,不是实例</span></span><br><span class="line">Session_class = sessionmaker(bind=engine)</span><br><span class="line">Session = Session_class()  <span class="comment"># 生成session实例</span></span><br><span class="line">my_user = Session.query(User).filter_by(name=<span class="string">"fgf"</span>).first()  <span class="comment"># 查询第一个</span></span><br><span class="line"><span class="comment"># my_user = Session.query(User).filter_by().all()  # 查询所有</span></span><br><span class="line">print(my_user)</span><br><span class="line"><span class="comment"># print(my_user.id,my_user.name,my_user.password)</span></span><br><span class="line"><span class="comment"># Session.commit()  #查询不需要commit</span></span><br></pre></td></tr></table></figure></p><h3 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h3><p>filter_by与filter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_user1 = Session.query(User).filter(User.id&gt;<span class="number">2</span>).all()</span><br><span class="line">my_user2 = Session.query(User).filter_by(id=<span class="number">27</span>).all()  <span class="comment"># filter_by相等用‘=’</span></span><br><span class="line">my_user3 = Session.query(User).filter(User.id==<span class="number">27</span>).all()  <span class="comment"># filter相等用‘==’</span></span><br><span class="line">objs = Session.query(User).filter(User.id&gt;<span class="number">0</span>).filter(User.id&lt;<span class="number">7</span>).all()</span><br><span class="line">print(my_user1,<span class="string">'\n'</span>,my_user2,<span class="string">'\n'</span>,my_user3,<span class="string">'\n'</span>,objs)</span><br></pre></td></tr></table></figure><p>建立在SQLAlchemy上的几种常见的SQL查询实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">几种常见sqlalchemy查询：</span><br><span class="line"><span class="comment">#简单查询    </span></span><br><span class="line">print(session.query(User).all())</span><br><span class="line">print(session.query(User.name, User.fullname).all())    </span><br><span class="line">print(session.query(User, User.name).all())        </span><br><span class="line"><span class="comment">#带条件查询    </span></span><br><span class="line">print(session.query(User).filter_by(name=<span class="string">'user1'</span>).all())    </span><br><span class="line">print(session.query(User).filter(User.name == <span class="string">"user"</span>).all())    </span><br><span class="line">print(session.query(User).filter(User.name.like(<span class="string">"user%"</span>)).all())      </span><br><span class="line"><span class="comment">#多条件查询  </span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_,or_  </span><br><span class="line">print(session.query(User).filter(and_(User.name.like(<span class="string">"user%"</span>), User.fullname.like(<span class="string">"first%"</span>))).all())    </span><br><span class="line">print(session.query(User).filter(or_(User.name.like(<span class="string">"user%"</span>), User.password != <span class="keyword">None</span>)).all())        </span><br><span class="line"><span class="comment">#sql过滤    </span></span><br><span class="line">print(session.query(User).filter(<span class="string">"id&gt;:id"</span>).params(id=<span class="number">1</span>).all())        </span><br><span class="line"><span class="comment">#关联查询     </span></span><br><span class="line">print(session.query(User, Address).filter(User.id == Address.user_id).all())    </span><br><span class="line">print(session.query(User).join(User.addresses).all())    </span><br><span class="line">print(session.query(User).outerjoin(User.addresses).all())        </span><br><span class="line"><span class="comment">#聚合查询    </span></span><br><span class="line">print(session.query(User.name, func.count(<span class="string">'*'</span>).label(<span class="string">"user_count"</span>)).group_by(User.name).all())    </span><br><span class="line">print(session.query(User.name, func.sum(User.id).label(<span class="string">"user_id_sum"</span>)).group_by(User.name).all())        </span><br><span class="line"><span class="comment">#子查询    </span></span><br><span class="line">stmt = session.query(Address.user_id, func.count(<span class="string">'*'</span>).label(<span class="string">"address_count"</span>)).group_by(Address.user_id).subquery()    </span><br><span class="line">print(session.query(User, stmt.c.address_count).outerjoin((stmt, User.id == stmt.c.user_id)).order_by(User.id).all())     </span><br><span class="line">   </span><br><span class="line"><span class="comment">#exists    </span></span><br><span class="line">print(session.query(User).filter(exists().where(Address.user_id == User.id)))    </span><br><span class="line">print(session.query(User).filter(User.addresses.any()))</span><br><span class="line">限制返回字段查询</span><br><span class="line">person = session.query(Person.name, Person.created_at,Person.updated_at).filter_by(name=<span class="string">"zhongwei"</span>).order_by(Person.created_at).first()</span><br><span class="line">记录总数查询：</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"><span class="comment"># count User records, without</span></span><br><span class="line"><span class="comment"># using a subquery.</span></span><br><span class="line">session.query(func.count(User.id))</span><br><span class="line"><span class="comment"># return count of user "id" grouped</span></span><br><span class="line"><span class="comment"># by "name"</span></span><br><span class="line">session.query(func.count(User.id)).\</span><br><span class="line">        group_by(User.name)</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> distinct</span><br><span class="line"><span class="comment"># count distinct "name" values</span></span><br><span class="line">session.query(func.count(distinct(User.name)))</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_user = Session.query(User).filter_by(name=<span class="string">"fgf"</span>).first()</span><br><span class="line">my_user.name = <span class="string">"fenggf"</span>  <span class="comment"># 查询出来之后直接赋值修改</span></span><br><span class="line">my_user.passwork = <span class="string">"123qwe"</span></span><br><span class="line">Session.commit() <span class="comment">#注意提交</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query = Session.query(User).filter_by(name=<span class="string">"hhh"</span>).delete()</span><br><span class="line">Session.commit()</span><br></pre></td></tr></table></figure><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_user = Session.query(User).filter_by(id=<span class="number">1</span>).first()</span><br><span class="line">my_user.name = <span class="string">"Jack"</span></span><br><span class="line">fake_user = User(name=<span class="string">'Rain'</span>, password=<span class="string">'12345'</span>)</span><br><span class="line">Session.add(fake_user)</span><br><span class="line">print(Session.query(User).filter(User.name.in_([<span class="string">'Jack'</span>,<span class="string">'rain'</span>])).all() )  <span class="comment">#这时看session里有你刚添加和修改的数据</span></span><br><span class="line">Session.rollback() <span class="comment">#此时你rollback一下</span></span><br><span class="line">print(Session.query(User).filter(User.name.in_([<span class="string">'Jack'</span>,<span class="string">'rain'</span>])).all() ) <span class="comment">#再查就发现刚才添加的数据没有了。</span></span><br><span class="line"><span class="comment"># Session</span></span><br><span class="line"><span class="comment"># Session.commit()</span></span><br></pre></td></tr></table></figure><h3 id="表与表之间的关系"><a href="#表与表之间的关系" class="headerlink" title="表与表之间的关系"></a>表与表之间的关系</h3><p>SQLAlchemy中的映射关系有四种,分别是一对一,一对多,多对一,多对多。</p><h3 id="一对多和多对一"><a href="#一对多和多对一" class="headerlink" title="一对多和多对一"></a>一对多和多对一</h3><p>因为外键(ForeignKey)始终定义在多的一方.如果relationship定义在多的一方,那就是多对一,一对多与多对一的区别在于其关联(relationship)的属性在多的一方还是一的一方，如果relationship定义在一的一方那就是一对多.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Enum,DATE,Integer, String,ForeignKey</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker,relationship</span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>,</span><br><span class="line">                                    encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">Base = declarative_base()  <span class="comment"># 生成orm基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu2</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"stu2"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">32</span>),nullable=<span class="keyword">False</span>)</span><br><span class="line">    register_date = Column(DATE,nullable=<span class="keyword">False</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;%s name:%s&gt;"</span> % (self.id, self.name)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyRecord</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"study_record"</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>)</span><br><span class="line">    day = Column(Integer,nullable=<span class="keyword">False</span>)</span><br><span class="line">    status = Column(String(<span class="number">32</span>),nullable=<span class="keyword">False</span>)</span><br><span class="line">    stu_id = Column(Integer,ForeignKey(<span class="string">"stu2.id"</span>))  <span class="comment">#------外键关联------</span></span><br><span class="line">    <span class="comment">#这个nb，允许你在user表里通过backref字段反向查出所有它在stu2表里的关联项数据</span></span><br><span class="line">    stu2 = relationship(<span class="string">"Stu2"</span>, backref=<span class="string">"my_study_record"</span>)  <span class="comment"># 添加关系，反查（在内存里）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;%s day:%s status:%s&gt;"</span> % (self.stu2.name, self.day,self.status)</span><br><span class="line">Base.metadata.create_all(engine)  <span class="comment"># 创建表结构</span></span><br><span class="line">Session_class = sessionmaker(bind=engine)  <span class="comment"># 创建与数据库的会话session class ,注意,这里返回给session的是个class,不是实例</span></span><br><span class="line">session = Session_class()  <span class="comment"># 生成session实例 #cursor</span></span><br><span class="line">s1 = Stu2(name=<span class="string">"A"</span>,register_date=<span class="string">"2014-05-21"</span>)</span><br><span class="line">s2 = Stu2(name=<span class="string">"J"</span>,register_date=<span class="string">"2014-03-21"</span>)</span><br><span class="line">s3 = Stu2(name=<span class="string">"R"</span>,register_date=<span class="string">"2014-02-21"</span>)</span><br><span class="line">s4 = Stu2(name=<span class="string">"E"</span>,register_date=<span class="string">"2013-01-21"</span>)</span><br><span class="line">study_obj1 = StudyRecord(day=<span class="number">1</span>,status=<span class="string">"YES"</span>, stu_id=<span class="number">1</span>)</span><br><span class="line">study_obj2 = StudyRecord(day=<span class="number">2</span>,status=<span class="string">"NO"</span>, stu_id=<span class="number">1</span>)</span><br><span class="line">study_obj3 = StudyRecord(day=<span class="number">3</span>,status=<span class="string">"YES"</span>, stu_id=<span class="number">1</span>)</span><br><span class="line">study_obj4 = StudyRecord(day=<span class="number">1</span>,status=<span class="string">"YES"</span>, stu_id=<span class="number">2</span>)</span><br><span class="line">session.add_all([s1,s2,s3,s4,study_obj1,study_obj2,study_obj3,study_obj4])  <span class="comment"># 创建</span></span><br><span class="line">session.commit()</span><br><span class="line">stu_obj = session.query(Stu2).filter(Stu2.name==<span class="string">"a"</span>).first()  <span class="comment"># 查询</span></span><br><span class="line"><span class="comment"># 在stu2表，查到StudyRecord表的记录</span></span><br><span class="line">print(stu_obj.my_study_record)  <span class="comment"># 查询A一共上了几节课</span></span><br></pre></td></tr></table></figure><h3 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h3><p>多对多关系需要一个中间关联表,通过参数secondary来指定,这个中间关联表只需要创建即可，不需要操作它，SQLAlchemy自己会管理这张表。<br><img src="/images/m2m.jpg" alt="多对多"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">post_keywords = Table(<span class="string">'student_class'</span>,Base.metadata,</span><br><span class="line">        Column(<span class="string">'student_id'</span>,Integer,ForeignKey(<span class="string">'students.id'</span>)),</span><br><span class="line">        Column(<span class="string">'class_id'</span>,Integer,ForeignKey(<span class="string">'classes.id'</span>))</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'students'</span></span><br><span class="line">    id = Column(Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    keywords = relationship(<span class="string">'Class'</span>,secondary=student_class,backref=<span class="string">'students'</span>)</span><br><span class="line">    <span class="comment"># keywords = relationship('Class',secondary=student_class,backref=backref('students,lazy="dynamic"),lazy="dynamic")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'classes'</span></span><br><span class="line">    id = Column(Integer,primary_key = <span class="keyword">True</span>)</span><br><span class="line">    classname = Column(String(<span class="number">50</span>),nullable=<span class="keyword">False</span>,unique=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Integer, ForeignKey, String, Column</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> relationship</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">Base = declarative_base()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'customer'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">64</span>))</span><br><span class="line">    <span class="comment"># 账单地址和邮寄地址, 都关联同一个地址表</span></span><br><span class="line">    billing_address_id = Column(Integer, ForeignKey(<span class="string">"address.id"</span>))</span><br><span class="line">    shipping_address_id = Column(Integer, ForeignKey(<span class="string">"address.id"</span>))</span><br><span class="line">    billing_address = relationship(<span class="string">"Address"</span>, foreign_keys=[billing_address_id])</span><br><span class="line">    shipping_address = relationship(<span class="string">"Address"</span>, foreign_keys=[shipping_address_id])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'address'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>,autoincrement=<span class="keyword">True</span>)</span><br><span class="line">    street = Column(String(<span class="number">64</span>))</span><br><span class="line">    city = Column(String(<span class="number">64</span>))</span><br><span class="line">    state = Column(String(<span class="number">64</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.street</span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>,</span><br><span class="line">                                    encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">Base.metadata.create_all(engine)  <span class="comment"># 创建表结构</span></span><br></pre></td></tr></table></figure><h2 id="Flask-SQLAlchemy的使用"><a href="#Flask-SQLAlchemy的使用" class="headerlink" title="Flask-SQLAlchemy的使用"></a>Flask-SQLAlchemy的使用</h2><p>Flask-SQLAlchemy 在 SQLAlchemy 的基础上，提供了一些常用的工具，并预设了一些默认值，帮助你更轻松地完成常见任务。flask-sqlalchemy 用起来比直接用 sqlalchemy 方便、省事，不过有些高级一点的功能如果不了解 sqlalchemy 的话会用不好。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">"SQLALCHEMY_DATABASE_URI"</span>]=<span class="string">"mysql+pymysql://root:pqc19960320@120.77.220.239:32777/mydb"</span></span><br><span class="line">app.config[<span class="string">"SQLALCHEMY_TRACK_MODIFICATIONS"</span>]=<span class="keyword">True</span></span><br><span class="line">db=SQLAlchemy(app)</span><br></pre></td></tr></table></figure><p>db对象是SQLAlchemy类的实例，表示程序使用的数据库，同时还获得了Flask-SQLAlchemy提供的所有功能。</p><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__=<span class="string">"roles"</span></span><br><span class="line">    id=db.Column(db.Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name=db.Column(db.String(<span class="number">30</span>),unique=<span class="keyword">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;Role %s&gt;"</span> % self.name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__=<span class="string">"users"</span></span><br><span class="line">    id=db.Column(db.Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    username=db.Column(db.String(<span class="number">64</span>),unique=<span class="keyword">True</span>,index=<span class="keyword">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User %s&gt;"</span> % self.username</span><br></pre></td></tr></table></figure><p><strong>tablename</strong>定义在数据库中使用的表名，如果没有定义<strong>tablename</strong>,Flask-SQLAlchemy会使用一个默认的名字，但是默认的表名没有遵循复数形式进行命名的约定。</p><p>常使用的列类型</p><table><thead><tr><th style="text-align:center">类型名称</th><th style="text-align:center">python类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Integer</td><td style="text-align:center">int</td><td style="text-align:center">常规整形，通常为32位</td></tr><tr><td style="text-align:center">SmallInteger</td><td style="text-align:center">int</td><td style="text-align:center">短整形，通常为16位</td></tr><tr><td style="text-align:center">BigInteger</td><td style="text-align:center">int或long</td><td style="text-align:center">精度不受限整形</td></tr><tr><td style="text-align:center">Float</td><td style="text-align:center">float</td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center">Numeric</td><td style="text-align:center">decimal.Decimal</td><td style="text-align:center">定点数</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">str</td><td style="text-align:center">可变长度字符串</td></tr><tr><td style="text-align:center">Text</td><td style="text-align:center">str</td><td style="text-align:center">可变长度字符串，适合大量文本</td></tr><tr><td style="text-align:center">Unicode</td><td style="text-align:center">unicode</td><td style="text-align:center">可变长度Unicode字符串</td></tr><tr><td style="text-align:center">UnicodeText</td><td style="text-align:center">unicode</td><td style="text-align:center">可变长度Unicode字符串,对较长或不限长度的字符串做了优化</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">bool</td><td style="text-align:center">布尔型</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">datetime.date</td><td style="text-align:center">日期类型</td></tr><tr><td style="text-align:center">Time</td><td style="text-align:center">datetime.time</td><td style="text-align:center">时间类型</td></tr><tr><td style="text-align:center">DataTime</td><td style="text-align:center">datetime.datatime</td><td style="text-align:center">日期和时间</td></tr><tr><td style="text-align:center">Interval</td><td style="text-align:center">datetime.timedelta</td><td style="text-align:center">时间间隔</td></tr><tr><td style="text-align:center">Enum</td><td style="text-align:center">str</td><td style="text-align:center">字符列表</td></tr><tr><td style="text-align:center">PickleType</td><td style="text-align:center">任意Python对象</td><td style="text-align:center">自动Pickle序列化</td></tr><tr><td style="text-align:center">LargeBinary</td><td style="text-align:center">str</td><td style="text-align:center">二进制</td></tr></tbody></table><p>常使用的列选项</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th><th style="text-align:center">可选值</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">primary_key</td><td style="text-align:center">主键</td><td style="text-align:center">True,False</td><td style="text-align:center">False</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">指定默认值</td><td style="text-align:center">自定义值</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">index</td><td style="text-align:center">是否建索引</td><td style="text-align:center">True,False</td><td style="text-align:center">False</td></tr><tr><td style="text-align:center">nullable</td><td style="text-align:center">字段可否可空</td><td style="text-align:center">True,False</td><td style="text-align:center">False</td></tr><tr><td style="text-align:center">unique</td><td style="text-align:center">是否允许出现重复值</td><td style="text-align:center">True,False</td><td style="text-align:center">False</td></tr></tbody></table><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="一对多和多对一-1"><a href="#一对多和多对一-1" class="headerlink" title="一对多和多对一"></a>一对多和多对一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__=<span class="string">"roles"</span></span><br><span class="line">    id=db.Column(db.Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name=db.Column(db.String(<span class="number">30</span>),unique=<span class="keyword">True</span>)</span><br><span class="line">    users=db.relationship(<span class="string">"User"</span>,backref=<span class="string">"role"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;Role %s&gt;"</span> % self.name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__=<span class="string">"users"</span></span><br><span class="line">    id=db.Column(db.Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    username=db.Column(db.String(<span class="number">64</span>),unique=<span class="keyword">True</span>,index=<span class="keyword">True</span>)</span><br><span class="line">    role_id=(db.Integer,db.ForeignKey(<span class="string">"roles.id"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User %s&gt;"</span> % self.username</span><br></pre></td></tr></table></figure><p>两张表之间的关系事实上是由ForeignKey建立起来的，relationship在两张表之间建立了一个虚拟关系，帮助我们更方便的操作这种关系。注意：在一对多或多对一的关系中，ForeignKey只会出现在多的一方，并且它所关联的一定是另一张表的primary_key。 relationship的一个必须参数是要建立虚拟关系的表所对应类的名字，如果这个类还没有定义，可以用一个字符串代替，它的其他更多可选参数见下图：</p><p><img src="/images/rela.png" alt="关系选项"></p><p><a href="http://blog.csdn.net/bestallen/article/details/52551579" target="_blank" rel="noopener">lazy选项</a></p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建表</span></span><br><span class="line">db.create_all()</span><br><span class="line"><span class="comment">#删除表</span></span><br><span class="line">db.drop_all()</span><br></pre></td></tr></table></figure><h5 id="插入行"><a href="#插入行" class="headerlink" title="插入行"></a>插入行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Role,User</span><br><span class="line">admin_role=Role(name=<span class="string">"Admin"</span>)</span><br><span class="line">mod_role=Role(name=<span class="string">"Moderator"</span>)</span><br><span class="line">user_role=Role(name=<span class="string">"User"</span>)</span><br><span class="line">john=User(usename=<span class="string">"John"</span>,role=admin_role)</span><br><span class="line">susan=User(username=<span class="string">"Susan"</span>,role=mod_role)</span><br><span class="line">david=User(username=<span class="string">"David"</span>,role=user_role)</span><br></pre></td></tr></table></figure><p>注意这里创建Role和User实例时，都没有传id属性，这是因为primary_key是由Flask-SQLAlchemy管理的。relationship建立的虚拟字段role和users也是可以使用的,虽然他们不是真正的数据库列，但却是一对多关系的高级表示。此时这些对象的状态是暂时的，并没有写入数据库中，此时打印对象的id值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(admin_role.id)   <span class="comment">#-&gt;None</span></span><br><span class="line">print(john.id)   <span class="comment">#-&gt;None</span></span><br></pre></td></tr></table></figure></p><p>添加如会话：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.session.add(admin_role)</span><br><span class="line">db.session.add(mod_role)</span><br><span class="line">db.session.add(user_role)</span><br><span class="line">db.session.add(john)</span><br><span class="line">db.session.add(susan)</span><br><span class="line">db.session.add(david)</span><br><span class="line"><span class="comment">#或者一次性添加</span></span><br><span class="line">db.session.add_all([admin_role,mod_role,user_role,john,susan,davia])</span><br><span class="line"><span class="comment">#此时这些数据对象的状态变成挂起的了，依然没有写入到数据库中，我们打印对象的id，依然是None</span></span><br><span class="line">print(admin_role.id) <span class="comment">#-&gt;None</span></span><br><span class="line"><span class="comment">#直到我们commit()之后，这些数据对象才持久化到数据库中</span></span><br><span class="line">db.commit()</span><br><span class="line">print(admin_role.id) <span class="comment">#-&gt;1</span></span><br></pre></td></tr></table></figure></p><h5 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin_role.name=<span class="string">"Administrator"</span></span><br><span class="line">db.session.add(admin_role)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h5 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.session.delete(mod_role)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h5 id="查询行"><a href="#查询行" class="headerlink" title="查询行"></a>查询行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Role.query.all()</span><br><span class="line">[&lt;Role <span class="string">"Administrator"</span>&gt;,&lt;Role <span class="string">"User"</span>&gt;]</span><br></pre></td></tr></table></figure><p>Flask-SQLAlchemy为每个模型都提供了一个query对象，模型名.query就可以拿到这个query对象，在query对象的后面可以加查询过滤器，查询过滤器返回的仍然是query对象，这意味着我们还可以继续在后面追加查询过滤器，从而精确的筛选出我们需要的数据。query对象建立好之后，Flask-SQLAlchemy并没有执行SQL查询，要想真正的得到数据，我们还必须要在query对象的后面执行查询执行函数。下面是常用的查询过滤器和查询执行函数：</p><table><thead><tr><th style="text-align:center">过滤器</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">filter()</td><td style="text-align:center">把过滤器添加到原查询上，返回一个新查询</td></tr><tr><td style="text-align:center">filter_by()</td><td style="text-align:center">把等值过滤器添加到原查询上，返回一个新查询</td></tr><tr><td style="text-align:center">limit()</td><td style="text-align:center">使用指定的值限制原查询返回的结果数量，返回一个新查询</td></tr><tr><td style="text-align:center">offset()</td><td style="text-align:center">偏移原查询返回的结果，返回一个新查询</td></tr><tr><td style="text-align:center">order_by()</td><td style="text-align:center">根据指定条件对原查询结果进行排序，返回一个新查询</td></tr><tr><td style="text-align:center">group_by()</td><td style="text-align:center">根据指定条件对原查询结果进行分组，返回一个新查询</td></tr></tbody></table><table><thead><tr><th style="text-align:center">查询执行方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">all()</td><td style="text-align:center">以列表形式返回查询的所有结果</td></tr><tr><td style="text-align:center">first()</td><td style="text-align:center">返回查询的第一个结果，如果没有结果，则返回None</td></tr><tr><td style="text-align:center">first_or_404()</td><td style="text-align:center">返回查询的第一个结果，如果没有结果，则终止请求，返回404错误响应</td></tr><tr><td style="text-align:center">get()</td><td style="text-align:center">返回指定主键对应的行，如果没有对应的行，则返回None</td></tr><tr><td style="text-align:center">get_or_404</td><td style="text-align:center">返回指定主键对应的行，如果没有找到指定的主键，则终止请求，返回404错误响应</td></tr><tr><td style="text-align:center">count()</td><td style="text-align:center">返回查询结果的数量</td></tr><tr><td style="text-align:center">paginate()</td><td style="text-align:center">返回一个Paginate对象，它包含指定范围内的结果</td></tr></tbody></table><p>下面我们看看relationship建立的虚拟字段role,users<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(admin_role.users)</span><br><span class="line"><span class="comment">#输出：[&lt;User John&gt;]</span></span><br></pre></td></tr></table></figure></p><p>这里有一个小问题，我们用users虚拟字段的时候，默认我们就得到了当前角色的所有用户的列表，也就是得到了查询执行函数执行之后的结果，但是如果我们想要做更加精细的筛选呢？</p><p>事实上，我们更期待它返回的是一个query对象，而不是结果列表。这是可以做得到的。</p><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><p><img src="/images/m2m2.png" alt="多对多"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">registrations=db.Table(<span class="string">"registrations"</span>,</span><br><span class="line">    db.Column(<span class="string">"student_id"</span>,db.Integer,db.ForeignKey(<span class="string">"students.id"</span>)),</span><br><span class="line">    db.Column(<span class="string">"class_id"</span>,db.Integer,db.ForeignKey(<span class="string">"classes.id"</span>))</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id=db.Column(db.Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name=db.Column(db.String(<span class="number">20</span>))</span><br><span class="line">    classes=db.relationship(<span class="string">"Class"</span>,</span><br><span class="line">                            secondary=registrations,</span><br><span class="line">                            backref=db.backref(<span class="string">"students"</span>,lazy=<span class="string">"dynamic"</span>),</span><br><span class="line">                            lazy=<span class="string">"dynamic"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id=db.Column(db.Integer,primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name=db.Column(db.String(<span class="number">20</span>))</span><br><span class="line">c=Class(name=<span class="string">"语文"</span>)</span><br><span class="line"><span class="comment">#学生s注册了课程c</span></span><br><span class="line">s.classes.append(c)</span><br><span class="line">db.session.add(s)</span><br><span class="line">s.classes.remove(c)</span><br><span class="line">db.session.add(s)</span><br><span class="line"><span class="comment">#学生s注册的所有课程</span></span><br><span class="line">s.classes.all()</span><br><span class="line"><span class="comment">#注册c的所有的学生</span></span><br><span class="line">c.students.all()</span><br></pre></td></tr></table></figure></p><h5 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h5><p><img src="/images/zyy.png" alt="自引用"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Follow</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__=<span class="string">"follows"</span></span><br><span class="line">    follower_id=db.Column(db.Integer,db.ForeignKey(<span class="string">"users.id"</span>),primary_key=<span class="keyword">True</span>)</span><br><span class="line">    followed_id=db.Column(db.Integer,db.ForeignKey(<span class="string">"user.id"</span>),primary_key=<span class="keyword">True</span>)</span><br><span class="line">    timestamp=db.Column(db.DateTime,default=datetime.utcnow)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__=<span class="string">"users"</span></span><br><span class="line">    username=db.Column(db.String(<span class="number">20</span>),index=<span class="keyword">True</span>)</span><br><span class="line">    followed=db.relationship(<span class="string">"Follow"</span>,</span><br><span class="line">                            foreign_key=[Follow.follower_id],</span><br><span class="line">                            backref=db.backref(<span class="string">"follower"</span>,lazy=<span class="string">"joined"</span>),</span><br><span class="line">                            lazy=<span class="string">"dynamic"</span>,</span><br><span class="line">                            cascade=<span class="string">"all,delete-orphan"</span>)</span><br><span class="line">     followers=db.relationship(<span class="string">"Follow"</span>,</span><br><span class="line">                            foreign_key=[Follow.followed_id],</span><br><span class="line">                            backref=db.backref(<span class="string">"followed"</span>,lazy=<span class="string">"joined"</span>),</span><br><span class="line">                            lazy=<span class="string">"dynamic"</span>,</span><br><span class="line">                            cascade=<span class="string">"all,delete-orphan"</span>)</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考内容过多，在此不一一列出，默默感谢那些走在前面的大佬。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> python </tag>
            
            <tag> sqlalchemy </tag>
            
            <tag> flask-sqlalchemy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python内置的序列类型</title>
      <link href="/2017/10/29/chapter-two-of-fluent-python/"/>
      <url>/2017/10/29/chapter-two-of-fluent-python/</url>
      
        <content type="html"><![CDATA[<h1 id="内置序列类型概览"><a href="#内置序列类型概览" class="headerlink" title="内置序列类型概览"></a>内置序列类型概览</h1><p>按照可否存储不同数据类型来分，可以分为容序列和扁平序列。</p><ul><li>容器序列<br>list, tuple, collections.deque　这些序列类型可以容纳不同类型的数据。</li><li>扁平序列<br>str, bytes, bytearray, memoryview, array.array　这类序列只能容纳一种类型的数据</li></ul><p>按照是否可变可以分为可变序列和不可变序列。</p><ul><li>可变序列<br>list, bytesarray, array.array, collections.deque, memoryview</li><li>不可变序列<br>tuple, str, bytes</li></ul><h1 id="列表推导式和生成器表达式"><a href="#列表推导式和生成器表达式" class="headerlink" title="列表推导式和生成器表达式"></a>列表推导式和生成器表达式</h1><p>列表推导是构建列表的快捷方式。而生成器表达式则可以用来创建其他的任何序列。</p><h2 id="善于使用列表推导式"><a href="#善于使用列表推导式" class="headerlink" title="善于使用列表推导式"></a>善于使用列表推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line">c=[(d,e) <span class="keyword">for</span> d,e <span class="keyword">in</span> zip(a,b)]</span><br><span class="line">print(c)</span><br><span class="line">g=[(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">for</span> j <span class="keyword">in</span> b]</span><br><span class="line">pprint(g)</span><br><span class="line"><span class="string">"""注意比较c,g两个列表推导式的区别"""</span></span><br><span class="line">h=[i+i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">print(h)</span><br><span class="line"><span class="comment">#生成器表达式</span></span><br><span class="line"><span class="comment">#把列表推导式的中括号改为圆括号就得到了生成器表达式</span></span><br><span class="line">a=(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">print(a)</span><br><span class="line">print(a.__next__())</span><br><span class="line">print(a.__next__())</span><br><span class="line">print(a.__next__())</span><br><span class="line">print(a.__next__())</span><br><span class="line">print(a.__next__())</span><br><span class="line"><span class="comment">#当生成器表达式作为函数调用过程中的唯一</span></span><br><span class="line"><span class="comment">#参数的时候不需要再用圆括号括起来</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="string">'b'</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="string">'c'</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">'a'</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">'b'</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="string">'c'</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">'a'</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">'b'</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="string">'c'</span>)]</span><br><span class="line"> [<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>]</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x7f28a9f3fc50</span>&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p><h2 id="元组不仅仅是不可变列表"><a href="#元组不仅仅是不可变列表" class="headerlink" title="元组不仅仅是不可变列表"></a>元组不仅仅是不可变列表</h2><p>如果仅仅是把元组理解为不可变的列表，那其他的信息——他所含有的元素的总数和他们的位置似乎就变得可有可无了。但是这样并没有发挥元组本来所有的力量。元组的特点就是它所记录数据的数量和位置。</p><h2 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拆包</span></span><br><span class="line">a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">n1,n2,n3=a</span><br><span class="line">print(n1)</span><br><span class="line">print(n2)</span><br><span class="line">print(n3)</span><br><span class="line"><span class="comment">#用*处理剩下的元素</span></span><br><span class="line">b=(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"ddd"</span>)</span><br><span class="line">b1,b2,*rest=b</span><br><span class="line">print(b1)</span><br><span class="line">print(b2)</span><br><span class="line">print(rest)</span><br><span class="line"><span class="comment">#变量的值</span></span><br><span class="line">m=<span class="number">1</span></span><br><span class="line">n=<span class="number">2</span></span><br><span class="line">print(m,n)</span><br><span class="line">m,n=n,m</span><br><span class="line">print(m,n)</span><br><span class="line"><span class="comment">#用*运算符把一个可迭代对象拆开作为函数的参数</span></span><br><span class="line">c=(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myadd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">print(myadd(*c))</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">[&apos;ccc&apos;, &apos;ddd&apos;]</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">11</span><br></pre></td></tr></table></figure></p><h2 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h2><p>collctions.namedtuple()是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">City=namedtuple(<span class="string">"City"</span>,[<span class="string">"name"</span>,<span class="string">"country"</span>,<span class="string">"population"</span>])</span><br><span class="line">Beijing=City(<span class="string">"Beijing"</span>,<span class="string">"China"</span>,<span class="number">100</span>)</span><br><span class="line">Tokyo=City(<span class="string">"Tokyo"</span>,<span class="string">"Japan"</span>,<span class="number">96</span>)</span><br><span class="line">print(Beijing.country)</span><br><span class="line">print(Tokyo.population)</span><br><span class="line">print(Tokyo[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">China</span><br><span class="line"><span class="number">96</span></span><br><span class="line">Japan</span><br></pre></td></tr></table></figure></p><p>创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。存放在对应字段里的数据要以一串参数的形式传入到构造函数中。可以通过字段名或者位置来获取一个字段的信息。</p><h3 id="具名元组的属性和方法"><a href="#具名元组的属性和方法" class="headerlink" title="具名元组的属性和方法"></a>具名元组的属性和方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(City._fields)<span class="comment">#获得所有的字段名</span></span><br><span class="line">cityMsg=(<span class="string">"Shanghai"</span>,<span class="string">"China"</span>,<span class="number">99</span>)</span><br><span class="line">shanghai=City._make(cityMsg)<span class="comment">#创建对象的一种方式，和City(*cityMsg)一样</span></span><br><span class="line">print(shanghai._asdict())</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> shanghai._asdict().items():</span><br><span class="line">    print(key,<span class="string">":"</span>,value)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'name'</span>, <span class="string">'country'</span>, <span class="string">'population'</span>)</span><br><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'Shanghai'</span>), (<span class="string">'country'</span>, <span class="string">'China'</span>), (<span class="string">'population'</span>, <span class="number">99</span>)])</span><br><span class="line">name : Shanghai</span><br><span class="line">country : China</span><br><span class="line">population : <span class="number">99</span></span><br></pre></td></tr></table></figure></p><h2 id="序列排序"><a href="#序列排序" class="headerlink" title="序列排序"></a>序列排序</h2><p>在这里我们用list这一个序列来作为例子讲解python中序列的排序，其他的可排序序列和list是一致。这里主要讨论list.sort()和sorted()。前者是对列表就地排序，它会返回None,将list改变为有序的list.而后者则不会改变传入的list，只是复制了一个新的list,将新的list调整顺序之后返回。无论是list.sort()还是sorted()都有两个可选的关键字参数：key,reverse。他们分别决定排序的标准和升降序。</p><h2 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h2><p>bisect模块包含两个主要的函数，bisect和insort两个函数都是利用二分查找算法来在有序序列中查找或插入元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">38</span>,<span class="number">85</span>]</span><br><span class="line">b=bisect.bisect(a,<span class="number">39</span>)</span><br><span class="line"><span class="comment">#返回39插入已升序排序序列a中后仍然满足升序规则的下标值</span></span><br><span class="line">a.insert(b,<span class="number">39</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#上面两步操作可以直接用下面的替代</span></span><br><span class="line">c=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">38</span>,<span class="number">85</span>]</span><br><span class="line">d=bisect.insort(c,<span class="number">39</span>)<span class="comment">#直接插入并且保持升序</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 38, 39, 85]</span><br><span class="line">[1, 2, 38, 39, 85]</span><br></pre></td></tr></table></figure></p><h1 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h1><p>有时候因为列表实在太方便了，所以python程序员会过度使用它。但是，如果你只需要处理数字列表的话，数组可能是个更好的选择，下面我们就来探讨一下可以替换列表的数据结构。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组(array)可以紧凑盛放基本的变量，如：字符，整数，浮点数。他是一个序列类型，在表现上和list非常想，但是它存储的数据类型受到了限制，它只能存储相同的基本类型的数据。所存储的数据的类型由array对象初始化时传入的typecode指定。以下的为所支持的typecode:</p><table><thead><tr><th style="text-align:center">Typecode</th><th style="text-align:center">C Type</th><th style="text-align:center">Python Type</th><th style="text-align:center">Minimum size in bytes</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">signed char</td><td style="text-align:center">int</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">unsigned char</td><td style="text-align:center">int</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">Py_UNICODE</td><td style="text-align:center">Unicode character</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">signed short</td><td style="text-align:center">int</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">unsigned char</td><td style="text-align:center">int</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">signed int</td><td style="text-align:center">int</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">unsigned int</td><td style="text-align:center">int</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">signed long</td><td style="text-align:center">int</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">unsigned long</td><td style="text-align:center">int</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">signed long  long</td><td style="text-align:center">int</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">unsigned long long</td><td style="text-align:center">int</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">f</td><td style="text-align:center">float</td><td style="text-align:center">float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">double</td><td style="text-align:center">float</td><td style="text-align:center">8</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line">a1=array(<span class="string">'q'</span>,(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)))</span><br><span class="line"><span class="comment">#其基本上和list具备相同的行为</span></span><br><span class="line">print(a1.typecode)</span><br><span class="line">print(a1[<span class="number">2</span>])</span><br><span class="line">print(a1.count(<span class="number">55</span>))</span><br><span class="line">print(a1.pop())</span><br><span class="line">a3=array(<span class="string">'d'</span>,(random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>**<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"float.bin"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    a3.tofile(f)</span><br><span class="line">a2=array(<span class="string">"d"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"float.bin"</span>,<span class="string">"rb"</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    a2.fromfile(f2,<span class="number">10</span>**<span class="number">3</span>)</span><br><span class="line">print(a2[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h2><p>memoryview是一个内置类，他能让用户在不复制内容的情况下操作同一个数组的不同切片，在数据结构之间共享内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">a=array(<span class="string">'h'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(a)</span><br><span class="line">m1=memoryview(a)</span><br><span class="line">print(len((m1)))</span><br><span class="line">m1[<span class="number">0</span>]=<span class="number">15</span></span><br><span class="line">print(m1)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array(&apos;h&apos;, [1, 2, 3])</span><br><span class="line">3</span><br><span class="line">&lt;memory at 0x7f7d2df4dc48&gt;</span><br><span class="line">array(&apos;h&apos;, [15, 2, 3])</span><br></pre></td></tr></table></figure></p><h2 id="双向队列和其他形式的队列"><a href="#双向队列和其他形式的队列" class="headerlink" title="双向队列和其他形式的队列"></a>双向队列和其他形式的队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">dq=deque(range(<span class="number">10</span>),maxlen=<span class="number">10</span>)</span><br><span class="line">print(dq)</span><br><span class="line">dq.rotate(<span class="number">3</span>)</span><br><span class="line">print(dq)</span><br><span class="line">dq.rotate(<span class="number">-3</span>)</span><br><span class="line">print(dq)</span><br><span class="line">dq.append(<span class="number">100</span>)</span><br><span class="line">print(dq)</span><br><span class="line">dq.appendleft(<span class="number">-100</span>)</span><br><span class="line">print(dq)</span><br><span class="line">dq.extend([<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>])</span><br><span class="line">print(dq)</span><br><span class="line">dq.extendleft([<span class="number">-111</span>,<span class="number">-222</span>,<span class="number">-333</span>])</span><br><span class="line">print(dq)</span><br><span class="line">print(dq.pop())</span><br><span class="line">print(dq)</span><br><span class="line">print(dq.popleft())</span><br><span class="line">print(dq)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line">deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)</span><br><span class="line">deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line">deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 100], maxlen=10)</span><br><span class="line">deque([-100, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line">deque([3, 4, 5, 6, 7, 8, 9, 111, 222, 333], maxlen=10)</span><br><span class="line">deque([-333, -222, -111, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line">9</span><br><span class="line">deque([-333, -222, -111, 3, 4, 5, 6, 7, 8], maxlen=10)</span><br><span class="line">-333</span><br><span class="line">deque([-222, -111, 3, 4, 5, 6, 7, 8], maxlen=10)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python sequence </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python数据模型</title>
      <link href="/2017/10/28/chapter-one-of-fluent-python/"/>
      <url>/2017/10/28/chapter-one-of-fluent-python/</url>
      
        <content type="html"><![CDATA[<p>最近在读一本python的书Fluent Python,收获很多。如果你是一个有一定python编程经验,并且想让自己的代码变的更加pythonic,那么这本书就非常适合你。就我个人而言，看了这本书前面的几章，感觉自己以前写的东西都不是python,之前自己对python的理解太过于肤浅了。这本书打开了我重新认识python的大门。</p><p><img src="/images/fp.jpg" alt="fluent python"><br>书中在深入介绍许多重要的主题时还穿插着介绍了许多我自己编程时很少用到的但是又非常有用的tips，全书行文逻辑比较复杂，感觉自己无法把每一部分的内容都理清，所以干脆就按照原书中的章节和知识点记录并介绍。下面就开始第一章的内容。</p><h1 id="一摞python风格的纸牌"><a href="#一摞python风格的纸牌" class="headerlink" title="一摞python风格的纸牌"></a>一摞python风格的纸牌</h1><p>第一章里作者就以一摞python风格的纸牌这个例子向我们展示了python语言的强大和优美。其中涉及到python的命名元组，列表推导，<code>__len__</code>,<code>__getitem__</code>两个特殊方法等知识点。</p><p>下面话不多说，直接拿出代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment">#创建了一个命名元祖Card</span></span><br><span class="line">Card=collections.namedtuple(<span class="string">"Card"</span>,[<span class="string">"value"</span>,<span class="string">"style"</span>])</span><br><span class="line"><span class="comment">#创建了一个纸牌类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment">#准备纸牌的牌面值和花色，使用了列表推导和字符串分割</span></span><br><span class="line">    values=[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)]+list(<span class="string">"JQKA"</span>)</span><br><span class="line">    styles=<span class="string">"spades diamonds clubs hearts"</span>.split()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards=[Card(value,style) <span class="keyword">for</span> value <span class="keyword">in</span> self.values</span><br><span class="line">                     <span class="keyword">for</span> style <span class="keyword">in</span> self.styles]</span><br><span class="line">    <span class="comment">#实现__len__魔术方法，使得我们的FrenchDeck的对象支持len()求元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line">    <span class="comment">#实现了__getitem__魔术方法，使得我们的FrenchDeck的对象支持切片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure></p><p>经过上面的简单定义，我们就得到了一个功能非常强大的类，下面我们就可以使用这个类了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T=FrenchDeck()</span><br><span class="line"><span class="comment">#源于__len__方法</span></span><br><span class="line">length=len(T)</span><br><span class="line">print(length)</span><br><span class="line"><span class="comment">#源于__getitem__方法</span></span><br><span class="line">print(T[<span class="number">2</span>])</span><br><span class="line">print(T[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line">print(T[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">a=choice(T)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Card(value=<span class="string">'2'</span>, style=<span class="string">'clubs'</span>)</span><br><span class="line">[Card(value=<span class="string">'2'</span>, style=<span class="string">'diamonds'</span>), Card(value=<span class="string">'2'</span>, style=<span class="string">'clubs'</span>), Card(value=<span class="string">'2'</span>,style=<span class="string">'hearts'</span>), Card(value=<span class="string">'3'</span>, style=<span class="string">'spades'</span>)]</span><br><span class="line">[Card(value=<span class="string">'2'</span>, style=<span class="string">'diamonds'</span>), Card(value=<span class="string">'2'</span>, style=<span class="string">'hearts'</span>)]</span><br><span class="line">Card(value=<span class="string">'10'</span>, style=<span class="string">'clubs'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="命名元组"><a href="#命名元组" class="headerlink" title="命名元组"></a>命名元组</h2><p>我们可以使用collections.namedtuple(命名元组)来构建一个简单的类，这个简单的类可以用来构建只有少数属性而没有方法的对象。比如上面的Card=collections.namedtuple(“Card”,[“value”,”style”])语句就是创建了一个只有vaule,style两个属性的类Card.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment">#比如下面就是构建了HH类，他有a,b两个属性</span></span><br><span class="line">HH=collections.namedtuple(<span class="string">"HH"</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line"><span class="comment">#实例化H1这个对象</span></span><br><span class="line">H1=HH(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(H1.a+H1.b)<span class="comment">#输出３</span></span><br></pre></td></tr></table></figure></p><p>现在就可以简单的将命名元组理解为只有属性没有方法的类，虽然在绝大多数的时候我们也是这样做的。关于命名元组的更多介绍将在介绍元组时讲到。</p><h2 id="len和getitem"><a href="#len和getitem" class="headerlink" title="len和getitem"></a><strong>len</strong>和<strong>getitem</strong></h2><p>在这个例子中第二个重要的知识点就是<code>__len__</code>和<code>__getitem__</code>两个魔术方法的使用，使用了<code>__len__</code>就让我们的对象直接支持内置的len()方法求元素的个数。而<code>__getitem__</code>直接就让我们的对象支持了和列表等可迭代对象同等的切片操作，并且让我们的对象直接成为可迭代对象。关于特殊方法的介绍是本书的重点，后面会介绍许多这样的方法。</p><h1 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h1><p>首先要明确的是，特殊方法的实现是为了被python解释器调用，你自己并不需要调用他们，也就是说没有<code>object.__len__()</code>这种写法，而应该写成<code>len(object)</code>。如果object是你自己定义的类的对象，那么<code>len(object)</code>执行时，python解释器就会自己去调用由你实现的<code>__len__()</code>方法。对于python的内置类型来说，比如list,str等，Cpython会抄个近路，<code>__len__()</code>会直接读取底层结构体中存储用来表示当前元素个数的变量的值并且返回，这就比逐个计数快许多。</p><h2 id="模拟数值类型"><a href="#模拟数值类型" class="headerlink" title="模拟数值类型"></a>模拟数值类型</h2><p>下面我们通过一个特殊方法实现一个二维向量类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"><span class="comment">#hypot(x,y)返回x**2+y**2的和开平方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x=<span class="number">0</span>,y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""支持加法"""</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x+other.x,self.y+other.y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""支持乘法"""</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x*other,self.y*other)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""支持求绝对值(求模)"""</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x,self.y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Vector Object Vector(%s,%s)"</span>%(self.x,self.y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""长度是否为０"""</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br></pre></td></tr></table></figure></p><p>下面我们就可以使用这个Vector类了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v1=Vector(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">v2=Vector(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">v3=v1+v2</span><br><span class="line">print(v3)</span><br><span class="line">v4=v1*<span class="number">3</span></span><br><span class="line">print(v4)</span><br><span class="line">print(abs(v1))</span><br><span class="line">v5=Vector()</span><br><span class="line">print(bool(v1))</span><br><span class="line">print(bool(v5))</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector Object Vector(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">Vector Object Vector(<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"><span class="number">2.23606797749979</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串的表示形式"><a href="#字符串的表示形式" class="headerlink" title="字符串的表示形式"></a>字符串的表示形式</h2><p>python中有两个内置函数repr()和str()两者都可以把一个对象用字符串的形式表达出来以便于辨认。当然，str()还有着类型转换的作用。对于自定义类的对象来说，他们两个分别依赖于<strong>repr</strong>(),<strong>str</strong>()两个特殊方法。交互式控制台和调试程序用repr函数来获得对象的字符串表示形式。而在程序中使用str(object)函数或者print(object)的时候会调用<strong>str</strong>().如果你只想实现两个特殊方法中的一个，<strong>repr</strong>()是个更好的选择，因为一个对象没有<strong>str</strong>()函数的时候，而python又需要调用它的时候，解释器会用<strong>repr</strong>()作为替代。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>在Vector的例子中，我们通过<strong>add</strong>()和<strong>mul</strong>()为Vector类带来了+和*这两个运算符。需要注意的是，这两个方法的返回值都是新创建的向量对象，被操作的对象本身并没有发生变化，在程序中只是读取了他们的值而已。</p><h2 id="自定义的布尔值"><a href="#自定义的布尔值" class="headerlink" title="自定义的布尔值"></a>自定义的布尔值</h2><p>尽管python里有bool类型，但是实际上任何的对象都可以用于需要布尔值的上下文中。为了判断一个值x是真是假，python会调用bool(x),这个函数只能返回True或者False.</p><p>默认情况下，我们自己定义的类的实例总被认为是真，除非这个类对<strong>bool</strong>()或者<strong>len</strong>()函数有自己的实现。bool(x)的背后是调用x.<strong>bool</strong>()的结果，如果不存在这个方法，那么bool(x)会尝试调用x.<strong>len</strong>()如果返回0,则bool(x)会返回False,否则返回True.</p><h1 id="python之禅-The-Zen-of-Python"><a href="#python之禅-The-Zen-of-Python" class="headerlink" title="python之禅(The Zen of Python)"></a>python之禅(The Zen of Python)</h1><p>在python交互式控制台中输入import this即可看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&apos;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&apos;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&apos;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&apos;s do more of those!</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fluent Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++总结1</title>
      <link href="/2017/10/24/something-about-c/"/>
      <url>/2017/10/24/something-about-c/</url>
      
        <content type="html"><![CDATA[<p>上学期的时候自学过c++,之后就一直在搞其他的高级语言.这学期选了一个面向对象程序设计的课，讲的是c++。但是我发现自己把c++的语法快忘干净了。所以这几天又在看c++的书了。感觉第二次看比第一次看要简单很多。许多东西扫一扫基本上也就知道是怎么回事了。但是温故而知新，我又发现了很多新的知识点和一些以前没遇到过的坑。这些坑绝大部分是来源于开发环境的变化（以前是在windows上的ide中开发的，而现在却是在linux上用一个简单的文本编辑器编辑的)。以下的点全部基于g++编译器和Ｕｂｕｎｔｕ操作系统，其他的编译器或操作系统可能情况不同。</p><h1 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h1><h2 id="类的相互引用"><a href="#类的相互引用" class="headerlink" title="类的相互引用"></a>类的相互引用</h2><p>有时，我们在定义多个类的时候可能会遇到两个类的相互引用的情况，比如下面：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">B <span class="title">func</span><span class="params">(...)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">B obj;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">(...)</span></span>;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> A obj;</span><br><span class="line">...</span><br><span class="line"> &#125;；</span><br></pre></td></tr></table></figure></p><p>这就出现了这样的尴尬局面：当把A放在B前面的时候，A中引用的B还没有定义，反之亦然。这时我们可以在两个类的定义之前先声明两个类就可以解决这个问题了，向下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先申明两个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">B <span class="title">func</span><span class="params">(...)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">B obj;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">(...)</span></span>;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> A obj;</span><br><span class="line">...</span><br><span class="line"> &#125;；</span><br></pre></td></tr></table></figure></p><h2 id="定义类时引用自身"><a href="#定义类时引用自身" class="headerlink" title="定义类时引用自身"></a>定义类时引用自身</h2><p>还有时我们可能会在一个类的定义的时候使用了这个类，比如下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A&amp; )</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这在g++这个编译器中会报错，显示A没有定义，这个时候的解决办法其实和上面的是一样的，我们可以在前面加上类的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明类A</span></span><br><span class="line">calss A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A&amp; )</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="类定义后面要加分号"><a href="#类定义后面要加分号" class="headerlink" title="类定义后面要加分号"></a>类定义后面要加分号</h2><p>这个问题也不是什么大问题，但是以前这个问题一直是ide帮我解决的，现在没有ide了，就写一下提醒自己吧！</p><h1 id="多文件编译与链接"><a href="#多文件编译与链接" class="headerlink" title="多文件编译与链接"></a>多文件编译与链接</h1><p>以前有ide，要想检验自己写的对不对，只需要点个按钮就行了，完全不用自己去管多文件之间的依赖关系，编译链接这些东西的，因为ide已经帮你做好了。但是在linux上则不同。现在这些工作都需要自己完成。</p><h2 id="关于gcc和g"><a href="#关于gcc和g" class="headerlink" title="关于gcc和g++"></a>关于gcc和g++</h2><p>在正式了解多文件编译与链接之前，先了解一下gcc和g++.</p><blockquote><p>gcc 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。现在你在编译代码时调用的gcc，已经不是当初那个c语言编译器了，更确切的说他是一个驱动程序，根据代码的后缀名来判断调用c编译器还是c++编译器 (g++)。比如你的代码后缀是*.c，他会调用c编译器还有linker去链接c的library。如果你的代码后缀是cpp, 他会调用g++编译器，当然librarycall也是&gt;c++版本的。当然我说了这么多你可能感到有些混乱，没关系，你就把gcc当成c语言编译器，g++当成c++语言编译器用就是了。</p></blockquote><p>出处：<a href="https://www.zhihu.com/question/20940822/answer/16667772" target="_blank" rel="noopener">https://www.zhihu.com/question/20940822/answer/16667772</a></p><h2 id="几个g-命令"><a href="#几个g-命令" class="headerlink" title="几个g++命令"></a>几个g++命令</h2><p>假设我们有一个test.cpp源文件，我们要把他编译链接成test.exe文件，这会经历下面这些步骤：<br>１.预处理[预处理器]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E test.cpp &gt; test.i</span><br></pre></td></tr></table></figure></p><p>功能：输出预处理后的文件，linux下以.i为后缀名。只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里 。这一步主要做了这些事情：宏的替换，还有注释的消除，还有找到相关的库文件。用编辑器打开test.i会发现有很多很多代码，你只需要看最后部分就会发现，预处理做了宏的替换，还有注释的消除，可以理解为无关代码的清除。</p><p>2.将预处理后的文件不转换成汇编语言,生成以.s结尾的文件[编译器]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.cpp</span><br></pre></td></tr></table></figure></p><p>功能:会生成test.s文件，.s文件表示是汇编文件，用编辑器打开就都是汇编指令。</p><p>3.由汇编指令变为目标代码(机器代码)生成.o的文件[汇编器as]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c test.cpp</span><br></pre></td></tr></table></figure></p><p>功能：.o是GCC生成的目标文件，除非你是做编译器和连接器调试开发的，否则打开这种.o没有任何意义。二进制机器码一般人也读不了。</p><p>4.连接目标代码,生成可执行程序[链接器ld]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.o -L F:\vs2008\VC\include\iostream</span><br></pre></td></tr></table></figure></p><p>功能：将.o文件与所需的库文件链接整合形成.exe文件，这就是可执行文件。-L 表示链接，这里我后面写的是绝对路径，相对各人电脑不同</p><p>在上面各个步骤中你可以用-o命令输出你自己想要的各种名字。比如最后一个命令，用下面的输出test.exe<br>你可以<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ Test.o -o Test.exe -L F:\vs2008\VC\include\iostream</span><br></pre></td></tr></table></figure></p><p>上面的四个步骤其实可以合并成一条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp</span><br></pre></td></tr></table></figure></p><p>这一条命令包含了上面的四个步骤，在ubuntu16.4上会默认生成名为a.out的可执行文件，这样我们就可以通过./a.out来执行这个可执行文件了。<br>我们也可以指定生成的可执行文件的文件名，通过-o选项<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test.exe test.cpp</span><br></pre></td></tr></table></figure></p><h2 id="为什么用多文件"><a href="#为什么用多文件" class="headerlink" title="为什么用多文件"></a>为什么用多文件</h2><p>在实际的开发中，为了便于团队的协作和保持代码的可维护性，加强代码的可重用性，以及通过设计抽象数据类型来加强封装，使的将不同功能的模块放在不同的文件中是一种最好的选择。程序的实现往往是通过一个一个组件来实现的，而程序的组件往往是通过一个或几个封装好的类来实现的，为了符合抽象数据类型(ADT)的设计原则,组件的设计者通常都是将类的接口文件(类的声明)，类的实现文件(类的具体功能的实现)分开来写，而使用这个组件的应用程序又是放在另外的一个文件中。这样来看在一个文件中就有了３中类型的文件：接口文件，实现文件，应用程序文件。他们彼此之间通过相互include来建立联系。这样一来，在一个项目中，文件与文件之间就有了非常复杂的依赖关系。所以在编译时先编译谁后编译谁就成了一个问题。</p><h2 id="用makefile解决问题"><a href="#用makefile解决问题" class="headerlink" title="用makefile解决问题"></a>用makefile解决问题</h2><p>make+makefile可以非常方便的控制这种程序的编译链接问题。<br>先来看下面的一个小项目：<br>projectName:<br>student.h<br>student.cpp<br>main.cpp<br>这是一个小小的项目，student.h(接口文件)中定义了一个学生类，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止重复定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//这里先声明一下，因为在这个类的定义中使用了这个类本身</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br><span class="line"><span class="comment">//定义这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name,<span class="keyword">int</span> age,<span class="keyword">int</span> score);</span><br><span class="line">    Student();</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">is_score_equal</span><span class="params">(Student t1,Student t2)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;<span class="comment">//注意类的定义的末尾需要有分号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">student.cpp(实现文件)中实现了这个类的功能，代码如下：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">Student::Student(<span class="built_in">string</span> name,<span class="keyword">int</span> age,<span class="keyword">int</span> score):name(name),age(age),score(score)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"初始化成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Student::Student():name(<span class="string">"none"</span>),age(<span class="number">18</span>),score(<span class="number">60</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"初始化成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> Student::getName()&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setName(<span class="built_in">string</span> _name)&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这里传入的变量名称最好不要与私有变量名相同,如传入name,然后</span></span><br><span class="line"><span class="comment">*赋值写为name=name,这在g++中会报错，下面其他的也一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    name=_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::getAge()&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setAge(<span class="keyword">int</span> _age)&#123;</span><br><span class="line">    age=_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::getScore()&#123;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setScore(<span class="keyword">int</span> _score)&#123;</span><br><span class="line">    </span><br><span class="line">    score=_score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_score_equal</span><span class="params">(Student t1,Student t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.score==t2.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main.cpp(应用程序文件)使用了这个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"小明"</span>,<span class="number">20</span>,<span class="number">96</span>)</span></span>;</span><br><span class="line">    Student s2;</span><br><span class="line">    s2.setScore(<span class="number">96</span>);</span><br><span class="line">    s2.setAge(<span class="number">55</span>);</span><br><span class="line">    <span class="keyword">bool</span> b=is_score_equal(s1,s2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s2.getAge()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">" "</span>&lt;&lt;s1.getScore()&lt;&lt;<span class="string">" "</span>&lt;&lt;s2.getScore()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我要把这个项目编译出来，那么我需要一个名为makefile的文件来指定文件的依赖关系和编译链接逻辑，下面先拿出makefile:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.exe:main.o student.o </span></span><br><span class="line">g++ -o main.exe student.o main.o</span><br><span class="line"><span class="section">student.o:student.cpp student.h</span></span><br><span class="line">g++ -c student.cpp</span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line">g++ -c main.cpp</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm main.exe main.o student.o</span><br></pre></td></tr></table></figure></p><p>把这个makefile文件放在项目根目录，这时只有我们在根目录执行make命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure></p><p>执行完后就可以在项目目录中看到main.o,student.o两个目标文件，和main.exe这个可执行文件，这个main.exe就是我们最终需要的那个文件了。这时我们再执行./main.exe就可以执行我们的程序了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./main.exe</span><br></pre></td></tr></table></figure></p><p>同时，如果我们想要清除中间生成的目标文件和最终的可执行文件，从而进行重新编译链接，我们可以使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br></pre></td></tr></table></figure></p><h2 id="makefile的语法"><a href="#makefile的语法" class="headerlink" title="makefile的语法"></a>makefile的语法</h2><p>更多关于makefile的内容请参考<a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D#makefile.E7.9A.84.E8.A7.84.E5.88.99" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>递归和非递归解决八皇后问题</title>
      <link href="/2017/10/10/Eight-Queens/"/>
      <url>/2017/10/10/Eight-Queens/</url>
      
        <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解.<br><img src="/images/八皇后.png" alt="八皇后示意图"></p><p>八皇后问题最早是由国际象棋棋手马克斯·贝瑟尔（Max Bezzel）于1848年提出。第一个解在1850年由弗朗兹·诺克（Franz Nauck）给出。并且将其推广为更一般的n皇后摆放问题。诺克也是首先将问题推广到更一般的n皇后摆放问题的人之一。</p><h1 id="递归实现求解八皇后-N皇后"><a href="#递归实现求解八皇后-N皇后" class="headerlink" title="递归实现求解八皇后(N皇后)"></a>递归实现求解八皇后(N皇后)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 12</span></span><br><span class="line"><span class="keyword">int</span> a[MAX]=&#123;<span class="number">0</span>&#125;;<span class="comment">//下标表示行，对应的值表示列</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//解的总数</span></span><br><span class="line"><span class="comment">//打印摆放好的棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;MAX<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==j)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Q "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"* "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在假设第n行以前的都放好了，现在检查第n+1是否可以放置皇后</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[n]||<span class="built_in">abs</span>(a[i]-a[n])==(n-i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">        a[n]=i;</span><br><span class="line">        <span class="keyword">if</span>(check(n))&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==MAX<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">//说明此时全部摆放完成，下面打印排放的结果</span></span><br><span class="line">                show(a);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                sum+=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                put(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    put(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非递归实现求解八皇后-N皇后"><a href="#非递归实现求解八皇后-N皇后" class="headerlink" title="非递归实现求解八皇后(N皇后)"></a>非递归实现求解八皇后(N皇后)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT -1</span></span><br><span class="line"><span class="keyword">int</span> q[MAX]=&#123;INIT&#125;;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]==col||<span class="built_in">abs</span>(q[i]-col)==<span class="built_in">abs</span>(row-i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> * a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;MAX<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==j)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"Q "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"* "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;MAX)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;MAX)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;check(i,j)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(i,j))&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"ok"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                q[i]=j;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个第i行都没有地方放，这时就需要回溯，就说明上面</span></span><br><span class="line">        <span class="comment">//有的行放错了位置</span></span><br><span class="line">        <span class="keyword">if</span>(q[i]==INIT)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">                j=q[i]+<span class="number">1</span>;</span><br><span class="line">                q[i]=INIT;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明此时已经排好一组了</span></span><br><span class="line">        <span class="keyword">if</span>(i==MAX<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;sum+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            show(q);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            sum+=<span class="number">1</span>;</span><br><span class="line">            j=q[i]+<span class="number">1</span>;</span><br><span class="line">            q[i]=INIT;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eight Queens </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单链表</title>
      <link href="/2017/09/28/Linked-List/"/>
      <url>/2017/09/28/Linked-List/</url>
      
        <content type="html"><![CDATA[<p>这一篇博客总结一下单链表常见方法的实现。相比于动态数组，对于单链表来说，它存储的元素并不要求在内存上连续，元素与元素之间通过指针串联起来。这样有许多好处，比如在单链表中间位置插入和删除元素的效率非常高，同时，它也有不足之处，它无法像动态数组那样可以通过下标直接访问。</p><p>链表实现的关键在于指针。一个节点除了保存着数据本身，还保存着指向下一个节点的指针。这样我们就可以通过一个节点找到下一个节点。从而将所有数据连接起来。<br><img src="/images/单链表.png" alt="单链表示意图"><br>如上图所示，首先有一个头结点，该节点的数据域并不存放有效数据，指针域指向下一个节点。而最后的一个节点的指针域指向NULL。下面我来总结一下单链表的常见操作。</p><h1 id="面向过程实现单链表操作"><a href="#面向过程实现单链表操作" class="headerlink" title="面向过程实现单链表操作"></a>面向过程实现单链表操作</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>    </span><br><span class="line">&#125;Node,*NodePtr;</span><br></pre></td></tr></table></figure><p>结构体中存储着int类型的数据，和指向自身类型的指针。</p><h2 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a>初始化链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NodePtr <span class="title">createList</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    NodePtr headPtr=<span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">if</span>(headPtr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"分配内存失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    headPtr-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> headPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分配头节点的内存空间，并且将头结点中的指针赋值为NULL,防止其指向了不明的变量。由于头结点不存放实际的数据，所以并没有对data赋值。最后返回指向头结点的指针(即头指针)。</p><h2 id="计算长度"><a href="#计算长度" class="headerlink" title="计算长度"></a>计算长度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listSize</span><span class="params">(NodePtr phead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//跳过头结点</span></span><br><span class="line">    phead=phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(phead!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        i+=<span class="number">1</span>;</span><br><span class="line">        phead=phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算的是链表中有效节点的个数，由于头结点并不包含有效数据，所以直接跳过了头节点(phead=phead-&gt;next),while循环的条件为phead!=NULL,这是因为我们在设计链表的时候总是会将最后一个节点中的指针指向NULL,所以当phead==NULL时，链表也就循环完了。</p><h2 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(NodePtr phead)</span></span>&#123;</span><br><span class="line">    phead=phead-&gt;next;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"打印所有节点："</span>;</span><br><span class="line">    <span class="keyword">while</span>(phead!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;phead-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        phead=phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里与上方求链表的长度是一致的。</p><h2 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(NodePtr phead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入你要增加的节点数："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">        NodePtr ptemp=<span class="keyword">new</span> Node;</span><br><span class="line">        <span class="keyword">if</span>(ptemp==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"分配内存失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptemp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"个节点的数据值"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ptemp-&gt;data;</span><br><span class="line">        phead-&gt;next=ptemp;</span><br><span class="line">        phead=phead-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以循环的方式增加链表的节点个数。通过收集控制台的输入来决定增加的数据的个数和具体的数据。每一个节点的增加都要经历如下的步骤：</p><ul><li>分配内存空间</li><li>赋值，数据域赋对应值，指针域赋值为NULL</li><li>链接，将新节点链接到链表的尾端</li></ul><p>下面的是一个节点加入到链表尾端的示意图:<br><img src="/images/链表尾部插入.png" alt="尾端添加节点示意图"></p><h2 id="在头部插入节点"><a href="#在头部插入节点" class="headerlink" title="在头部插入节点"></a>在头部插入节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAtHead</span><span class="params">(NodePtr phead)</span></span>&#123;</span><br><span class="line">    NodePtr ptemp=<span class="keyword">new</span> Node;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入在头部插入的数据值"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ptemp-&gt;data;</span><br><span class="line">    ptemp-&gt;next=phead-&gt;next;</span><br><span class="line">    phead-&gt;next=ptemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/头部插入.png" alt="头部插入节点示意图"></p><h2 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAtTail</span><span class="params">(NodePtr phead)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先创建需要插入的节点</span></span><br><span class="line">    NodePtr pinsert=<span class="keyword">new</span> Node;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入在尾部插入的数据"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;pinsert-&gt;data;</span><br><span class="line">    pinsert-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    NodePtr ptemp=phead;</span><br><span class="line">    phead=phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(phead!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        phead=phead-&gt;next;</span><br><span class="line">        ptemp=ptemp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ptemp-&gt;next=pinsert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配并删除第一个匹配节点"><a href="#匹配并删除第一个匹配节点" class="headerlink" title="匹配并删除第一个匹配节点"></a>匹配并删除第一个匹配节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOneNode</span><span class="params">(NodePtr phead,<span class="keyword">int</span> _data)</span></span>&#123;</span><br><span class="line">    NodePtr ptemp;</span><br><span class="line">    ptemp=phead;</span><br><span class="line">    phead=phead-&gt;next;</span><br><span class="line">    <span class="comment">//空链表的情况</span></span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"链表为空！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(phead!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//找到了</span></span><br><span class="line">        <span class="keyword">if</span>(phead-&gt;data==_data)&#123;</span><br><span class="line">            ptemp-&gt;next=phead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> phead;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到</span></span><br><span class="line">        phead=phead-&gt;next;</span><br><span class="line">        ptemp=ptemp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要一前一后的指针来分别指向一前一后两个节点。前面的指针负责寻找目标节点，当找到了目标节点之后就将目标节点后一个节点的指针域指向目标节点的下一个节点，这样目标节点也就不再属于该链表了。同时释放目标节点的内存。跳出循环，这样也就删除了匹配的第一个节点。</p><h2 id="匹配并删除所有匹配节点"><a href="#匹配并删除所有匹配节点" class="headerlink" title="匹配并删除所有匹配节点"></a>匹配并删除所有匹配节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteAllNode</span><span class="params">(NodePtr phead,<span class="keyword">int</span> _data)</span></span>&#123;</span><br><span class="line">    NodePtr ptemp;</span><br><span class="line">    ptemp=phead;</span><br><span class="line">    phead=phead-&gt;next;</span><br><span class="line">    <span class="comment">//空链表的情况</span></span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"链表为空！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(phead!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(phead-&gt;data==_data)&#123;</span><br><span class="line">            ptemp-&gt;next=phead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> phead;</span><br><span class="line">            phead=ptemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        phead=phead-&gt;next;</span><br><span class="line">        ptemp=ptemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">``` </span><br><span class="line">这里与上面的删除第一个匹配的节点的情况差不多，只不过在删除了一个节点之后还需要保持phead和ptemp的这种一前一后的关系，让他继续去删除所有匹配的节点。这里大家可能会有点奇怪，明明phead已经被释放了，为什么还可以将ptemp-&gt;next赋给phead呢？其实这里需要注意的是<span class="keyword">delete</span> phead只是释放了phead所指向的那一块内存，并没有释放phead变量本身。</span><br><span class="line"></span><br><span class="line">## 销毁整个链表</span><br><span class="line">``` c++</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryList</span><span class="params">(NodePtr phead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        destoryList(phead-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> phead; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用递归的方式释放了整个链表。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建头结点</span></span><br><span class="line">    NodePtr phead=createList();</span><br><span class="line">    <span class="comment">//测试增加节点</span></span><br><span class="line">    addNode(phead);</span><br><span class="line">    printList(phead);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"节点数量："</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;listSize(phead)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// //测试从尾部插入一个节点</span></span><br><span class="line">    insertAtTail(phead);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"从尾部插入节点后："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printList(phead);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"节点数量："</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;listSize(phead)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    insertAtHead(phead);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"从头插入节点后："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printList(phead);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"节点数量："</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;listSize(phead)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//测试删除第一个匹配的节点</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入你要删除的元素的值(只删除第一个匹配的值)："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    deleteOneNode(phead,a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"删除第一个"</span>&lt;&lt;a&lt;&lt;<span class="string">"后："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printList(phead);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"节点数量："</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;listSize(phead)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//测试删除所有匹配的节点</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入你要删除的元素的值(将删除所有匹配的值)："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">    deleteAllNode(phead,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"删除所有的"</span>&lt;&lt;b&lt;&lt;<span class="string">"后："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printList(phead);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"节点数量："</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;listSize(phead)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    destoryList(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入你要增加的节点数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">输入第<span class="number">1</span>个节点的数据值</span><br><span class="line"><span class="number">1</span></span><br><span class="line">输入第<span class="number">2</span>个节点的数据值</span><br><span class="line"><span class="number">2</span></span><br><span class="line">输入第<span class="number">3</span>个节点的数据值</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输入第<span class="number">4</span>个节点的数据值</span><br><span class="line"><span class="number">3</span></span><br><span class="line">输入第<span class="number">5</span>个节点的数据值</span><br><span class="line"><span class="number">2</span></span><br><span class="line">输入第<span class="number">6</span>个节点的数据值</span><br><span class="line"><span class="number">1</span></span><br><span class="line">输入第<span class="number">7</span>个节点的数据值</span><br><span class="line"><span class="number">4</span></span><br><span class="line">输入第<span class="number">8</span>个节点的数据值</span><br><span class="line"><span class="number">5</span></span><br><span class="line">输入第<span class="number">9</span>个节点的数据值</span><br><span class="line"><span class="number">6</span></span><br><span class="line">输入第<span class="number">10</span>个节点的数据值</span><br><span class="line"><span class="number">8</span></span><br><span class="line">打印所有节点：<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> </span><br><span class="line">节点数量：<span class="number">10</span></span><br><span class="line">输入在尾部插入的数据</span><br><span class="line"><span class="number">100</span></span><br><span class="line">从尾部插入节点后：</span><br><span class="line">打印所有节点：<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">100</span> </span><br><span class="line">节点数量：<span class="number">11</span></span><br><span class="line">输入在头部插入的数据值</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">从头插入节点后：</span><br><span class="line">打印所有节点：<span class="number">-1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">100</span> </span><br><span class="line">节点数量：<span class="number">12</span></span><br><span class="line">请输入你要删除的元素的值(只删除第一个匹配的值)：</span><br><span class="line"><span class="number">2</span></span><br><span class="line">删除第一个<span class="number">2</span>后：</span><br><span class="line">打印所有节点：<span class="number">-1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">100</span> </span><br><span class="line">节点数量：<span class="number">11</span></span><br><span class="line">请输入你要删除的元素的值(将删除所有匹配的值)：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">删除所有的<span class="number">1</span>后：</span><br><span class="line">打印所有节点：<span class="number">-1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">100</span> </span><br><span class="line">节点数量：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><h1 id="面向对象实现单链表操作"><a href="#面向对象实现单链表操作" class="headerlink" title="面向对象实现单链表操作"></a>面向对象实现单链表操作</h1><p>我同样的用面向对象的思想实现了一遍这样的操作.</p><h2 id="LinkedList-h"><a href="#LinkedList-h" class="headerlink" title="LinkedList.h"></a>LinkedList.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">namespace</span> mylinkedlist</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">&#125; Node, *NodePtr;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>;</span></span><br><span class="line"><span class="comment">//定义这个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    LinkedList();</span><br><span class="line">    <span class="comment">//获取链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//尾部增加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(ElementType e)</span></span>;</span><br><span class="line">    <span class="comment">//头部插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_head</span><span class="params">(ElementType e)</span></span>;</span><br><span class="line">    <span class="comment">//释放整个链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//匹配并删除第一个匹配的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteFirst</span><span class="params">(ElementType e)</span></span>;</span><br><span class="line">    <span class="comment">//匹配并删除所有的匹配的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(ElementType e)</span></span>;</span><br><span class="line">    <span class="comment">//反序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//排序,默认从小到大排序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> rule = <span class="string">'&lt;'</span>)</span></span>;</span><br><span class="line">    <span class="comment">//在指定位置插入指定节点</span></span><br><span class="line">    <span class="comment">//在第pos个节点之后插入数据域为e的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, ElementType e)</span></span>;</span><br><span class="line">    <span class="comment">//将两个已经按相同规则排序的链表合并并且按指定规则排序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(LinkedList &amp;, <span class="keyword">char</span> originalrule, <span class="keyword">char</span> rule = <span class="string">'&lt;'</span>)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    NodePtr head;</span><br><span class="line">    NodePtr tail;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="LinkedList-cpp"><a href="#LinkedList-cpp" class="headerlink" title="LinkedList.cpp"></a>LinkedList.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkedList.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> mylinkedlist</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//LinkedList构造函数</span></span><br><span class="line">LinkedList::LinkedList()</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>; <span class="comment">//保护指针，防止指向不明变量</span></span><br><span class="line">    tail = head;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取链表长度</span></span><br><span class="line"><span class="keyword">int</span> LinkedList::size()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾部插入节点</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::append(ElementType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开辟内存</span></span><br><span class="line">    NodePtr ptemp = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">if</span> (ptemp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"分配内存失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填充节点</span></span><br><span class="line">    ptemp-&gt;data = e;</span><br><span class="line">    ptemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    tail-&gt;next = ptemp;</span><br><span class="line">    tail = ptemp;</span><br><span class="line">    <span class="comment">//更新count</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头部插入</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::push_head(ElementType e)</span><br><span class="line">&#123;</span><br><span class="line">    NodePtr ptemp = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">if</span> (ptemp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"分配内存失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptemp-&gt;data = e;</span><br><span class="line">    ptemp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = ptemp;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::print()</span><br><span class="line">&#123;</span><br><span class="line">    NodePtr phead = head;</span><br><span class="line">    phead = phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (phead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; phead-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        phead = phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配并删除第一个匹配的节点</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::deleteFirst(ElementType e)</span><br><span class="line">&#123;</span><br><span class="line">    NodePtr phead, ptemp;</span><br><span class="line">    phead = head;</span><br><span class="line">    ptemp = phead;</span><br><span class="line">    phead = phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (phead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (phead-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            ptemp-&gt;next = phead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> phead;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        phead = phead-&gt;next;</span><br><span class="line">        ptemp = ptemp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配并删除所有匹配的节点</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::deleteAll(ElementType e)</span><br><span class="line">&#123;</span><br><span class="line">    NodePtr phead, ptemp;</span><br><span class="line">    phead = head;</span><br><span class="line">    ptemp = phead;</span><br><span class="line">    phead = phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (phead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (phead-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            ptemp-&gt;next = phead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> phead;</span><br><span class="line">            count--;</span><br><span class="line">            phead = ptemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            phead = phead-&gt;next;</span><br><span class="line">            ptemp = ptemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反序</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::reverse()</span><br><span class="line">&#123;</span><br><span class="line">    NodePtr p, q,r;</span><br><span class="line">    NodePtr h=<span class="keyword">new</span> Node;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    <span class="comment">// head = NULL; //旧的头指针是新的尾指针，next需要指向NULL</span></span><br><span class="line">    <span class="keyword">while</span> (q)</span><br><span class="line">    &#123;</span><br><span class="line">        r = q-&gt;next; <span class="comment">//先保留下一个step要处理的指针</span></span><br><span class="line">        q-&gt;next = p; <span class="comment">//然后p q交替工作进行反向</span></span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    h-&gt;next=p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tail = head;</span></span><br><span class="line">    head = h; <span class="comment">// 最后q必然指向NULL，所以返回了p作为新的头指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::sort(<span class="keyword">char</span> rule)</span><br><span class="line">&#123;</span><br><span class="line">    NodePtr phead, ptemp;</span><br><span class="line">    <span class="keyword">if</span> (rule == <span class="string">'&lt;'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (phead = head-&gt;next; phead != <span class="literal">NULL</span>; phead = phead-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (ptemp = phead-&gt;next; ptemp != <span class="literal">NULL</span>; ptemp = ptemp-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (phead-&gt;data &gt; ptemp-&gt;data)</span><br><span class="line">                &#123;</span><br><span class="line">                    ElementType temp = phead-&gt;data;</span><br><span class="line">                    phead-&gt;data = ptemp-&gt;data;</span><br><span class="line">                    ptemp-&gt;data = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rule == <span class="string">'&gt;'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (phead = head-&gt;next; phead != <span class="literal">NULL</span>; phead = phead-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (ptemp = phead-&gt;next; ptemp != <span class="literal">NULL</span>; ptemp = ptemp-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (phead-&gt;data &lt; ptemp-&gt;data)</span><br><span class="line">                &#123;</span><br><span class="line">                    ElementType temp = phead-&gt;data;</span><br><span class="line">                    phead-&gt;data = ptemp-&gt;data;</span><br><span class="line">                    ptemp-&gt;data = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请正确指明排序规则,'&lt;'或'&gt;'!"</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在第pos个节点之后插入数据域为e的节点</span></span><br><span class="line"><span class="keyword">void</span> LinkedList::insert(<span class="keyword">int</span> pos, ElementType e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//首先要找到第pos个节点</span></span><br><span class="line">    NodePtr ptemp = head;</span><br><span class="line">    ptemp = ptemp-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptemp = ptemp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    NodePtr ptemp1 = <span class="keyword">new</span> Node;</span><br><span class="line">    ptemp1-&gt;data = e;</span><br><span class="line">    ptemp1-&gt;next = ptemp-&gt;next;</span><br><span class="line">    ptemp-&gt;next = ptemp1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkedList.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mylinkedlist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    LinkedList l1=LinkedList();</span><br><span class="line">    l1.append(<span class="number">1</span>);</span><br><span class="line">    l1.append(<span class="number">1</span>);</span><br><span class="line">    l1.append(<span class="number">3</span>);</span><br><span class="line">    l1.append(<span class="number">2</span>);</span><br><span class="line">    l1.append(<span class="number">2</span>);</span><br><span class="line">    l1.append(<span class="number">5</span>);</span><br><span class="line">    l1.append(<span class="number">12</span>);</span><br><span class="line">    l1.append(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// l1.insert(2,100);</span></span><br><span class="line">    l1.print();</span><br><span class="line">    l1.reverse();</span><br><span class="line">    l1.print();</span><br><span class="line">    l1.reverse();</span><br><span class="line">    l1.print();</span><br><span class="line">    l1.sort(<span class="string">'&lt;'</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;l1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    l1.print();</span><br><span class="line">    l1.reverse();</span><br><span class="line">    l1.print();</span><br><span class="line">    l1.deleteFirst(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;l1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    l1.print();</span><br><span class="line">    l1.deleteAll(<span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;l1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    l1.print();</span><br><span class="line">    l1.sort(<span class="string">'&lt;'</span>);</span><br><span class="line">    l1.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.exe:LinkedList.o main.o</span></span><br><span class="line">g++ -o main.exe LinkedList.o main.o</span><br><span class="line"><span class="section">LinkedList.o:LinkedList.cpp LinkedList.h</span></span><br><span class="line">g++ -c LinkedList.cpp LinkedList.h</span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line">g++ -c main.cpp</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm main.exe main.o LinkedList.o LinkedList.h.gch</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态数组</title>
      <link href="/2017/09/26/Dynamic-Array/"/>
      <url>/2017/09/26/Dynamic-Array/</url>
      
        <content type="html"><![CDATA[<p>最近在学数据结构，涉及到动态数组。我自己总结了一下，把与动态数组有关的基本操作用c和c++分别写了一遍。下面把总结的成果记录一下。</p><p>动态数组之所以称之为动态，关键就在于其可以在程序运行过程中自动增加分配的内存大小。要实现这一点的关键又在于下面两点：</p><ul><li>实时记录数组的元素个数和分配的内存的大小</li><li>realloc()函数重新分配内存</li></ul><p>数组中的数据是连续存放的，可以随机访问。在数组尾部增加删除元素效率很高，但是在中间插入和删除元素则效率低下。</p><h1 id="C语言动态数组操作"><a href="#C语言动态数组操作" class="headerlink" title="C语言动态数组操作"></a>C语言动态数组操作</h1><p>要实现实时记录数组的元素个数和分配的内存的大小可以使用下面的一个结构体：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DynamicArray</span>&#123;</span></span><br><span class="line">    ElementType* elems;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">&#125; *DynamicArrayPtr;</span><br></pre></td></tr></table></figure></p><p>elems是数据所在地址块的首地址。size和capacity分别是所存储数据的个数和当前分配的容量，他们的值必须与当前数组的状况相对应。</p><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(DynamicArrayPtr DAP)</span></span>&#123;</span><br><span class="line">    DAP-&gt;elems=(ElementType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType)*<span class="number">100</span>);</span><br><span class="line">    DAP-&gt;size=<span class="number">0</span>;</span><br><span class="line">    DAP-&gt;capacity=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的过程中我们为数据存储区域分配了初始的可以容纳100个元素的内存空间，所以当前的容量为100。此时数组中还没有数据，所以大小为0.</p><h2 id="打印动态数组"><a href="#打印动态数组" class="headerlink" title="打印动态数组"></a>打印动态数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(DynamicArrayPtr DAP)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DAP-&gt;size; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, DAP-&gt;elems[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存重新分配"><a href="#内存重新分配" class="headerlink" title="内存重新分配"></a>内存重新分配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dealOverflow</span><span class="params">(DynamicArrayPtr DAP)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DAP-&gt;size &gt;= DAP-&gt;capacity) &#123;</span><br><span class="line">        ElementType* newbase = (ElementType*)<span class="built_in">realloc</span>(DAP-&gt;elems, (<span class="number">50</span> + DAP-&gt;size)*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">        <span class="keyword">if</span>(newbase==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"重新分配内存失败！"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        DAP-&gt;elems=newbase;</span><br><span class="line">DAP-&gt;capacity += DELTA_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存重新分配的条件就是当前数组中的元素个数大于或等于当前分配的容量时.重新分配使用的函数是realloc(),在原来的容量的基础之上新分配了可以容纳20个元素的空间,分配完成之后需要将记录当前容量大小的变量更新一下。这个函数主要进行的是容量是否够用的检测，如果不够用则增加容量。在每增加一个元素之前就应该调用一次该函数。</p><h2 id="尾部追加元素"><a href="#尾部追加元素" class="headerlink" title="尾部追加元素"></a>尾部追加元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(DynamicArrayPtr DAP,ElementType e)</span></span>&#123;</span><br><span class="line">    dealOverflow(DAP);</span><br><span class="line">    DAP-&gt;elems[DAP-&gt;size]=e;</span><br><span class="line">    DAP-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向尾部追加元素效率是比较高的。在追加之前首先要检测容量够不够用，追加之后要更新记录数组大小的变量的值。</p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(DynamicArrayPtr DAP,<span class="keyword">int</span> pos,ElementType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若容量不够则重新分配内存</span></span><br><span class="line">    dealOverflow(DAP);</span><br><span class="line">    <span class="comment">//下标超界的处理</span></span><br><span class="line">    <span class="keyword">if</span>(pos&gt;DAP-&gt;size||pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//移动元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=DAP-&gt;size;i&gt;pos;i--)&#123;</span><br><span class="line">        DAP-&gt;elems[i]=DAP-&gt;elems[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    DAP-&gt;elems[i]=e;</span><br><span class="line">    <span class="comment">//更新sie</span></span><br><span class="line">    DAP-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素效率较低，在所插入位置的元素之后的所有元素都必须向后移动一个位置。</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myremove</span><span class="params">(DynamicArrayPtr DAP,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="comment">//下标超界的处理</span></span><br><span class="line">    <span class="keyword">if</span>(pos&gt;=DAP-&gt;size||pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//删除数据</span></span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=pos;i&lt;DAP-&gt;size;i++)&#123;</span><br><span class="line">         DAP-&gt;elems[i]=DAP-&gt;elems[i+<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     更新size</span><br><span class="line">     DAP-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(DynamicArrayPtr DAP,<span class="keyword">char</span> rule=<span class="string">'&lt;'</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rule==<span class="string">'&lt;'</span>)&#123;<span class="comment">//从小到大排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;DAP-&gt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;DAP-&gt;size;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(DAP-&gt;elems[i]&gt;DAP-&gt;elems[j])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp=DAP-&gt;elems[i];</span><br><span class="line">                        DAP-&gt;elems[i]=DAP-&gt;elems[j];</span><br><span class="line">                        DAP-&gt;elems[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rule==<span class="string">'&gt;'</span>)&#123;<span class="comment">//从大到小排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;DAP-&gt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;DAP-&gt;size;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(DAP-&gt;elems[i]&lt;DAP-&gt;elems[j])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp=DAP-&gt;elems[i];</span><br><span class="line">                        DAP-&gt;elems[i]=DAP-&gt;elems[j];</span><br><span class="line">                        DAP-&gt;elems[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//rule参数输入错误</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请输入正确的排序规则('&lt;' or '&gt;')!!!"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用冒泡法则对元素进行排序，rule参数指定排序规则，默认按照从小到大排序。</p><h2 id="合并两个数组并排序"><a href="#合并两个数组并排序" class="headerlink" title="合并两个数组并排序"></a>合并两个数组并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeAndsort</span><span class="params">(DynamicArrayPtr DAP1,DynamicArrayPtr DAP2,<span class="keyword">char</span> rule=<span class="string">'&lt;'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;DAP2-&gt;size;i++)&#123;</span><br><span class="line">        append(DAP1,DAP2-&gt;elems[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    sort(DAP1,rule);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="两个有序数组合并排序"><a href="#两个有序数组合并排序" class="headerlink" title="两个有序数组合并排序"></a>两个有序数组合并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能:对两个已经按照相同规则排好序的动态数组合并并按照指定规则排序排序，</span></span><br><span class="line"><span class="comment"> * 根据原始规则与指定的规则的不同有四种排列组合</span></span><br><span class="line"><span class="comment"> * ＠para:DA１，DA2是两个原始的已有序的动态数组</span></span><br><span class="line"><span class="comment"> * ＠para:DA3是最终生成的结果动态数组</span></span><br><span class="line"><span class="comment"> * ＠para:originrule是原始的已排序的动态数组的排序规则('&lt;' or '&gt;')</span></span><br><span class="line"><span class="comment"> * ＠para:rule是合并后的的动态数组的排序规则('&lt;' or '&gt;')</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeAndsort_for_sorted</span><span class="params">(DynamicArrayPtr DA1,DynamicArrayPtr DA2,DynamicArrayPtr DA3,<span class="keyword">char</span> originrule,<span class="keyword">char</span> rule=<span class="string">'&lt;'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(originrule==<span class="string">'&lt;'</span>&amp;&amp;rule==<span class="string">'&lt;'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i!=DA1-&gt;size&amp;&amp;j!=DA2-&gt;size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(DA1-&gt;elems[i]&lt;DA2-&gt;elems[j])&#123;</span><br><span class="line">                    append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(DA1-&gt;elems[i]==DA2-&gt;elems[j]) &#123;</span><br><span class="line">                    <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">                    append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                    append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(DA1-&gt;size==i)&#123;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;DA2-&gt;size)&#123;</span><br><span class="line">                   append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(DA2-&gt;size==j)&#123;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;DA1-&gt;size)&#123;</span><br><span class="line">                   append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(originrule==<span class="string">'&gt;'</span>&amp;&amp;rule==<span class="string">'&gt;'</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(i!=DA1-&gt;size&amp;&amp;j!=DA2-&gt;size)&#123;</span><br><span class="line">           <span class="keyword">if</span>(DA1-&gt;elems[i]&lt;DA2-&gt;elems[j])&#123;</span><br><span class="line">               append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(DA1-&gt;elems[i]==DA2-&gt;elems[j]) &#123;</span><br><span class="line">               <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">               append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i++;</span><br><span class="line">               append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(DA1-&gt;size==i)&#123;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;DA2-&gt;size)&#123;</span><br><span class="line">              append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(DA2-&gt;size==j)&#123;</span><br><span class="line">           <span class="keyword">while</span>(i&lt;DA1-&gt;size)&#123;</span><br><span class="line">              append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(originrule==<span class="string">'&lt;'</span>&amp;&amp;rule==<span class="string">'&gt;'</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> i=DA1-&gt;size<span class="number">-1</span>,j=DA2-&gt;size<span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(DA1-&gt;elems[i]&lt;DA2-&gt;elems[j])&#123;</span><br><span class="line">               append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(DA1-&gt;elems[i]==DA2-&gt;elems[j]) &#123;</span><br><span class="line">               <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">               append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i--;</span><br><span class="line">               append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(<span class="number">-1</span>==i)&#123;</span><br><span class="line">           <span class="keyword">while</span>(j!=<span class="number">-1</span>)&#123;</span><br><span class="line">              append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">-1</span>==j)&#123;</span><br><span class="line">           <span class="keyword">while</span>(i!=<span class="number">-1</span>)&#123;</span><br><span class="line">              append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(originrule==<span class="string">'&gt;'</span>&amp;&amp;rule==<span class="string">'&lt;'</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> i=DA1-&gt;size<span class="number">-1</span>,j=DA2-&gt;size<span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(DA1-&gt;elems[i]&lt;DA2-&gt;elems[j])&#123;</span><br><span class="line">               append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i--;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(DA1-&gt;elems[i]==DA2-&gt;elems[j]) &#123;</span><br><span class="line">               <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">               append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i--;</span><br><span class="line">               append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(<span class="number">-1</span>==i)&#123;</span><br><span class="line">           <span class="keyword">while</span>(j!=<span class="number">-1</span>)&#123;</span><br><span class="line">              append(DA3,DA2-&gt;elems[j]);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">-1</span>==j)&#123;</span><br><span class="line">           <span class="keyword">while</span>(i!=<span class="number">-1</span>)&#123;</span><br><span class="line">              append(DA3,DA1-&gt;elems[i]);</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"原始规则或指定的规则不正确"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"># C++版动态数组</span><br><span class="line">我用c++把上面的c的内容封装了一下，下面的是全部的内容。</span><br><span class="line"></span><br><span class="line">## DynamicArray.h的内容</span><br><span class="line">``` c++</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口文件</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DYNAMICARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DYNAMICARRAY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CAPACITY 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELTA_CAPACITY 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">namespace</span> mydynamicarray&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span>;</span></span><br><span class="line">    <span class="comment">//定义这个类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        DynamicArray();</span><br><span class="line">        <span class="comment">//获取长度</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//获取容量</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//最大值的索引</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//最小值的索引</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//打印输出</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//在末尾追加数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(ElementType e)</span></span>;</span><br><span class="line">        <span class="comment">//在指定下标的前面插入指定的数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos,ElementType e)</span></span>;</span><br><span class="line">        <span class="comment">//移除指定下标的数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line">        <span class="comment">//销毁</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">todestroy</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//按照指定规则排序，默认从小到大</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(charneirong rule=<span class="string">'&lt;'</span>)</span></span>;</span><br><span class="line">        <span class="comment">//合并两个动态数组，并且按照规则排序</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mergeAndsort</span><span class="params">(DynamicArray&amp;,<span class="keyword">char</span> rule)</span></span>;</span><br><span class="line">        <span class="comment">//对两个已经具有相同顺序的动态数组进行合并并且排序</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mergeAndsort_for_sorted</span><span class="params">(DynamicArray&amp;,DynamicArray&amp;,<span class="keyword">char</span> originrule,<span class="keyword">char</span> rule=<span class="string">'&lt;'</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dealOverflow</span><span class="params">()</span></span>;<span class="comment">//重新分配内存</span></span><br><span class="line">        ElementType* elems;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> capacity;</span><br><span class="line">    &#125;;<span class="comment">//注意类的定义的末尾需要有分号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="DynamicArray-cpp的内容"><a href="#DynamicArray-cpp的内容" class="headerlink" title="DynamicArray.cpp的内容"></a>DynamicArray.cpp的内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现文件</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DynamicArray.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> mydynamicarray&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    DynamicArray::DynamicArray()&#123;</span><br><span class="line">        elems=<span class="keyword">new</span> ElementType[INIT_CAPACITY];</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        capacity=INIT_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取长度</span></span><br><span class="line">    <span class="keyword">int</span> DynamicArray::getSize()&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取容量</span></span><br><span class="line">    <span class="keyword">int</span> DynamicArray::getCapacity()&#123;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">int</span> DynamicArray::max()&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            result=(elems[i]&gt;elems[i+<span class="number">1</span>])?i:i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="keyword">int</span> DynamicArray::min()&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            result=(elems[i]&lt;elems[i+<span class="number">1</span>])?i:i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">void</span> DynamicArray::print()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;elems[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理重新分配问题</span></span><br><span class="line">    <span class="keyword">void</span> DynamicArray::dealOverflow()&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&gt;=capacity)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            ElementType* newbase=(ElementType*)<span class="built_in">realloc</span>(elems,size+DELTA_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span>(newbase==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"重新分配内存失败！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            elems=newbase;</span><br><span class="line">            capacity+=DELTA_CAPACITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾部追加</span></span><br><span class="line">    <span class="keyword">void</span> DynamicArray::append(ElementType e)&#123;</span><br><span class="line">        dealOverflow();</span><br><span class="line">        elems[size]=e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在指定下表位置插入</span></span><br><span class="line">    <span class="keyword">void</span> DynamicArray::insert(<span class="keyword">int</span> pos,ElementType e)&#123;</span><br><span class="line">        dealOverflow();</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>||pos&gt;size)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"指定的位置不合法！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=size;i&gt;pos;i--)&#123;</span><br><span class="line">            elems[i]=elems[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        elems[i]=e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定下表的元素</span></span><br><span class="line">    <span class="keyword">void</span> DynamicArray::remove(<span class="keyword">int</span> pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>||pos&gt;size)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"指定的位置不合法！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=pos;i&lt;size;i++)&#123;</span><br><span class="line">            elems[i]=elems[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="keyword">void</span> DynamicArray::todestroy()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] elems;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        capacity=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> DynamicArray::sort(<span class="keyword">char</span> rule)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rule==<span class="string">'&lt;'</span>)&#123;<span class="comment">//从小到大排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(elems[i]&gt;elems[j])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp=elems[i];</span><br><span class="line">                        elems[i]=elems[j];</span><br><span class="line">                        elems[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rule==<span class="string">'&gt;'</span>)&#123;<span class="comment">//从大到小排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(elems[i]&lt;elems[j])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp=elems[i];</span><br><span class="line">                        elems[i]=elems[j];</span><br><span class="line">                        elems[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//rule参数输入错误</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入正确的排序规则('&lt;' or '&gt;')!!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> DynamicArray::mergeAndsort(DynamicArray&amp; dyArray,<span class="keyword">char</span> rule=<span class="string">'&lt;'</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dyArray.size;i++)&#123;</span><br><span class="line">            append(dyArray.elems[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁DA2,注意不能够两次释放，如果这里释放了，那么在其他的地方</span></span><br><span class="line">        <span class="comment">//不能再次释放</span></span><br><span class="line">        <span class="comment">// dyArray.todestroy();</span></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        sort(rule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对两个已经有序的动态数组进行合并排序</span></span><br><span class="line">    <span class="keyword">void</span> DynamicArray::mergeAndsort_for_sorted(DynamicArray&amp; DA2,DynamicArray&amp; DA3,<span class="keyword">char</span> originrule,<span class="keyword">char</span> rule)&#123;</span><br><span class="line">        <span class="keyword">if</span>(originrule==<span class="string">'&lt;'</span>&amp;&amp;rule==<span class="string">'&lt;'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i!=size&amp;&amp;j!=DA2.size)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(elems[i]&lt;DA2.elems[j])&#123;</span><br><span class="line">                        DA3.append(elems[i]);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(elems[i]==DA2.elems[j]) &#123;</span><br><span class="line">                        <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">                        DA3.append(elems[i]);</span><br><span class="line">                        i++;</span><br><span class="line">                        DA3.append(DA2.elems[j]);</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        DA3.append(DA2.elems[j]);</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(size==i)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;DA2.size)&#123;</span><br><span class="line">                       DA3.append(DA2.elems[j]);</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(DA2.size==j)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;size)&#123;</span><br><span class="line">                       DA3.append(elems[i]);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(originrule==<span class="string">'&gt;'</span>&amp;&amp;rule==<span class="string">'&gt;'</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(i!=size&amp;&amp;j!=DA2.size)&#123;</span><br><span class="line">               <span class="keyword">if</span>(elems[i]&lt;DA2.elems[j])&#123;</span><br><span class="line">                   DA3.append(DA2.elems[j]);</span><br><span class="line">                   j++;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(elems[i]==DA2.elems[j]) &#123;</span><br><span class="line">                   <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">                   DA3.append(elems[i]);</span><br><span class="line">                   i++;</span><br><span class="line">                   DA3.append(DA2.elems[j]);</span><br><span class="line">                   j++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   DA3.append(elems[i]);</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(size==i)&#123;</span><br><span class="line">               <span class="keyword">while</span>(j&lt;DA2.size)&#123;</span><br><span class="line">                  DA3.append(DA2.elems[j]);</span><br><span class="line">                   j++;</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(DA2.size==j)&#123;</span><br><span class="line">               <span class="keyword">while</span>(i&lt;size)&#123;</span><br><span class="line">                  DA3.append(elems[i]);</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(originrule==<span class="string">'&lt;'</span>&amp;&amp;rule==<span class="string">'&gt;'</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> i=size<span class="number">-1</span>,j=DA2.size<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">while</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(elems[i]&lt;DA2.elems[j])&#123;</span><br><span class="line">                   DA3.append(DA2.elems[j]);</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(elems[i]==DA2.elems[j]) &#123;</span><br><span class="line">                   <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">                   DA3.append(elems[i]);</span><br><span class="line">                   i--;</span><br><span class="line">                   DA3.append(DA2.elems[j]);</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   DA3.append(elems[i]);</span><br><span class="line">                   i--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(<span class="number">-1</span>==i)&#123;</span><br><span class="line">               <span class="keyword">while</span>(j!=<span class="number">-1</span>)&#123;</span><br><span class="line">                  DA3.append(DA2.elems[j]);</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">-1</span>==j)&#123;</span><br><span class="line">               <span class="keyword">while</span>(i!=<span class="number">-1</span>)&#123;</span><br><span class="line">                  DA3.append(elems[i]);</span><br><span class="line">                   i--;</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(originrule==<span class="string">'&gt;'</span>&amp;&amp;rule==<span class="string">'&lt;'</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> i=size<span class="number">-1</span>,j=DA2.size<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">while</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(elems[i]&lt;DA2.elems[j])&#123;</span><br><span class="line">                   DA3.append(elems[i]);</span><br><span class="line">                   i--;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(elems[i]==DA2.elems[j]) &#123;</span><br><span class="line">                   <span class="comment">//防止循环的最后一个相同的时候漏掉一个</span></span><br><span class="line">                   DA3.append(elems[i]);</span><br><span class="line">                   i--;</span><br><span class="line">                   DA3.append(DA2.elems[j]);</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   DA3.append(DA2.elems[j]);</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(<span class="number">-1</span>==i)&#123;</span><br><span class="line">               <span class="keyword">while</span>(j!=<span class="number">-1</span>)&#123;</span><br><span class="line">                  DA3.append(DA2.elems[j]);</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">-1</span>==j)&#123;</span><br><span class="line">               <span class="keyword">while</span>(i!=<span class="number">-1</span>)&#123;</span><br><span class="line">                  DA3.append(elems[i]);</span><br><span class="line">                   i--;</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"原始规则或指定的规则不正确"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-cpp-测试-的内容"><a href="#main-cpp-测试-的内容" class="headerlink" title="main.cpp(测试)的内容"></a>main.cpp(测试)的内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试文件</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DynamicArray.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mydynamicarray;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   DynamicArray array1=DynamicArray();</span><br><span class="line">   array1.append(<span class="number">1</span>);</span><br><span class="line">   array1.append(<span class="number">3</span>);</span><br><span class="line">   array1.append(<span class="number">2</span>);</span><br><span class="line">   array1.print();</span><br><span class="line">   array1.insert(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">   array1.insert(<span class="number">2</span>,<span class="number">200</span>);</span><br><span class="line">   array1.print();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">       array1.append(i);</span><br><span class="line">   &#125;</span><br><span class="line">   array1.print();</span><br><span class="line">   array1.sort(<span class="string">'&gt;'</span>);</span><br><span class="line">   array1.print();</span><br><span class="line">   array1.sort();</span><br><span class="line">   array1.print();</span><br><span class="line">   DynamicArray array2=DynamicArray();</span><br><span class="line">   array2.append(<span class="number">1000</span>);</span><br><span class="line">   array2.append(<span class="number">3000</span>);</span><br><span class="line">   array2.append(<span class="number">2000</span>);</span><br><span class="line">   array2.append(<span class="number">250</span>);</span><br><span class="line">   array2.append(<span class="number">9000</span>);</span><br><span class="line">   array2.sort();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;array2.getSize()&lt;&lt;<span class="string">"||||||||||||"</span>&lt;&lt;array2.getCapacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   array2.print();</span><br><span class="line">   array1.mergeAndsort(array2,<span class="string">'&lt;'</span>);</span><br><span class="line">   array1.print();</span><br><span class="line">   DynamicArray array3=DynamicArray();</span><br><span class="line">   array1.mergeAndsort_for_sorted(array2,array3,<span class="string">'&lt;'</span>);</span><br><span class="line">   array3.print();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;array3.max()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;array3.min()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   array1.todestroy();</span><br><span class="line">   array2.todestroy();</span><br><span class="line">   array3.todestroy();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main.exe:DynamicArray.o main.o</span><br><span class="line">    g++ -o main.exe DynamicArray.o main.o</span><br><span class="line">DynamicArray.o:DynamicArray.cpp DynamicArray.h</span><br><span class="line">    g++ -c DynamicArray.cpp DynamicArray.h</span><br><span class="line">main.o:main.cpp</span><br><span class="line">    g++ -c main.cpp</span><br><span class="line">clean:</span><br><span class="line">    rm main.exe main.o DynamicArray.o DynamicArray.h.gch</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vector in STL</title>
      <link href="/2017/09/26/Vector-in-STL/"/>
      <url>/2017/09/26/Vector-in-STL/</url>
      
        <content type="html"><![CDATA[<p>在c++的标准模板库中有许多模板容器，他们封装了底层的数据结构，并且可以用来装几乎所有的已有数据类型以及用户自定义的数据类型。vector(向量)就是其中一个非常好用的序列式的容器。vector是最简单的序列容器，支持元素的随机访问，当然有时候显得效率低一些。</p><h1 id="vector类基础"><a href="#vector类基础" class="headerlink" title="vector类基础"></a>vector类基础</h1><h2 id="vector对象定义"><a href="#vector对象定义" class="headerlink" title="vector对象定义"></a>vector对象定义</h2><p>vector对象定义之前需要使用std命名空间和vector这一个头文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myIntVec;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; myStrVec;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是定义了两个vector对象，一个是用来装int类型的数据，一个是用来装string类型的数据。</p><h2 id="vector类对象初始化"><a href="#vector类对象初始化" class="headerlink" title="vector类对象初始化"></a>vector类对象初始化</h2><p>vector对象的常用的初始化方法有以下几种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v1          <span class="comment">//v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2(v1)       <span class="comment">//v2中包含有v1所有元素的副本</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v2 = v1       <span class="comment">//等价于v2(v1)，v2中包含有v1所有元素的副本</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v3(n, val)      <span class="comment">//v3包含了n个重复的元素，每个元素的值都是val</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v4(n)          <span class="comment">//v4包含了n个重复地执行了值初始化的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5&#123;a,b,c...&#125;　<span class="comment">//v5包含了初始值个数的元素，每个元素被赋予相应的初始值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v5=&#123;a,b,c...&#125;　<span class="comment">//等价于v5&#123;a,b,c...&#125;</span></span><br></pre></td></tr></table></figure></p><p>vector对象在没有初始化之前不能够用赋值符号对其进行赋值，但是可以用push_back()成员函数对其赋值例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myIntVec;</span><br><span class="line">myIntVec[<span class="number">0</span>]=<span class="number">0</span>;  <span class="comment">//错误</span></span><br><span class="line">myIntVec.push_back(<span class="number">1</span>); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><h2 id="容器的大小和容量"><a href="#容器的大小和容量" class="headerlink" title="容器的大小和容量"></a>容器的大小和容量</h2><p>vector类定义了size()和capacity()两个函数来实现对当前容器元素的个数统计和对容器当前分配的内存数量的统计，同时也提供了reserve()和resize()两个成员函数来预先设置容器的大小和修改容器的大小。</p><h2 id="vector类的成员函数"><a href="#vector类的成员函数" class="headerlink" title="vector类的成员函数"></a>vector类的成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">myvec.push_back(<span class="number">1</span>);　<span class="comment">//向向量中推进去一个数</span></span><br><span class="line">myvec.pop_back();　　<span class="comment">//弹出（删除）向量末尾的元素</span></span><br><span class="line">myvec.empty() <span class="comment">//判断向量是否为空</span></span><br><span class="line">myvec.front()  <span class="comment">//获得向量中的第一个元素</span></span><br><span class="line">myvec.back()  <span class="comment">//获得向量中的最后一个元素</span></span><br><span class="line">myvec.clear() <span class="comment">//将容器清空</span></span><br><span class="line">myvec.at()   <span class="comment">//访问指定的下标的元素</span></span><br></pre></td></tr></table></figure><h2 id="遍历vector容器"><a href="#遍历vector容器" class="headerlink" title="遍历vector容器"></a>遍历vector容器</h2><p>遍历vector容器可以使用迭代器方式，也可以通过使用at()成员函数和循环语句实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器加for循环来遍历vector对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_iter</span><span class="params">(<span class="built_in">vector</span>&lt;TYPE&gt;&amp; myvec)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;TYPE&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter=myvec.begin();iter!=myvec.end();iter++)&#123;</span><br><span class="line">temp=*iter;</span><br><span class="line"><span class="comment">//do somnthing with temp here...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for循环加size()和at()成员函数来遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_at_size</span><span class="params">(<span class="built_in">vector</span>&lt;TYPE&gt;&amp; myvec)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myvec.size();i++)&#123;</span><br><span class="line">temp=myvec.at(i);</span><br><span class="line"><span class="comment">//do something with temp here...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用count-if算法和for-each算法操作vector对象"><a href="#使用count-if算法和for-each算法操作vector对象" class="headerlink" title="使用count_if算法和for_each算法操作vector对象"></a>使用<code>count_if</code>算法和<code>for_each</code>算法操作vector对象</h2><p><code>for_each</code>和<code>count_if</code>算法在algorithm头文件中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">if_bigger_than_3</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)&#123;</span><br><span class="line"><span class="comment">//定义并初始化含有是个元素的vector对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//for_each算法将指定区间的元素的引用逐一传递到print函数中</span></span><br><span class="line"><span class="comment">//被print函数中的形参x接收并执行</span></span><br><span class="line">for_each(myvec.begin(),myvec.end(),print);</span><br><span class="line"></span><br><span class="line"><span class="comment">//count_if算法将指定区间的元素的引用逐一传递到if_bigger_than_3函数中</span></span><br><span class="line"><span class="comment">//返回值为if_bigger_than_3中返回true的次数</span></span><br><span class="line"><span class="keyword">auto</span> count=count_if(myvec.begin(),myvec.end(),if_bigger_than_3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="vector高级主题"><a href="#vector高级主题" class="headerlink" title="vector高级主题"></a>vector高级主题</h1><h2 id="元素访问方法"><a href="#元素访问方法" class="headerlink" title="元素访问方法"></a>元素访问方法</h2><p>可以直接访问vector对象的操作方法主要包括以下４中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;MyType&gt; myvector;</span><br><span class="line">myvector[index];</span><br><span class="line">myvector.at(index);</span><br><span class="line">myvector.front();</span><br><span class="line">myvector.back();</span><br></pre></td></tr></table></figure></p><p>myvector[index]和myvector.at(index)两种访问方式返回的都是对象的引用类型，所以既可以取其中的元素，也可以对其赋值。前提是下标值必须有效。front()和back()分别返回第一个元素和最后一个元素。</p><h2 id="迭代器相关函数"><a href="#迭代器相关函数" class="headerlink" title="迭代器相关函数"></a>迭代器相关函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvect=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//返回值类型均为迭代器类型，分别指向第一个元素和最后一个元素的下一个元素</span></span><br><span class="line">myvect.begin();</span><br><span class="line">myvect.end();</span><br><span class="line"><span class="comment">//返回值类型均为逆向迭代器类型，分别指向逆向迭代的第一个元素和逆向迭代的最后一个元素的下一个元素</span></span><br><span class="line">myvect.rbegin();</span><br><span class="line">myvect.rend();</span><br></pre></td></tr></table></figure><h2 id="元素查找和搜索"><a href="#元素查找和搜索" class="headerlink" title="元素查找和搜索"></a>元素查找和搜索</h2><p>STL通用算法find()和find_if()</p><h2 id="容器中元素的排序"><a href="#容器中元素的排序" class="headerlink" title="容器中元素的排序"></a>容器中元素的排序</h2><p>sort算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_by_score</span><span class="params">(Student&amp; s1,Student&amp; s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.score&gt;s2.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Student &amp; s)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.name&lt;&lt;<span class="string">":"</span>&lt;&lt;s.score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; myvec=&#123;&#123;<span class="number">25</span>,<span class="string">"mary"</span>&#125;,&#123;<span class="number">35</span>,<span class="string">"jack"</span>&#125;,&#123;<span class="number">10</span>,<span class="string">"Lily"</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序前："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">for_each(myvec.begin(),myvec.end(),print);</span><br><span class="line">sort(myvec.begin(),myvec.end(),sort_by_score);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">for_each(myvec.begin(),myvec.end(),print);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面程序的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">排序前：</span><br><span class="line">mary:25</span><br><span class="line">jack:35</span><br><span class="line">Lily:10</span><br><span class="line">排序后：</span><br><span class="line">jack:35</span><br><span class="line">mary:25</span><br><span class="line">Lily:10</span><br></pre></td></tr></table></figure></p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>push_back()可以在vector对象的末尾插入元素，insert()函数可以在vector的任意位置插入元素。下面看演示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;myIntvec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//在开始位置前面插入０</span></span><br><span class="line">    myIntvec.insert(myIntvec.begin(),<span class="number">0</span>);</span><br><span class="line">    for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//在末尾位置前面插入０</span></span><br><span class="line">     myIntvec.insert(myIntvec.end(),<span class="number">0</span>);</span><br><span class="line">     for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//创建一个新向量</span></span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;myIntvec2;</span><br><span class="line">     <span class="comment">//用push_back()依次向末尾添加数据</span></span><br><span class="line">     myIntvec2.push_back(<span class="number">6</span>);</span><br><span class="line">     myIntvec2.push_back(<span class="number">5</span>);</span><br><span class="line">     myIntvec2.push_back(<span class="number">2</span>);</span><br><span class="line">     for_each(myIntvec2.begin(),myIntvec2.end(),print);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//用pop_back()依次从末尾移除数据</span></span><br><span class="line">     myIntvec2.pop_back();</span><br><span class="line">     for_each(myIntvec2.begin(),myIntvec2.end(),print);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//将myIntvec2中的全部元素插入到myIntvec的开始元素的前面</span></span><br><span class="line">     myIntvec.insert(myIntvec.begin(),myIntvec2.begin(),myIntvec2.end());</span><br><span class="line">     for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//插入多个相同的值,这里是在myIntvec的开始元素的前面插入两个５</span></span><br><span class="line">     myIntvec.insert(myIntvec.begin(),<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">     for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7</span><br><span class="line">0 1 2 3 4 5 6 7</span><br><span class="line">0 1 2 3 4 5 6 7 0</span><br><span class="line">6 5 2</span><br><span class="line">6 5</span><br><span class="line">6 5 0 1 2 3 4 5 6 7 0</span><br><span class="line">5 5 6 5 0 1 2 3 4 5 6 7 0</span><br></pre></td></tr></table></figure></p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>在vector删除元素可以使用３个成员函数：pop_back(),erase(),和clear().还可以使用算法库的算法remove()来实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;myIntvec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    myIntVec.erase(myIntVec.begin());</span><br><span class="line">    for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    myIntVec.clear();</span><br><span class="line">    for_each(myIntvec.begin(),myIntvec.end(),print);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7</span><br><span class="line">2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL Vector </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>构建镜像</title>
      <link href="/2017/09/25/Build-your-own-images/"/>
      <url>/2017/09/25/Build-your-own-images/</url>
      
        <content type="html"><![CDATA[<p>构建docker镜像可以让我们保存对容器的修改并且可以再次使用，提供了自定义镜像的能力，使我们可以以软件的形式打包并分发服务及其运行环境.</p><h1 id="通过容器构建镜像"><a href="#通过容器构建镜像" class="headerlink" title="通过容器构建镜像"></a>通过容器构建镜像</h1><p>可以通过docker的commit子命令基于一个容器创建一个新的镜像。</p><h2 id="commit命令"><a href="#commit命令" class="headerlink" title="commit命令"></a>commit命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h2><table><thead><tr><th style="text-align:center">OPTIONS</th><th style="text-align:center">USAGES</th></tr></thead><tbody><tr><td style="text-align:center">-a,–author</td><td style="text-align:center">指定镜像的作者的信息(通常是作者的名字以及联系方式)</td></tr><tr><td style="text-align:center">-m,–message</td><td style="text-align:center">记录信息，一般记录改变的信息</td></tr><tr><td style="text-align:center">-p,–pause</td><td style="text-align:center">是否停止容器</td></tr><tr><td style="text-align:center">-c,–change</td><td style="text-align:center">使用dockerfile的指令来配置生成的镜像</td></tr></tbody></table><p>-c,–change选项是通过Dockerfile指令配置即将生成的镜像，支持的dockerfile指令有：CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR</p><h2 id="官网上的例子"><a href="#官网上的例子" class="headerlink" title="官网上的例子"></a>官网上的例子</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS              NAMES</span><br><span class="line">c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours                            desperate_dubinsky</span><br><span class="line">197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours                            focused_hamilton</span><br><span class="line">$ docker commit c3f279d17e0a  svendowideit/testimage:version3</span><br><span class="line">f5283438590d</span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY                        TAG                 ID                  CREATED             SIZE</span><br><span class="line">svendowideit/testimage            version3            f5283438590d        16 seconds ago      335.7 MB</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID       IMAGE               COMMAND             CREATED             STATUS              PORTS              NAMES</span><br><span class="line">c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours                            desperate_dubinsky</span><br><span class="line">197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours                            focused_hamilton</span><br><span class="line">$ docker inspect -f <span class="string">"&#123;&#123; .Config.Env &#125;&#125;"</span> c3f279d17e0a</span><br><span class="line">[HOME=/ PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin]</span><br><span class="line">$ docker commit --change <span class="string">"ENV DEBUG true"</span> c3f279d17e0a  svendowideit/testimage:version3</span><br><span class="line">f5283438590d</span><br><span class="line">$ docker inspect -f <span class="string">"&#123;&#123; .Config.Env &#125;&#125;"</span> f5283438590d</span><br><span class="line">[HOME=/ PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin DEBUG=<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS              NAMES</span><br><span class="line">c3f279d17e0a        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours                            desperate_dubinsky</span><br><span class="line">197387f1b436        ubuntu:12.04        /bin/bash           7 days ago          Up 25 hours                            focused_hamilton</span><br><span class="line">$ docker commit --change=<span class="string">'CMD ["apachectl", "-DFOREGROUND"]'</span> -c <span class="string">"EXPOSE 80"</span> c3f279d17e0a  svendowideit/testimage:version4</span><br><span class="line">f5283438590d</span><br><span class="line">$ docker run -d svendowideit/testimage:version4</span><br><span class="line">89373736e2e7f00bc149bd783073ac43d0507da250e999f3f1036e0db60817c0</span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS              NAMES</span><br><span class="line">89373736e2e7        testimage:version4  <span class="string">"apachectl -DFOREGROU"</span>  3 seconds ago       Up 2 seconds        80/tcp             distracted_fermat</span><br><span class="line">c3f279d17e0a        ubuntu:12.04        /bin/bash               7 days ago          Up 25 hours                            desperate_dubinsky</span><br><span class="line">197387f1b436        ubuntu:12.04        /bin/bash               7 days ago          Up 25 hours                            focused_hamilton</span><br></pre></td></tr></table></figure><p>事实上，官方不建议通过commit方式来创建新的镜像，这种创建方式是不透明的，你对新镜像做的操作无法记录下来，官方推荐的方式是使用 dockerfile创建镜像。</p><h1 id="通过Dockerfile文件构建镜像"><a href="#通过Dockerfile文件构建镜像" class="headerlink" title="通过Dockerfile文件构建镜像"></a>通过Dockerfile文件构建镜像</h1><h2 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h2><p>Dockerfile是包含了一系列命令的文本文件。就像下面这样：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#First Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> Ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> penname  hfsjhdss@outlook.com </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="bash">RUN apt-get install –y nginx</span></span><br><span class="line"><span class="bash">EXPOSE 80</span></span><br></pre></td></tr></table></figure></p><p>下面我们在桌面创建一个文件夹Test，在里面创建一个名为Dockerfile的文件，文件中的内容就是上面的例子中的内容。<br>然后使用$ docker build命令来开启镜像的创建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build –t=<span class="string">"myfirstdockerfileimage"</span> .</span><br></pre></td></tr></table></figure></p><p>上面这条命令的意思是根据当前目录中的Dockerfile文件创建一个名为myfirstdockerfileimage的新镜像。当命令执行完毕之后，我们就可以使用docker images命令查看到我们新创建的镜像了。注意这条命令的最后一个选项是一个点，表示的是当前目录。下面我就详细的介绍一下Dockerfile文件各个指令的使用，以及docker的build子命令的使用和注意事项。</p><h2 id="Dockerfile主要指令"><a href="#Dockerfile主要指令" class="headerlink" title="Dockerfile主要指令"></a>Dockerfile主要指令</h2><p>Dockerfile支持两种指令格式：注释和指令。注释是以#开头，后面是注释信息。指令是大写的指令名开头，后面是指令的参数。下面我们来看一下Dockerfile中的各个指令。</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>通过FROM指令指定基础镜像。该镜像名必须是一个已经存在于本地的镜像。FROM必须是Dockerfile中第一条非注释指令，后续指令都是基于这个基础镜像执行。在Docker Hub上有非常多的高质量的官方镜像， 有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等； 也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。 可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 RUN 指令就是这种格式。<br>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。<br>既然 RUN 就像Shell脚本一样可以执行命令，那么我们是否就可以像Shell脚本一样把每个命令对应一个RUN呢？比如这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="bash">RUN apt-get install -y gcc libc6-dev make</span></span><br><span class="line"><span class="bash">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span></span></span><br><span class="line"><span class="bash">RUN mkdir -p /usr/src/redis</span></span><br><span class="line"><span class="bash">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="bash">RUN make -C /usr/src/redis</span></span><br><span class="line"><span class="bash">RUN make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。<br>上面的 Dockerfile 正确的写法应该是这样：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure></p><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>指定运行该镜像的容器使用的端口，可以一个expose后面跟多个端口，也可以使用多个expose:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">EXPOSE 80 8080</span><br></pre></td></tr></table></figure><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD[“executable”,”param1”,”param2”] (<span class="built_in">exec</span>模式)</span><br><span class="line">CMD <span class="built_in">command</span> param1 param2 (shell模式)</span><br><span class="line">CMD [“param1”,”param2”] (作为ENTRYPOINT指令的默认参数)</span><br></pre></td></tr></table></figure><p>RUN指令指定的命令是在镜像构建时运行的，而CMD指定的命令是在容器运行时运行的，并且，如果我们在使用run来启动镜像对应的容器的时候，如果指定了容器启动运行的命令的话，CMD指令指定的命令将会被重写覆盖，而不会被执行，也就是说CMD指令是指定容器运行的默认行为．注意每个Dockerfile只能有一条CMD指令，如果指定了多条，则只有最后一条执行。</p><h3 id="ENTERYPOINT"><a href="#ENTERYPOINT" class="headerlink" title="ENTERYPOINT"></a>ENTERYPOINT</h3><p>同CMD指令一样，ENTRYPOINT指令也有exec和shell两种模式。在功能上，二者也很相似，两者的区别就是，ENTRYPOINT指令所指定的命令不会被docker run命令中指定的启动命令所覆盖，如果要覆盖，就需要在docker run命令中指定entrypoint选项，即:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run –entrypoint……..</span><br></pre></td></tr></table></figure><h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE"></a>LABLE</h3><p>LABLE标签用来指定生成镜像的元数据标签信息，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABLE version=<span class="string">"1.0"</span> description=<span class="string">"this is a short description"</span></span><br></pre></td></tr></table></figure><p>注意以前的表示作者信息的MAINTAINER指令已经被废弃，官方建议使用LABLE代替。</p><h3 id="COPY-ADD"><a href="#COPY-ADD" class="headerlink" title="COPY/ADD"></a>COPY/ADD</h3><p>ADD和COPY都是将文件和目录复制到使用dockerfile构建的镜像中，他们都支持两种参数，来源地址和目标地址。文件和目录的来源可以是本地地址，也可以是远程url。如果是本地地址，必须是构建目录中的相对地址，对于远程的，对于远程的url，docker并不推荐使用，更建议使用curl和wget之类的命令来获取文件。而目标路径需要指定镜像中的绝对路径。<br>这两个指令的区别：<br>ADD包含类似tar的解压功能，在一些安装tar软件包时会有所帮助。如果单纯复制文件，docker推荐使用COPY.。<br>例如：COPY inde.html /usr/share/nginx/html/ 把宿主机中与dockerfile同级目录下的index.html复制到镜像的/usr/share/nginx/html/下</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>用来向基于镜像创建的容器添加卷，一个卷是可以存在一个或多个容器的特定目录，这个目录可以绕过联合文件系统，并提供如共享数据，对数据持久化的功能.</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>用来从镜像创建一个新容器时，在容器内部设置工作目录，ENTRYPOINT和CMD指定的命令都会在这个目录下执行。我们也可以使用这个指令在构建中为后续的指令指定工作目录，需要注意的是：WORKDIR一般使用绝对路径，如果使用相对路径，那么工作路径会一直传递下去，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>结果为 /a/b/c</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>这个指令用于设置环境变量，环境变量的指令可以作用于构建过程中，在运行过程中同样有效。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定镜像被什么样的用户去运行</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>可以为构建出来镜像添加触发器，当该镜像被其他镜像作为基础镜像时就会执行，及插入触发器中的指令</p><h2 id="基于Dockerfile构建镜像"><a href="#基于Dockerfile构建镜像" class="headerlink" title="基于Dockerfile构建镜像"></a>基于Dockerfile构建镜像</h2><p>编写完成Dockerfile之后，可以通过docker build命令来创建镜像，该命令基本的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build [OPTIONS] 上下文路径</span><br></pre></td></tr></table></figure><h3 id="常用选项："><a href="#常用选项：" class="headerlink" title="常用选项："></a>常用选项：</h3><table><thead><tr><th style="text-align:center">OPTIONS</th><th style="text-align:center">USAGES</th></tr></thead><tbody><tr><td style="text-align:center">-t 　　　</td><td style="text-align:center">　    指定最终生成的镜像的名称</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:center">如果使用非上下文路径下的Dockerfile，那么需要-f选项指定其路径</td></tr></tbody></table><p>该命令会读取上下文路径下包括其子目录中的Dockerfile（或者是-f指定位置的Dockerfile）,并且将上下文路径下的内容发送给Docker服务端，由服务端来创建镜像。服务端会依据Dockerfile中的指令，从基础镜像开始运行一个容器,执行一条指令，对容器做出修改,执行类似于docker commit的操作，提交一个新的镜像层,再居于刚才提交的镜像运行一个新容器,执行Dockerfile中的下一条指令，直至所有的指令执行完毕。在根据Dockerfile构建镜像的过程中，会生成中间层镜像及其对应的容器，在这一过程中docker会自动删除生成的容器，而没有删除中间层镜像。这其实给了我们调试的能力，我们可以通过运行中间层镜像，来调试。</p><h3 id="上下文-Context-是什么鬼？"><a href="#上下文-Context-是什么鬼？" class="headerlink" title="上下文(Context)是什么鬼？"></a>上下文(Context)是什么鬼？</h3><p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？<br>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。<br>如果在 Dockerfile 中这么写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... dockerfile</span><br><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure></p><p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>如果观察 docker build 输出，我们其实可以看到了这个发送上下文的过程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myimage .</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 2.048 kB</span><br></pre></td></tr></table></figure></p><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p><p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p><h3 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h3><p>由于每一步的构建过程都会将结果提交为镜像，docker会将之前的镜像看做缓存，如果我们再次运行下之前已经运行过的dockerfile的build命令，我们会发现，我们不会再次经历像第一次执行那样的长时间的等待，并且这一次运行的每一步都有Using cache的字样。这样就使我们的构建变得非常高效。但有时我们并不想使用缓存，如构建命令中包含apt-get update命令时，我们希望每次apt-get包都能刷新，这样就可以得到最新的版本。如果要跳过构建缓存，可以使用docker build –no-cache….即docker build命令中的—no-cache选项。</p><h3 id="查看镜像构建过程"><a href="#查看镜像构建过程" class="headerlink" title="查看镜像构建过程"></a>查看镜像构建过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> [image]</span><br></pre></td></tr></table></figure><p>对于一个给定的镜像，我们可以通过上面的命令来查看其构建过程</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker网络管理</title>
      <link href="/2017/09/20/Network-management-of-Docker/"/>
      <url>/2017/09/20/Network-management-of-Docker/</url>
      
        <content type="html"><![CDATA[<p>在实践中，经常需要多个服务组件容器之间共同协作，这往往需要多个容器之间能够相互访问到对方的服务。同时，为了容器的安全有时我们也要避免容器之间的访问。</p><h1 id="容器与用户的连接"><a href="#容器与用户的连接" class="headerlink" title="容器与用户的连接"></a>容器与用户的连接</h1><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>要想外部用户访问到服务器主机中容器中的服务，那么就要把提供服务的容器的端口映射到服务器主机的端口上。这样用户访问服务器主机的对应端口就可以访问到容器中的服务了。这是通过run命令的两个选项实现的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run [-p]|[-P]………</span><br><span class="line">-P –publish-all=ture|<span class="literal">false</span> 默认为<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>用大写的P将会对容器所暴露的所有的端口进行映射,命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –P -i –t IMAGE [COMMAND] [ARG…]</span><br></pre></td></tr></table></figure></p><p>这会将镜像所暴露的端口随机映射到49000~49900的端口。</p><p>用小写的p时我们可以指定映射那些端口，对映射关系进行详细操作，总共有4种指定的方式：</p><p>containerPort只指定需要映射的容器的端口，将他随机映射到一个宿主机的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –p 80 –i –t Ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>hostport:containerport两者皆指定，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –p 8080:80 –i –t Ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>ip:containerport</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –p 0.0.0.0:80 –I –t Ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>ip:hostport:containerport</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –p 0.0.0.0:8080:80 –I –t Ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>这样我们就可以通过docker的ps,inspect子命令查看到端口映射的情况了。</p><h1 id="容器与容器之间的互联"><a href="#容器与容器之间的互联" class="headerlink" title="容器与容器之间的互联"></a>容器与容器之间的互联</h1><p>首先，无论是同一台主机上的容器之间，还是跨主机的容器之间都可以通过访问对方容器所在的主机的映射的端口访问到对方容器的服务。</p><h2 id="同一台主机上的容器的互联"><a href="#同一台主机上的容器的互联" class="headerlink" title="同一台主机上的容器的互联"></a>同一台主机上的容器的互联</h2><h3 id="通过ip-端口互联"><a href="#通过ip-端口互联" class="headerlink" title="通过ip+端口互联"></a>通过ip+端口互联</h3><p>容器有自己的网络和ip地址，使用docker inspect＋容器ID就可以查看到相关信息。默认情况之下，在同一台物理主机中的容器之间可以通过对方容器的ip和端口访问到对方的服务。但是这样有一个弊端：随着容器的停止与启动，容器的ip可能会发生变化。这就意味着每一次你重启了集群中的一个容器，你就必须要查看这个启动的容器新的ip，然后更改访问这个容器中服务的容器的配置。这显然太麻烦了。好在docker为我们提供了更加稳定可靠的方式来维护容器的连通。那就是：docker run的–link选项，</p><h3 id="容器名便捷互访"><a href="#容器名便捷互访" class="headerlink" title="容器名便捷互访"></a>容器名便捷互访</h3><h4 id="自定义容器名"><a href="#自定义容器名" class="headerlink" title="自定义容器名"></a>自定义容器名</h4><p>虽然镜像启动后，容器会自动获得一个随机的容器名，但是为了方便和易记，我们往往会为容器自定义一个名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name myname ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>如上，通过–name参数来指定容器的名称为myname.</p><h4 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h4><p>使用–link参数能够让容器之间安全的进行交互。比如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name db mysql</span><br></pre></td></tr></table></figure></p><p>上面我们以mysql镜像创建了名为db的容器，下面我们就让我们的应用程序容器与它链接起来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd -P --name myweb --link db:mydb ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>如上，我们以ubuntu镜像创建了一个名为myweb的容器，它通过–link参数与上面的db容器建立了容器名互访连接的关系，他在myweb容器中将被称之为mydb.<br>注意–link参数的格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... --link &lt;CONTAINER_NAME&gt;:&lt;ALIAS&gt; ...</span><br></pre></td></tr></table></figure></p><p>CONTAINER_NAME是所要链接的容器名，ALIAS是在容器中使用的所要链接容器的别名.<br>下面我们就可以在myweb容器中执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping mydb</span><br></pre></td></tr></table></figure><p>可以发现可以顺利ping通。假如db容器的80端口还提供了静态网站服务，那么在myweb容器中可以通过如下命令访问到这一服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl mydb:80</span><br></pre></td></tr></table></figure><p>注意：ping和curl这两个命令可能在容器中并没有安装，所以要先安装后才可以使用。<br>之后无论你怎样重启容器，只要对方容器还在运行，你就可以通过这种方式在源容器中访问到目标容器。</p><h1 id="高级网络管理"><a href="#高级网络管理" class="headerlink" title="高级网络管理"></a>高级网络管理</h1><h2 id="docker自带的网络"><a href="#docker自带的网络" class="headerlink" title="docker自带的网络"></a>docker自带的网络</h2><p>当我们安装docker的时候，会自动创建三个网络，我们可以使用下面的命令来查看主机中当前存在的网络：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">5a0d02e77f3c        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">8349004e42e8        host                host                <span class="built_in">local</span></span><br><span class="line">92e7ec631cff        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>NETWORK ID列是对应网络的唯一ID。NAME列是对应网络的名字。DRIVER是对应网络所使用的驱动。SCOPE是当前网络的作用域，这里的local说明当前网络作用域为本地。<br>上面的bridge,host,none就是docker安装时自动创建的三个网络。</p><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>bridge网络是docker容器默认使用的网络，除非在容器启动时显式的指定使用其他网络，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name ct1 ubuntu</span><br><span class="line">$ docker run -itd --name ct2 --network host ubuntu</span><br></pre></td></tr></table></figure></p><p>上面的两条命令用ubuntu镜像分别启动了两个容器ct1,ct2.其中ct1在默认的bridge网络中，ct2在我们指定的host网络中。可以通过docker inspect ct1和docker inspect ct2来查看当前容器所属的网络：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect ct1</span><br></pre></td></tr></table></figure></p><p>部分输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Networks"</span>: &#123;   </span><br><span class="line">                <span class="string">"bridge"</span>: &#123;</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: null,</span><br><span class="line">                    <span class="string">"Links"</span>: null,</span><br><span class="line">                    <span class="string">"Aliases"</span>: null,</span><br><span class="line">                    <span class="string">"NetworkID"</span>: <span class="string">"5a0d02e77f3c89ec59b9432be752a35f6cc28c260022398751495ee563809570"</span>,</span><br><span class="line">                    <span class="string">"EndpointID"</span>: <span class="string">"a60ca83c9da616064ca9fa112f80a05549bc2ff408483381979b6921bdba46ef"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.2"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">                    <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>对ct2执行同样的命令，同一部分的输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Networks"</span>: &#123;</span><br><span class="line">                <span class="string">"host"</span>: &#123;</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: null,</span><br><span class="line">                    <span class="string">"Links"</span>: null,</span><br><span class="line">                    <span class="string">"Aliases"</span>: null,</span><br><span class="line">                    <span class="string">"NetworkID"</span>: <span class="string">"8349004e42e8dda028d04b62a19df90ecf9655409ad0f1e8847a70f5b49fdd1f"</span>,</span><br><span class="line">                    <span class="string">"EndpointID"</span>: <span class="string">"f3f957ca950edc0c12ab94e57d72d0799c8287ee638179ba63349cc87f27731e"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"MacAddress"</span>: <span class="string">""</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>由上可见，确实ct1,ct2两个容器分属于不同的网络。<br>bridge网络的底层就是docker0这一虚拟网络设备，当容器运行在bridge网络中时，docker的守护进程就是通过docker0来链接到这些容器的，并且这些容器支持通过ip来访问对方。其实在你安装docker以后，docker0这一网络设备就已经成为你的主机的网络栈的一部分。你可以通过如下命令查看到docker0:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show</span><br></pre></td></tr></table></figure><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>运行在host网络中的容器，在网络方面与宿主机之间没有隔离，不用做端口映射，外界通过访问主机ip加对应端口访问到容器中的服务。直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，Docker host 上已经使用的端口就不能再用了。Docker host 的另一个用途是让容器可以直接配置 host 网路。比如某些跨 host 的网络解决方案，其本身也是以容器方式运行的，这些方案需要对网络进行配置，比如管理 iptables。</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>故名思议，none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。封闭意味着隔离，一些对安全性要求高并且不需要联网的应用可以使用 none 网络。比如某个容器的唯一用途是生成随机密码，就可以放到 none 网络中避免密码被窃取。</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><p>在实践中使用最多的网络是默认的bridge网络，其实我们还可以自定义网络：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create --driver bridge mynetwork</span><br></pre></td></tr></table></figure></p><p>如上我以bridge为驱动创建了一个自定义网络mynetwork,我们可以通过下面的命令查看当前主机中的网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br></pre></td></tr></table></figure><p>这时我们就可以发现除了docker自带的bridge,none,host三种网络之外，我们的自定义网络mynetwork也出现在输出中。</p><h3 id="使用自定义网络运行容器"><a href="#使用自定义网络运行容器" class="headerlink" title="使用自定义网络运行容器"></a>使用自定义网络运行容器</h3><p>下面我们使用默认的bridge运行ct1,ct2,使用我们的自定义网络再运行起来一个ct3容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name ct1 ubuntu</span><br><span class="line">$ docker run -d --name ct2 ubuntu</span><br><span class="line">$ docker run -d --name ct3 --network mynetwork ubuntu</span><br></pre></td></tr></table></figure><p>这样我们就得到了两个运行在bridge网络中的容器ct1,ct2，和一个运行在我自定义的网络mynetwork中的ct3.（可以使用docker inspect命令在Networks一项中查看到容器所属于的网络）</p><h3 id="不同网络中容器的互访"><a href="#不同网络中容器的互访" class="headerlink" title="不同网络中容器的互访"></a>不同网络中容器的互访</h3><p>我们可以在ct1,ct2,ct3中相互的ping对方，可以发现位于默认bridge网络中的ct1,ct2可以相互的ping通，但是，ct1,ct2和位于mynetwork中的ct3确无法ping通。这就说明在相同网络中的容器可以通过ip相互访问，但是跨网络则不行。那如果需要不同网络中的容器能够相互访问怎么办呢？可以使用下面的命令实现将某一个容器加入某一个网络中，那么这个容器就可以访问都该网络中的容器了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network connect mynetwork ct2</span><br></pre></td></tr></table></figure><p>如上，我们通过上述命令将ct2加入到了mynetwork网络中，这时我们可以查看一下ct2所属于的网络：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect ct2</span><br></pre></td></tr></table></figure></p><p>部分输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Networks"</span>: &#123;</span><br><span class="line">                <span class="string">"bridge"</span>: &#123;</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: null,</span><br><span class="line">                    <span class="string">"Links"</span>: null,</span><br><span class="line">                    <span class="string">"Aliases"</span>: null,</span><br><span class="line">                    <span class="string">"NetworkID"</span>: <span class="string">"5a0d02e77f3c89ec59b9432be752a35f6cc28c260022398751495ee563809570"</span>,</span><br><span class="line">                    <span class="string">"EndpointID"</span>: <span class="string">"b138dd2a40e7e194fd3c055c78dc4db6778b80c767fbe32a68096507ac039fa5"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.3"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">                    <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:03"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"mynetwork"</span>: &#123;</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: &#123;&#125;,</span><br><span class="line">                    <span class="string">"Links"</span>: null,</span><br><span class="line">                    <span class="string">"Aliases"</span>: [</span><br><span class="line">                        <span class="string">"455c3ec1534d"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="string">"NetworkID"</span>: <span class="string">"69d07788867935f590056da4d1c60591ca5459029715029e30c54f440b59b968"</span>,</span><br><span class="line">                    <span class="string">"EndpointID"</span>: <span class="string">"afda2df82f371f3022e367e9b806c479d6ba06f5b6888b90c4bdcf2d48fffc8d"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.18.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.18.0.3"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">                    <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:12:00:03"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>可见，ct2现在既属于bridge网络，又属于mynetwork网络。并且在bridge网络和在mynetwork网络中的ip不相同。在ct3中要访问ct2那么就需要使用ct2在mynetwork中的ip，同理要在ct1中访问ct2则要使用ct2在bridge网络中的ip.</p><h3 id="查看某一网络中的容器"><a href="#查看某一网络中的容器" class="headerlink" title="查看某一网络中的容器"></a>查看某一网络中的容器</h3><p>我们可以通过命令来查看某一网络中的所有的容器，如下我们查看bridge网络中的所有容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network inspect bridge</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"5a0d02e77f3c89ec59b9432be752a35f6cc28c260022398751495ee563809570"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-09-19T20:50:37.834660229+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: null,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.17.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"455c3ec1534dde68712fbb441e8fa97ed830430595d92a15ec7cbee801d22e39"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"ct2"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"b138dd2a40e7e194fd3c055c78dc4db6778b80c767fbe32a68096507ac039fa5"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:03"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"172.17.0.3/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"7b7063b9630d7945415063cf2dd0275414cb32cf5622c77ac27b96a10903ae57"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"ct1"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"111c9a1c47272f854457530fb8ee077947728144b3191b80c15e6223e865a9e5"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"172.17.0.2/16"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;</span><br><span class="line">            <span class="string">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,</span><br><span class="line">            <span class="string">"com.docker.network.driver.mtu"</span>: <span class="string">"1500"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从Containers一项中我们可以发现目前在bridge网络中的容器为ct1和ct2,这和目前的实际状况是一致的。</p><h3 id="容器退出某一网络"><a href="#容器退出某一网络" class="headerlink" title="容器退出某一网络"></a>容器退出某一网络</h3><p>我们也可以使一个容器退出某一网络，比如现在使ct2退出bridge:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network disconnect bridge ct2</span><br></pre></td></tr></table></figure><p>这时我们再次查看ct2的所属的网络就只有mynetwork了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect ct2</span><br></pre></td></tr></table></figure><p>部分输出;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Networks"</span>: &#123;</span><br><span class="line">                <span class="string">"mynetwork"</span>: &#123;</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: &#123;&#125;,</span><br><span class="line">                    <span class="string">"Links"</span>: null,</span><br><span class="line">                    <span class="string">"Aliases"</span>: [</span><br><span class="line">                        <span class="string">"455c3ec1534d"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="string">"NetworkID"</span>: <span class="string">"69d07788867935f590056da4d1c60591ca5459029715029e30c54f440b59b968"</span>,</span><br><span class="line">                    <span class="string">"EndpointID"</span>: <span class="string">"afda2df82f371f3022e367e9b806c479d6ba06f5b6888b90c4bdcf2d48fffc8d"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.18.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.18.0.3"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">                    <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:12:00:03"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network in Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker数据管理</title>
      <link href="/2017/09/20/Data-manage-in-Docker/"/>
      <url>/2017/09/20/Data-manage-in-Docker/</url>
      
        <content type="html"><![CDATA[<p>生产环境中使用docker，往往需要对数据进行持久化，或者在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。容器中管理数据主要有两种方式：</p><ul><li>数据卷</li><li>数据卷容器</li></ul><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><h2 id="什么是数据卷？"><a href="#什么是数据卷？" class="headerlink" title="什么是数据卷？"></a>什么是数据卷？</h2><p>数据卷是经过特殊设计的目录，可以绕过联合文件系统，为一个或多个容器提供访问。数据卷设计的目的，在于数据的永久化，它完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷，也不会存在垃圾收集机制，对容器引用的数据卷进行处理.</p><p><img src="/images/datavolume.jpg" alt="数据卷示意图"></p><p>上图可以告诉我们：</p><ul><li>docker的数据卷是独立于docker的存在，他存在于dockerhost也就是宿主机中，因此他与docker容器的生存周期是分离的。</li><li>docker数据卷本质上是存在于docker宿主机的文件系统中</li><li>docker数据卷可以是目录也可以是文件</li><li>docker容器可以利用数据卷的技术与宿主机进行数据共享</li><li>同一个目录或文件可以支持多个容器的访问，这样其实实现了容器间数据的共享和交换。</li></ul><h2 id="数据卷的特点"><a href="#数据卷的特点" class="headerlink" title="数据卷的特点"></a>数据卷的特点</h2><ul><li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会可拷贝到新初始化的数据卷中。</li><li>数据卷可以在容器之间共享和重用</li><li>可以对数据卷中的内容直接进行修改</li><li>数据卷的变化不会影响镜像的更新</li><li>卷会一直存在，即使挂载数据卷的容器已经删除</li></ul><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><h3 id="docker-volume子命令"><a href="#docker-volume子命令" class="headerlink" title="docker volume子命令"></a>docker volume子命令</h3><p>docker 1.9引入了新的子命令docker volume,用户可以使用这个命令创建查看和删除数据卷，与此同时，传统的-v参数创建volume的方式也得到了保留。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Usage:docker volume COMMAND</span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">help</span>   Print usage</span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure></p><p>创建<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create --name volume1</span><br></pre></td></tr></table></figure></p><p>在用户使用docker创建volume的时候，采用的是默认的local volumedriver,所以volume的文件系统默认使用宿主机的文件系统，如果用户需要创建其他文件系统的volume，则需要使用其他的volumedriver.</p><p>docker在创建volume的时候会在宿主机的/var/lib/docker/volume/中创建一个以volume ID为名的目录，并且将volume中的内容存储在名为_data的目录下。</p><p>使用docker volume inspect <volume name="">命令可以获得该volume包括其在宿主机中该文件夹的位置等信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect volume1</span><br></pre></td></tr></table></figure></volume></p><p>输出:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/volume1/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"volume1"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="为容器添加数据卷"><a href="#为容器添加数据卷" class="headerlink" title="为容器添加数据卷"></a>为容器添加数据卷</h3><p>用户在使用docker run或者docker create创建新容器的时候，可以使用-v选项为容器添加volume(可以多次使用-v选项，为容器添加多个数据卷),用户可以将自行创建或者由docker创建的的volume挂载到容器中，也可以将宿主机上的目录或者文件作为volume挂载到容器中。</p><h4 id="宿主机的目录或文件作为数据卷"><a href="#宿主机的目录或文件作为数据卷" class="headerlink" title="宿主机的目录或文件作为数据卷"></a>宿主机的目录或文件作为数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run  –v  ~/datavolume:/data –it Ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>-v选项就可以为启动的容器添加数据卷，~/datavolume为宿主机中的目录（这里也可以是一个文件，但是不管值文件夹还是文件都必须使用绝对路径），如果当前宿主机中没有这样的目录，那么容器启动时会自动在当前创建这个目录，这里的话，就是在当前用户的家目录下创建名为datavolume的目录。冒号后面的/data就是对应的容器中的目录。</p><p>我们如果在启动的容器的/data目录创建一个文件，并且在文件内写上一些内容。然后退出容器，查看宿主机的~/datavolume目录，则会发现，其中的内容就和我们在容器的/data目录中创建的内容一毛一样。也就是说两者之间的数据实现了同步的共享。</p><h4 id="随机名字的数据卷"><a href="#随机名字的数据卷" class="headerlink" title="随机名字的数据卷"></a>随机名字的数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -v /data ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>以上的命令创建了一个随机名字的volume,并挂载到容器中的/data目录。要想知道它所挂载的数据卷在宿主机中的位置，可以通过docker volume inspect <volume name="">查看。</volume></p><h4 id="指定名字的数据卷"><a href="#指定名字的数据卷" class="headerlink" title="指定名字的数据卷"></a>指定名字的数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create --name volume1</span><br><span class="line">$ docker run -d -v volume1:/data ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>以上两条命令首先是创建了一个名为volume1的数据卷，然后将其挂载在容器的/data目录。如果不执行第一条命令，直接执行第二条命令的话，docker会代替用户创建名为volume1的volume，并且将其挂载在容器中的/data目录。</p><h4 id="为数据卷添加访问权限"><a href="#为数据卷添加访问权限" class="headerlink" title="为数据卷添加访问权限"></a>为数据卷添加访问权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run  –v  ~/datavolume:/data:ro Ubuntu  /bin/bash</span><br></pre></td></tr></table></figure><p>在-v选项的参数后面添加了一个：ro(read only),这样的话就让这个数据卷变得只读了。<br>注：在退出容器后，可以用docker的inspect命令来查看数据卷的情况，以及读写权限</p><h3 id="在dockerfile中创建数据卷"><a href="#在dockerfile中创建数据卷" class="headerlink" title="在dockerfile中创建数据卷"></a>在dockerfile中创建数据卷</h3><p>VOLUME命令<br>如：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加多个数据卷</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">[“/datavolume1”,”/datavolume2”]</span></span><br><span class="line"><span class="bash"><span class="comment">#添加一个数据卷</span></span></span><br><span class="line"><span class="bash">VOLUME /date</span></span><br></pre></td></tr></table></figure></p><p>上面的命令所构建的镜像在创建容器时就会在容器的根目录挂载对应数据卷，并且在宿主机的文件系统中随机创建目录分别与容器内的数据卷对应。</p><p>与docker run -v不同的是VOLUME不能挂载主机中指定的文件夹，这主要是为了Dockerfile的可移植性。因为不能保证所有的宿主机都有对应的文件夹。</p><p>可以用docker inspect命令来查看宿主机上与这两个数据卷对应的目录。但是每次用此镜像运行的容器中的数据卷对应的宿主机的目录是不相同的。这样的话这个镜像所构建的容器们之间就无法进行数据共享。这就有了docker的数据卷容器。</p><h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><p><img src="/images/datavolume2.jpg" alt="数据卷容器示意图"></p><h2 id="什么是数据卷容器？"><a href="#什么是数据卷容器？" class="headerlink" title="什么是数据卷容器？"></a>什么是数据卷容器？</h2><p>一个容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，前面的挂载数据卷的容器就叫做数据卷容器。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#data volume container experience image</span></span><br><span class="line">FORM Ubuntu:latest</span><br><span class="line">VALUME[“/datavolume1”,”/datavolume2”]</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">[“/bin/bash”]</span></span><br><span class="line"><span class="bash">EXPOSE 80</span></span><br></pre></td></tr></table></figure><p>如上，我们创建了这样的dockerfile，我们再根据这一dockerfile构建一个镜像image1<br>然后：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name ct1 image1</span><br></pre></td></tr></table></figure></p><p>我们根据这个镜像创建了一个容器ct1，由上面的内容可知ct1内挂载了两个数据卷/datavolume1,/datavolume2.并且现在docker宿主机上也有两个目录与这两个数据卷相对应。下面我们以ct1为数据卷容器在运行两个容器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --volumes-from:ct1 --name ct2 ubuntu /bin/bash</span><br><span class="line">$ docker run -it --volumes-from:ct1 --name ct3 ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>这样ct1，ct2，ct3就都拥有了数据卷，他们之间包括和宿主机之间就可以实现数据的共享。并且容器创建好之后，我们可以删除此中的数据卷容器ct1，那么ct2和ct3中的数据卷仍然可以正常使用。虽然数据卷容器在这个容器集群的构建中扮演着重要的角色，但是他只是进行了配置的传递，而容器ct1本身却不起作用，所以即使删除ct1，其他容器可以照样使用。</p><p>事实上，当这个集群建好之后，我们删除任意的一个容器，都不会对数据卷产生任何影响。即使删除了所有的挂载的容器，包括ct1,ct2,ct3，数据卷也不会被自动删除，如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v　CONTAINER_ID命令来指定。</p><h2 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h2><p>如果创建容器时从容器中挂载了volume，在/var/lib/docker/volumes/下会生成与volume对应的目录，使用docker rm删除容器并不会删除与volume对应的目录，这些目录会占据不必要的空间。即使可以手动删除，但是由于这些随机生成的目录名称是无意义的随机字符串，要知道他们是否与被删除的容器对应也是十分麻烦的。所以在删除容器时需要对容器中的volume妥善处理。在删除容器时，一并删除volume有一下几种方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于自己命名的volume,可以直接像下面这样删除即可,这里只有当没有任何容器使用该volume的时候才会删除成功</span></span><br><span class="line">$ docker volume rm &lt;volume name&gt;</span><br><span class="line"><span class="comment">#在删除容器时，一并删除其volume(推荐使用)</span></span><br><span class="line">$ docker rm -v &lt;container_name&gt;</span><br><span class="line"><span class="comment">#在运行容器时使用`docker run --rm`,--rm选项会在容器停止运行时删除容器以及容器所挂载的volume</span></span><br></pre></td></tr></table></figure></p><h2 id="容器与宿主机的数据交换"><a href="#容器与宿主机的数据交换" class="headerlink" title="容器与宿主机的数据交换"></a>容器与宿主机的数据交换</h2><p>使用docker cp命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Usage:docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line">Copy files/folders between a container and the <span class="built_in">local</span> filesystem</span><br><span class="line">Options:</span><br><span class="line">  -L, --follow-link   Always follow symbol link <span class="keyword">in</span> SRC_PATH</span><br><span class="line">      --<span class="built_in">help</span>          Print usage</span><br></pre></td></tr></table></figure></p><p>上述的docker cp命令只适合纯粹的在容器与宿主机之间交换数据，但是它的灵活性比volume小得多，它不支持数据在容器和宿主机之间的同步。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker Data Manage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Express框架中的Cookie，Session，以及Redis使用</title>
      <link href="/2017/09/17/cookie-and-session-in-Express-use-redis-to-make-it-work-better/"/>
      <url>/2017/09/17/cookie-and-session-in-Express-use-redis-to-make-it-work-better/</url>
      
        <content type="html"><![CDATA[<p>本文主要包括express框架中cookie和session的使用和需要注意的点，以及redis的使用，如何在express项目中集成redis来缓存session等内容。</p><h1 id="Cookie和Session基本原理"><a href="#Cookie和Session基本原理" class="headerlink" title="Cookie和Session基本原理"></a>Cookie和Session基本原理</h1><h2 id="What’s-Cookie"><a href="#What’s-Cookie" class="headerlink" title="What’s Cookie?"></a>What’s Cookie?</h2><p>众所周知，HTTP协议本身是无状态的，服务器不负责维护会话的状态。每次客户端访问完,服务器就会立即断开链接。客户端访问了服务器，服务器不会关心客户端是谁，他只是在人的事先规划之下根据客户端请求报文中包含的信息做出相应的响应，完成了此次响应，就会立即与客户端断开，然后去处理下一个请求(注意：在异步非阻塞的设计之下，服务器并不是完完全全处理完一个请求才处理下一个请求的，node就是这样的设计)。即使下一个请求仍然由同一个客户端发起，服务器也不会有所察觉，他还是会按照一个全新的请求去处理。这样的设计就导致了访问者的身份和状态无法确定，这样的话我们要想在网上做一些具有连贯性的任务就不可实现。比如用户登录，网上购物，游戏的积分，线上学习的进度情况等等。于是cookie出现了。cookie是存储在客户端主机的磁盘上的一串有特定意义的字符串。cookie的实现是客户端和服务器相互配合的结果。目前只要是还在使用的浏览器都支持了cookie的实现。当某一个请求到达服务器，服务器如果需要追踪会话状态的话，就会在响应报文中设置一些特定的数据，这些数据告诉浏览器这个网站需要设置cookie并且cookie中需要包含那些信息。浏览器解析到了相应的信息，就会按照大家事先沟通好的方式，将这些cookie数据写入自己所在主机的磁盘的某一个位置。下一次当再次访问这个网站时，浏览器就会携带之前记录的cookie。这些cookie数据送到服务器，服务器就可以根据它来确定当前来访用户的身份，进而找到数据库中关于此用户的信息，从而确定其会话状态。</p><h2 id="What’s-session"><a href="#What’s-session" class="headerlink" title="What’s session?"></a>What’s session?</h2><p>Session同Cookie一样，都是用来解决用户会话的跟踪问题。但是Cookie存在着安全的问题，Cookie中存储的数据必定含有一个可以确定用户身份的关键信息，这一个信息有可能是敏感信息，这样的信息存储在用户磁盘上是极其不安全的。Cookie可以被窃取，被篡改等。虽然也有加密cookie，但是不管怎么说，存储在客户端总是让人不放心的。并且要让客户端每次请求都要带着额外的一堆数据，这对于网络传输来说也是不利的。就在这时Session出现了，session是基于cookie的。但是和cookie不同的是，原来cookie中的数据转移到了服务器端，而客户端则只保留一个无意义的随机字符串，这个无意义的字符串与存储在服务器端的该客户端的相关信息有着一一对应的关系。现在客户端访问这个服务器就只需要带着这一个随机字符串，然后服务器就可以根据这一个字符串确定来访客户的会话状态了。Session与Cookie相比，安全性有了极大的提高，并且减少了客户端访问服务器时所携带的数据量。</p><h1 id="在Express中使用Cookie或Session"><a href="#在Express中使用Cookie或Session" class="headerlink" title="在Express中使用Cookie或Session"></a>在Express中使用Cookie或Session</h1><h2 id="Express项目中使用Cookie"><a href="#Express项目中使用Cookie" class="headerlink" title="Express项目中使用Cookie"></a>Express项目中使用Cookie</h2><p>在express 4.x的版本的api中上行的req和下行的res中都有cookie,分别是读取cookie和设置cookie。在express中使用cookie需要用到cookie-parser这一个中间件，此中间件的使用方法是：<br>首先下载cookie-parser(如果你使用express-genarater生成项目的话，就已经下载好了cookie-parser，并且用到了项目中)</p><p>###下载cookie-parser</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cookie-parser --save</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser=<span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);　<span class="comment">//引包</span></span><br><span class="line">app.use(cookieParser())　　　<span class="comment">//这里的cookieParser()括号中没有字符串就是不带签名的cookie</span></span><br><span class="line"><span class="comment">//下面就可以使用cookie了</span></span><br><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line">res.cookie(<span class="string">"username"</span>,<span class="string">"xiaoming"</span> ,&#123;<span class="attr">domain</span>: <span class="string">'.example.com'</span>, <span class="attr">path</span>: <span class="string">'/admin'</span>, <span class="attr">secure</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">//这里的vaule是一个简单字符串也可以是一个JSON格式的字符串</span></span><br><span class="line"><span class="comment">//读取cookie</span></span><br><span class="line">req.cookies.username</span><br><span class="line">                 -&gt;<span class="string">"xiaoming"</span></span><br></pre></td></tr></table></figure><h3 id="设置cookie时的参数"><a href="#设置cookie时的参数" class="headerlink" title="设置cookie时的参数"></a>设置cookie时的参数</h3><p>domain　：cookie在什么域名下有效，类型为String,。默认为网站域名<br>expires : cookie过期日期，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。<br>httpOnly: 只能被web server访问，类型Boolean。不能通过js代码来读取cookie<br>maxAge : 实现expires的功能，设置cookie过期的时间，指明从现在开始，多少毫秒以后，cookie到期。<br>path : cookie在什么路径下有效，默认为’/‘，类型为String<br>secure ：只能被HTTPS使用，类型Boolean，默认为false<br>signed :使用签名，类型Boolean，默认为false。express会使用req.secret来完成签名，需要cookie-parser配合使用,将其设为true时，在取ｃｏｏｋｉｅ时要用 req.signedCookie（）方法<br>sameSite : Boolean or String Value of the “SameSite” Set-Cookie attribute.</p><h3 id="签名cookie"><a href="#签名cookie" class="headerlink" title="签名cookie"></a>签名cookie</h3><p>要使用带签名的cookie(一种更安全的cookie的处理方式)，需要cookie-parser的配合：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用cookie-parser中间件的时候要传入secret</span></span><br><span class="line">app.use(cookieParser(<span class="string">"This is a secret that signedcookie needed"</span>));</span><br><span class="line"><span class="comment">//设置cookie时要将signed设为true</span></span><br><span class="line">res.cookie(<span class="string">"username"</span>,<span class="string">"andrewpqc"</span>,&#123;<span class="attr">signed</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">//读取签名cookie时要使用req.signedCookies</span></span><br><span class="line">req.signedCookies.username</span><br><span class="line">-&gt;andrewpqc</span><br></pre></td></tr></table></figure></p><h3 id="清除cookie"><a href="#清除cookie" class="headerlink" title="清除cookie"></a>清除cookie</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.clearCookie(<span class="string">'name'</span>, &#123; <span class="attr">path</span>: <span class="string">'/admin'</span> &#125;);</span><br><span class="line"><span class="comment">//这里设置的path要保持和设置该cookie时的一致</span></span><br></pre></td></tr></table></figure><h2 id="Express项目中使用Session"><a href="#Express项目中使用Session" class="headerlink" title="Express项目中使用Session"></a>Express项目中使用Session</h2><p>Express中session的实现依赖于express-session</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express-session</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> session=<span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">secret:<span class="string">"keyboard cat"</span>,</span><br><span class="line">resave:<span class="literal">false</span>,</span><br><span class="line">saveUninitialized:<span class="literal">true</span>,</span><br><span class="line"><span class="comment">//cookie:&#123;secret:true&#125;//这里设为true时，是https协议使用的</span></span><br><span class="line"><span class="comment">//注意在实验时这里的secret要设为ｆａｌｓｅ，因为本地用的是http协议</span></span><br><span class="line">&#125;));</span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(req.session.login)&#123;</span><br><span class="line">res.send(<span class="string">'欢迎您'</span>＋<span class="string">','</span>+req.session.username)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res.send(<span class="string">'你还没有登录，请登录！'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/login'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">req.session.login=<span class="literal">true</span>;        <span class="comment">//设置session</span></span><br><span class="line">req.session.username=<span class="string">"xiaoming"</span>;<span class="comment">//设置session</span></span><br><span class="line">req.session.cookie.expires=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now()+<span class="number">3600000</span>);<span class="comment">//设置超时时间,这里１小时后失效</span></span><br><span class="line">res.send(<span class="string">'你已经成功登陆'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，这里在使用时和cookie不同，cookie的req,res都对应有cookie接口，分别读取和设置cookie。而session则不同，无论是读取还是设置，都是通过req.session这一个接口完成的。session的数据并不是存储在cookie中，cookie中存储的仅仅是session ID,而其他的有用的信息存储在服务器端。</p><h3 id="可选参数以及详细说明"><a href="#可选参数以及详细说明" class="headerlink" title="可选参数以及详细说明"></a>可选参数以及详细说明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(session(OPTIONS))</span><br></pre></td></tr></table></figure><p>这里有一点需要说明的是从express-session 1.5.0开始，这一个模块已经不再需要cookie-parser这一个中间件了。并且如果你在cookie-parser中使用的secret与express-session中的secret不一致的话就会起冲突。所以最好的处理办法是，如果你已经决定在项目中使用session的，你大可把cookie-parser从你的代码中去掉.</p><h1 id="redis的基本使用"><a href="#redis的基本使用" class="headerlink" title="redis的基本使用"></a>redis的基本使用</h1><h2 id="为什么要使用redis"><a href="#为什么要使用redis" class="headerlink" title="为什么要使用redis?"></a>为什么要使用redis?</h2><p>session中的数据要存储在服务器端，怎么存就成了一个问题？可以存储在服务器所在主机的文件系统中，也可以存储在服务器端的数据库中，还可以直接存储在服务器的内存中。(express-session默认就将session数据直接缓存在服务器所在主机的内存中)但是无论是存储在文件中还是普通数据库中，最终程序还是需要在磁盘上面进行读写。大家知道这种数据从磁盘上的读写是非常耗时的。而sesssion数据则是需要频繁的使用的，这就意味着频繁的I/O操作，这对程序的性能是一个巨大的损害。无疑，把session数据存储在内存中是一个最好的选择。但是像express-session默认的将其直接存储在服务器主机的内存中也是不行的。随着网站用户数的增加，session数据会越来越多，这将极大的占用服务器的内存，从而使程序变慢。网站的维护也将变得困难，因为一旦服务器重启，内存中的session数据就将全部丢失。这种方式也不利于session数据的共享。目前最常用的方式就是专门提供一个数据库，它把数据存储在内存中，必要时也可以将数据写入磁盘中，并且还支持多个程序的连接，实现数据的共享，同时提供操作数据的接口，方便程序操作数据。Redis就是这样的一个数据库。我们把Redis单独放在一个稳定的内存大的主机之上，做成一个数据库服务器，这样的话，上述的所有问题就统统解决了。<br>其实除了可以存储session数据之外，redis还可以缓存很多东西。比如我们可以把html缓存在redis中，客户端发请求需要这个html页面，那么我们的程序就可以先在缓存中找这个页面，如果没有找到在去数据库中找。类似这样的操作可以极大的提高响应的速度，增强用户体验。</p><h2 id="redis使用-基于ubuntu系统"><a href="#redis使用-基于ubuntu系统" class="headerlink" title="redis使用(基于ubuntu系统)"></a>redis使用(基于ubuntu系统)</h2><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install redis</span><br></pre></td></tr></table></figure><p>上面的两条命令就可以安装redis了，但是这样安装的redis往往不是redis的最新版本，(但是也够用了，本人就是这样安装的，安装的是3.2.1版，当前最新的稳定版本是４．０．１)其实区别不大。<br>如果想要安装最新版可以使用下面的几条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-4.0.1.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.1.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-4.0.1</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure></p><p>这样的安装时间可能会长一些。</p><h3 id="基本工具介绍"><a href="#基本工具介绍" class="headerlink" title="基本工具介绍"></a>基本工具介绍</h3><p>安装完成之后我们就有了两个基本工具了，服务启动工具：redis-server,命令行的客户端工具：redis-cli.</p><h4 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server</span><br></pre></td></tr></table></figure><p>上面这条命令就可以启动redis的服务了，redis默认监听的是６３７９端口。但是这种方式启动redis,是以前台的方式启动的，这样的话，我们就必须保持这个会话，关闭回话窗口或按下ctrl+c,服务就停止了。我们还可以以守护式进程的方式，让redis在后台运行。这就需要配置了,在/etc/redis.conf或者/etc/redis/redis.conf中，我们把daemonize后面的no改为yes就行了。这时我们再次启动redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>这次启动要在命令后面带上刚才修改了的配置文件的路径。这样的话，我们的redis就会在后台运行了。<br>注意：有的版本的redis默认daemonize的选项就是yes,也就是说默认就是在后台运行的，这时我们在运行$ redis-server就会告诉我们6379端口被占用。</p><h4 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h4><p>redis-cli是一个redis的命令行客户端工具，用于连接和操作redis服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure><p>上面的这条命令，默认是连接到本地的6379端口，我们也可以指定主机名和端口号来进行远程链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><p>这条命令同样链接到本地的6379<br>链接到了redis服务器之后，我们就进入了与redis服务器的会话交互中，我们可以通过一些指令来进行操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ keys *             //查看存储的所有的键</span><br><span class="line">$ <span class="built_in">set</span> hello world    //设置键hello对应的值为world</span><br><span class="line">$ get hello          //查看键hello对应的值</span><br></pre></td></tr></table></figure><h4 id="GUI工具"><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h4><p>推荐Redis Desktop Manager</p><h3 id="nodejs中操作redis"><a href="#nodejs中操作redis" class="headerlink" title="nodejs中操作redis"></a>nodejs中操作redis</h3><p>在nodejs中操作redis,需要一个redis的驱动。目前比较受欢迎的有两个node_redis,ioredis.下面我们就使用node-redis来讲解。</p><h4 id="安装node-redis"><a href="#安装node-redis" class="headerlink" title="安装node_redis"></a>安装node_redis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save redis</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node_redis插件</span></span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="comment">//链接redis服务器</span></span><br><span class="line"><span class="keyword">var</span> client = redis.createClient(<span class="number">6379</span>, <span class="string">"localhost"</span>);</span><br><span class="line"><span class="comment">//保存数据</span></span><br><span class="line">client.set(<span class="string">"this is a key"</span>, <span class="string">"this is a vaule"</span>);</span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line">client.get(<span class="string">'this is a key'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.message);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//我们可以改写toString方法，让redis存储一个json字符串，这是我们可以把他</span></span><br><span class="line"><span class="comment">//从redis中取出来之后就可以转化成对象，接着使用</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当然，最好不要改变原型链中的方法</span></span><br><span class="line"><span class="comment">//我们保存一个对象</span></span><br><span class="line">client.set(<span class="string">'key'</span>, &#123;<span class="string">"a"</span>: <span class="number">1</span>,<span class="string">"b"</span>: <span class="number">2</span>&#125;);</span><br><span class="line">client.get(<span class="string">'key'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.message);</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(vaule, <span class="keyword">typeof</span> vaule)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//从输出结果中可以看到，上面的打印ｖａｕｌｅ的类型，是一个字符串</span></span><br><span class="line"><span class="comment">//那是因为当存储的是一个对象的时候，redis会使用toString方法，把他转化成字符串，见上</span></span><br><span class="line"><span class="comment">//操作列表list</span></span><br><span class="line"><span class="comment">//从右边依次插入a,b,c,d,e</span></span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'a'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'b'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'c'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'d'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">//同理，还有一个lpush</span></span><br><span class="line"><span class="comment">//从左边加数据</span></span><br><span class="line"><span class="comment">//删除数据（从右边删rpop,从左边删lpop）</span></span><br><span class="line">client.rpop(<span class="string">'testList'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,v</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.message);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(v);<span class="comment">//这里的v就是被删除的数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//读取列表</span></span><br><span class="line"><span class="comment">//取数据需要指定从哪里取到哪里，参数中如果是非负数就是从左边开始取，负数就是从右边开始取</span></span><br><span class="line"><span class="comment">//下面的这条语句就是取出全部的数据</span></span><br><span class="line">client.lrange(<span class="string">"testList"</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,list</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err.message);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">consol.log(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//操作集合</span></span><br><span class="line"><span class="comment">//往集合里面添加东西</span></span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'a'</span>);</span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'b'</span>);</span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'c'</span>);</span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'d'</span>);</span><br><span class="line"><span class="comment">//集合里面的数据有互异性，在向里面添加数据时只会添加集合中没有的数据，集合中已经有的数据</span></span><br><span class="line"><span class="comment">//将无法插入</span></span><br><span class="line"><span class="comment">//从集合中取东西</span></span><br><span class="line">client.smembers(<span class="string">'testSet'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,values</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(values)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//消息中介</span></span><br><span class="line"><span class="comment">//通过redis的消息订阅与发布可以实现两个进程之间的通信</span></span><br><span class="line"><span class="comment">//消息的发布</span></span><br><span class="line">client.publish(<span class="string">'testPublish'</span>,<span class="string">'message from hhh'</span>);</span><br><span class="line"><span class="comment">//消息的订阅</span></span><br><span class="line">client.subscribe(<span class="string">'testPublish'</span>);</span><br><span class="line">client.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">channel,msg</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(channel,msg)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="在Express项目中用redis来缓存Session"><a href="#在Express项目中用redis来缓存Session" class="headerlink" title="在Express项目中用redis来缓存Session"></a>在Express项目中用redis来缓存Session</h4><p>在express项目中使用redis需要connect-redis这一个插件。首先要安装connect-redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -save connect-redis</span><br></pre></td></tr></table></figure><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> redis=<span class="built_in">require</span>(<span class="string">'redis);</span></span><br><span class="line"><span class="string">var session=require('</span>express-session<span class="string">');</span></span><br><span class="line"><span class="string">var RedisStore=require('</span>connect-redis<span class="string">')(session);</span></span><br><span class="line"><span class="string">var client=redis.createClient(6379,"127.0.0.1");</span></span><br><span class="line"><span class="string">var app=express();</span></span><br><span class="line"><span class="string">app.use(session(&#123;</span></span><br><span class="line"><span class="string">secret: '</span>recommand <span class="number">128</span> bytes random string<span class="string">',</span></span><br><span class="line"><span class="string">resave:true,</span></span><br><span class="line"><span class="string">saveUninitialized:true,</span></span><br><span class="line"><span class="string">cookie:&#123;&#125;,</span></span><br><span class="line"><span class="string">//在express-session中间件选项中加入store就可以了</span></span><br><span class="line"><span class="string">store:new RedisStore(&#123;client:client&#125;)</span></span><br><span class="line"><span class="string">&#125;));</span></span><br></pre></td></tr></table></figure><p>配置完上面的内容之后，我们还是照常在我们的代码中去操作session，但是这是我们的session的数据就已经存在了redis的缓存系统中了。</p>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> express </tag>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Set and Multiset in STL</title>
      <link href="/2017/09/14/Set-and-Multiset-in-STL/"/>
      <url>/2017/09/14/Set-and-Multiset-in-STL/</url>
      
        <content type="html"><![CDATA[<h1 id="关联式容器概述"><a href="#关联式容器概述" class="headerlink" title="关联式容器概述"></a>关联式容器概述</h1><p>set和multiset是一种关联式容器，关联式容器依据特定的排序准则，自动为元素排序。所有的关联式容器都有一个可供选择的template参数，指明排序准则。排序准则以函数的形式呈现，用于比较元素值或元素键，默认情况下，从小到大排列。<br>主要的关联式容器包括set,multiset,map,multimap.其中set可以视为一种特殊的map，它的元素的值就是键的值。前两种需要包含set头文件，后两种要包含map头文件。</p><pre><code>set关键词和数据是同一个值，set容器中的所有的元素必须具有唯一值，不可重复。set对象可以一定的次序存储数据。multiset是另一种类型的容器，其关键词和数据元素也是同样的值。与set不同的是，它可以包含重复的元素。同样的multiset中的数据也是有次序的。map是一种包含成对数据的容器，一个值是实际的数据值，另一个值是用来寻找数据的关键值。一个特定的关键值只能与一个元素相联系。map中同一对键值只能出现一次.同样的其中的键值对也是按照特定的顺序排列的。multimap是允许重复键值的出现。</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Set STL </tag>
            
            <tag> Multiset STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Deque in STL</title>
      <link href="/2017/09/14/Deque-in-STL/"/>
      <url>/2017/09/14/Deque-in-STL/</url>
      
        <content type="html"><![CDATA[<p>dequ(双端队列)和vector非常的相似，deque也是采取动态数组来管理容器中的数据，数据存储的地址都是连续的，可以对deque中的数据进行随机的访问。deque最重要的特征就是在容器的两端插入删除数据都非常的快速，这也是它和vector的主要的区别。(vector只是在尾端插入删除快速，在头部插入删除数据效率很低)。当程序中涉及到需要在容器的头部和尾部频繁的插入和删除数据时，deque就是最好的选择。同样的，作为动态数组的形式，deque必然也存在其局限性：在deque的中间插入和删除数据时效率很低，这一点和vector的情况是一致的。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>由于deque与vector及其的相似，这里就只总结一下它和vector在具体用法上的区别，其他的用法可以参考vector。</p><h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><p>使用前需要包含deque头文件，使用std命名空间。</p><h3 id="push-front-和pop-front"><a href="#push-front-和pop-front" class="headerlink" title="push_front()和pop_front()"></a>push_front()和pop_front()</h3><p>deque在vector的基础之上增加了push_front()和pop_front()两个成员函数来实现对头部元素的快速操作。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL Deque </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>List in STL</title>
      <link href="/2017/09/13/List-in-STL/"/>
      <url>/2017/09/13/List-in-STL/</url>
      
        <content type="html"><![CDATA[<p>与vector一样，list也是STL模板库中提供的序列式容器之一。不同的是，list是由双向链表来实现的，元素与元素之间的地址不一定是连续的，，元素之间的序列关系由指针维护。list支持前后两种移动方式。与vector不同,list不支持随机访问，不可以使用operator[] 或at()来获取元素。list的优势在于任何位置执行插入和删除操作都非常迅速，因为改变的仅仅是指针与节点的链接而已。list的使用需要头文件和std命名空间。</p><h2 id="list对象的定义与构造函数"><a href="#list对象的定义与构造函数" class="headerlink" title="list对象的定义与构造函数"></a>list对象的定义与构造函数</h2><p>list对象的定义与初始化一般有一下几种方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist;　　　　　　　　<span class="comment">//初始化一个空lkongist</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(size);          <span class="comment">//初始化一个初始大小为size的空list</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(size,vaule);    <span class="comment">//初始化一个装有size个vaule的list</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(elselist);      <span class="comment">//复制构造函数</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(first,last);　　<span class="comment">//将由迭代器指定的其他list中的多个元素复制以构成新list</span></span><br></pre></td></tr></table></figure></p><h2 id="基础成员函数"><a href="#基础成员函数" class="headerlink" title="基础成员函数"></a>基础成员函数</h2><h3 id="元素的赋值"><a href="#元素的赋值" class="headerlink" title="元素的赋值"></a>元素的赋值</h3><p>list模板类提供了两个成员函数<code>push_back()</code>,<code>push_front()</code>,分别用来将新的节点追加到list的尾部和插入到list的头部。与之对应的<code>pop_back()</code>和<code>pop_front()</code>函数则是在相应位置做删除操作。在vector中只提供了<code>push_back()</code>函数和<code>pop_back()</code>函数，主要是因为vector中在头部插入和删除元素效率很低，所以就没有直接提供相应操作，这也说明了list是双向链表。</p><h3 id="list容器的容量"><a href="#list容器的容量" class="headerlink" title="list容器的容量"></a>list容器的容量</h3><p>和list容量相关的主要是下面的几个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mylist.size();         <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">mylist.max_size();　　<span class="comment">//返回容器中最多可以容纳节点的数目，一般是一个非常大的数字，我们可以不用管</span></span><br><span class="line">mylist.resize();　　　<span class="comment">//重新设置容器的大小</span></span><br></pre></td></tr></table></figure></p><h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><p>list模板类包含的和迭代器相关的函数主要有：begin(),end(),rbegin(),rend(),back(),front()<br>下面我们通过一个程序演示他们的使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; myIntlist;</span><br><span class="line">    myIntlist.push_back(<span class="number">1</span>);</span><br><span class="line">    myIntlist.push_back(<span class="number">2</span>);</span><br><span class="line">    myIntlist.push_back(<span class="number">3</span>);</span><br><span class="line">    myIntlist.push_back(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//顺序打印</span></span><br><span class="line">    for_each(myIntlist.begin(),myIntlist.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//反序打印</span></span><br><span class="line">    for_each(myIntlist.rbegin(),myIntlist.rend(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator riter;</span><br><span class="line">    riter=myIntlist.rbegin();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    iter=myIntlist.begin();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*riter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> last=myIntlist.back();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;last&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">4 3 2 1</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><h3 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h3><p>使用list对象的empty()方法判断链表是否为空，该函数返回bool值</p><h3 id="list元素的存取与访问"><a href="#list元素的存取与访问" class="headerlink" title="list元素的存取与访问"></a>list元素的存取与访问</h3><p>list对象不能使用operator[]和at()来实现随机访问，但是可以用迭代器来进行元素的访问。</p><h3 id="元素的插入与删除"><a href="#元素的插入与删除" class="headerlink" title="元素的插入与删除"></a>元素的插入与删除</h3><p>可以实现list元素插入与删除的函数有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在链表尾端插入</span></span><br><span class="line">push_back();</span><br><span class="line"><span class="comment">//删除尾端的元素</span></span><br><span class="line">pop_back();</span><br><span class="line"><span class="comment">//链表头部插入</span></span><br><span class="line">push_front();</span><br><span class="line"><span class="comment">//移除头部的元素</span></span><br><span class="line">pop_front();</span><br><span class="line"><span class="comment">//可以实现任意位置的插入</span></span><br><span class="line">insert()</span><br><span class="line"><span class="comment">//任意位置的删除</span></span><br><span class="line">erase()</span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line">clear()</span><br><span class="line"><span class="comment">//下面两个成员函数也可以用来删除链表中的元素</span></span><br><span class="line">remove()</span><br><span class="line">remove_if()</span><br></pre></td></tr></table></figure></p><h3 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><p>operator==,operator&lt;,operator&gt;,operator&lt;=,operator&gt;=,operator!=这些运算符函数均可以用于两个list对象之间的比较，前提是参与比较的两个list对象的格式应该完全相同。</p><h3 id="合并两个list"><a href="#合并两个list" class="headerlink" title="合并两个list"></a>合并两个list</h3><p>list还提供了成员函数merge()成员函数，用于将两个具有相同格式的list对象合并,同时提供了sort()成员函数用于将成员排序:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; L1,L2;</span><br><span class="line">    L1.push_back(<span class="string">"abc"</span>);</span><br><span class="line">    L1.push_back(<span class="string">"def"</span>);</span><br><span class="line">    L1.push_back(<span class="string">"ghi"</span>);</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    L2.push_back(<span class="string">"jkl"</span>);</span><br><span class="line">    L2.push_back(<span class="string">"mno"</span>);</span><br><span class="line">    L2.push_back(<span class="string">"pqr"</span>);</span><br><span class="line">    for_each(L2.begin(),L2.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    L1.merge(L2,greater&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L3,L4;</span><br><span class="line">    L3.push_back(<span class="number">2</span>);</span><br><span class="line">    L3.push_back(<span class="number">3</span>);</span><br><span class="line">    L3.push_back(<span class="number">1</span>);</span><br><span class="line">    for_each(L3.begin(),L3.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    L3.sort();</span><br><span class="line">    for_each(L3.begin(),L3.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//从大到小【排序</span></span><br><span class="line">    L3.sort(greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(L3.begin(),L3.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc def ghi</span><br><span class="line">jkl mno pqr</span><br><span class="line">jkl mno pqr abc def ghi</span><br><span class="line">2 3 1</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure></p><h3 id="unique-重复的元素只保留一个"><a href="#unique-重复的元素只保留一个" class="headerlink" title="unique()重复的元素只保留一个"></a>unique()重复的元素只保留一个</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">1</span>);</span><br><span class="line">    L1.push_back(<span class="number">2</span>);</span><br><span class="line">    L1.push_back(<span class="number">1</span>);</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//这里要先sort再unique(),不然的话没有效果</span></span><br><span class="line">    L1.sort();</span><br><span class="line">    L1.unique();</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure></p><h3 id="reverse-反转顺序"><a href="#reverse-反转顺序" class="headerlink" title="reverse()反转顺序"></a>reverse()反转顺序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">1</span>);</span><br><span class="line">    L1.push_back(<span class="number">2</span>);</span><br><span class="line">    L1.push_back(<span class="number">3</span>);</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//这里要先sort再unique(),不然的话没有效果</span></span><br><span class="line">    <span class="comment">//L1.sort();</span></span><br><span class="line">    L1.reverse();</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++总结2</title>
      <link href="/2017/09/10/something-other-about-c/"/>
      <url>/2017/09/10/something-other-about-c/</url>
      
        <content type="html"><![CDATA[<p>这一篇文章打算把c++里面非常重要而又不容易记住的东西好好总结一下，主要涉及的知识点有独立编译，命名空间，友元，继承的细节，多态等。</p><h1 id="独立编译和命名空间"><a href="#独立编译和命名空间" class="headerlink" title="独立编译和命名空间"></a>独立编译和命名空间</h1><p>其实在上一篇文章中,我已经讨论过独立编译的问题，只不过没有讲的深入，在这里我打算详细的讲一讲独立编译。</p><h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型(ADT)"></a>抽象数据类型(ADT)</h2><p>抽象数据类型(Abstract Data Type)是一个类，它将类的接口与类的实现区分开来。对于标准的开发来讲，所有的类都应该设计成ADT。为了定义一个ADT类，需要将类的使用规范与类的实现细节彻底分开。这一点的实现需要遵循一下三条规则：</p><ul><li>使所有的成员变量都成为类的私有成员。</li><li>使类的每一项基本操作成为类的一个公共成员函数,一个友元函数，一个普通函数或者一个重载的操作符。将类的定义与函数/操作符的声明以及用来告诉类的使用者该如何使用这个类及相关函数的必要的注释统统放在一个文件中，这个文件就是这个ADT类的接口文件。</li><li>确保使用ADT的程序员无法访问到基本操作的具体实现。实现由函数定义以及重载的操作符的定义（另外还包括任何辅助函数，或者这些定义需要的其他项）构成。</li></ul><p>我们在设计类的时候只要按照ADT的设计原则，那么我们的类就是标准的类了。但是这就引出来了其他的一些问题，比如：编译时的依赖关系，接口文件的重复定义，命令空间问题。</p><h2 id="解决编译时的依赖关系"><a href="#解决编译时的依赖关系" class="headerlink" title="解决编译时的依赖关系"></a>解决编译时的依赖关系</h2><p>这个问题在上一篇文章中已经讨论过了,这里不在赘述。</p><h2 id="防止接口文件的重复编译"><a href="#防止接口文件的重复编译" class="headerlink" title="防止接口文件的重复编译"></a>防止接口文件的重复编译</h2><p>我们设计ADT类的其中一个目的就是要提高代码的可重用性。所有的文件都可以通过include某个ADT类的接口文件，来使用这个类提供的功能。这样的话就有可能出现类似这样的情形：我们项目中的一个文件include另外的两个文件，而另外的两个文件又分别include了同一个ＡＤＴ类，这样的话我们的项目就会编译两次这个ADT类，这是不被允许的。我们必须要解决这个问题。解决的办法就是在类的接口文件中，加三条预编译指令。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>　XXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXX</span></span><br><span class="line"><span class="comment">//这中间放类的接口文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>将类的接口放在这三条命令之间，就可以防止重复编译。第一次编译的时候，会定义XXX这个宏，当第二次编译的时候，XXX这个宏已经被定义，编译器就会跳过这个接口文件，从而避免了重复编译。</p><h2 id="命名空间问题。"><a href="#命名空间问题。" class="headerlink" title="命名空间问题。"></a>命名空间问题。</h2><p>大型项目的编码工作是由许多的程序员的合作完成的。每个人写的代码最后汇合到一起，这就难以避免的会产生命名冲突。要解决这个问题就要靠命名空间了。大家在编写c++代码的时候，用的最多的就是std命令空间了。其实我们写的每一句代码都是在某一个命名空间中，加入不明确指定一个命名空间，代码就默认放在全局命名空间中。全局命令空间不需要using指令，因为它是默认的命名空间。可以同时使用多个命名空间，比如我们总是在使用全局命名空间，同时也会使用std命名空间。假如一个名称在两个命名空间中都进行了定义，而你又使用了这两个命名空间，那么你使用这个名称的时候就会产生冲突，这个名称是哪个命名空间的呢？所以我们在使用一个名称的时候一般都要指定这个名称属于那个命名空间。<br>为了防止我们自己定义的类中的名称与全局命名空间或用户引用的其他命名空间中的名称产生冲突，我们最好把自己的类放在一个自己的命名空间中。</p><h3 id="创建和使用命名空间"><a href="#创建和使用命名空间" class="headerlink" title="创建和使用命名空间"></a>创建和使用命名空间</h3><p>要将代码放到一个命名空间中，需要采取一下形式来定义一个命名空间分组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> my_namespace_name&#123;</span><br><span class="line">some_code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将上述命名空间分组放到自己的代码中，就相当与将some_code中定义的名称放到命名空间my_namespace_name中，为了使用这些名称，需要使用一下的using 指令：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> my_namespace_name;</span><br></pre></td></tr></table></figure></p><p>下面给一点代码来演示命名空间的创建与使用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//程序中需要用到cout,所以需要std命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//在两个命名空间中声明两个函数</span></span><br><span class="line"><span class="keyword">namespace</span> ns1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ns2&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//要指定使用那个命名空间，才能使用那个命名空间中定义的名称</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> ns1;</span><br><span class="line">        func1();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> ns2;</span><br><span class="line">        func2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在同样的命名空间中定义这两个函数</span></span><br><span class="line"><span class="keyword">namespace</span> ns1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"here is func1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ns2&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"here is func2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="限定名称"><a href="#限定名称" class="headerlink" title="限定名称"></a>限定名称</h3><p>假如现在你遇到了这样一种情况，你需要使用ns1命名空间中的func1函数和ns2中的func2函数，但是在ns1和ns2中又分别定义了一个名为func的同名函数。这时如果你使用using namespace ns1和using namespace ns2就不合适了。因为这会使得ns1和ns2中的所有的名称都进入可用状态，这就产生了冲突。一种更为保险的方法就是下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ns1::func1;</span><br><span class="line"><span class="keyword">using</span> ns2::func2;</span><br></pre></td></tr></table></figure></p><p>这样的话，就只会让ns1命名空间中的func1和ns2中的func2进入可用状态，而两个命名空间中的其他名称仍然不可使用。</p><h1 id="类中的注意点"><a href="#类中的注意点" class="headerlink" title="类中的注意点"></a>类中的注意点</h1><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>在 C++ 中，每一个对象都能通过this指针访问自己的地址。this指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>面向对象的设计思想提高了数据封装的程度和程序数据的安全性。外界对对象内部数据的访问得到了严格的控制。外部要想访问对象的私有属性，必须要通过对象提供的方法去访问。但是有时为了简化函数定义和提高效率，我们想让自己定义的外部函数直接访问到对象的私有属性。这在c++中是通过友元函数实现的。就是将某个外部函数定义为某个类的友元，这样这个函数就得到了类的信任，从而可以直接访问类的私有属性。具体实现，看代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Student(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age);</span><br><span class="line">        Student();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//下面这个函数就是Studnet类的一个友元函数</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Student s1,Student s2)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">Student::Studnet(strng _name,<span class="keyword">int</span> _age):name(_name),age(_age)&#123;</span><br><span class="line">    <span class="comment">//有意留空</span></span><br><span class="line">&#125;</span><br><span class="line">Student::Student():name(<span class="string">"none"</span>),age(<span class="number">18</span>)&#123;</span><br><span class="line">    <span class="comment">//有意留空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> Studnet::getName()&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setName(<span class="built_in">string</span> _name)&#123;</span><br><span class="line">    name=_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::getAge()&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setAge(<span class="keyword">int</span> _age)&#123;</span><br><span class="line">    age=_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Studnet s1,Student s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.name==s2.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码包含了一个Student类的接口和实现，由于这里只是演示，所以就没有考虑上文中提到的那些东西。上面定义了一个友元函数，用来判断两个学生是否同名。必须明确的是，友元函数并不是一个类的成员函数，他是一个外部函数，但是把他声明为某个类的友元之后，他就有了访问类的私有属性的权限。声明的方法是在当事类中声明，并且以friend关键字打头，定义的时候还是按照普通函数那样定义。假如我们的类有良好的取值和赋值函数的话，我们也可以不必把这个函数定义成友元函数，直接就把他定义成一个普通的外部函数，这时，他的定义就变成这样了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Student s1,Student s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.getName()==s2.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见这样的话在一定程度上增加了函数定义的复杂度，并且降低了效率。确实友元可以简化函数的定义和提高效率，但是反对友元的人则说友元函数破坏了类的封装性。依我看两者都有道理，用那一种就看编程者的心情了。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是通过一个类(基类)派生出一个新类(派生类)的过程，派生类自动具有基类的所有成员变量和函数，并且可以根据需要添加更多的成员函数或成员变量。<br>先举一个例子</p><p>下面我们先来看一个关于继承的小项目,项目结构如下：<br>Project:<br>human.h<br>human.cpp<br>student.h<br>student.cpp<br>teacher.h<br>teacher.cpp<br>main.cpp<br>makefile<br>上面的项目定义了一个Human类，然后由Human类派生出Student类和Teacher类，xxx.h为对应类的接口文件，xxx.cpp为对应类的实现文件，main.cpp为测试这三个类的文件，makefile为编译的文件。<br>human.h的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HUMAN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUMAN_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> human_namespace&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Human(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age);</span><br><span class="line">        Human();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> _name)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> _age)</span></span>;</span><br><span class="line">        <span class="comment">//下面这个函数就是Studnet类的一个友元函数</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Human s1,Human s2)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">human.cpp的内容：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"human.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> human_namespace&#123;</span><br><span class="line">    Human::Human(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age):name(_name),age(_age)&#123;</span><br><span class="line">        <span class="comment">//有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Human::Human():name(<span class="string">"none"</span>),age(<span class="number">18</span>)&#123;</span><br><span class="line">        <span class="comment">//有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> Human::getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> Human::setName(<span class="built_in">string</span> _name)&#123;</span><br><span class="line">        name=_name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> Human::getAge()&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> Human::setAge(<span class="keyword">int</span> _age)&#123;</span><br><span class="line">        age=_age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Human s1,Human s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.name==s2.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>student.h的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"human.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> student_namespace&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">public</span> Human&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Student(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _schoolNmae);</span><br><span class="line">        Student();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setSchoolName</span><span class="params">(<span class="built_in">string</span> _schoolName)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getSchoolName</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">studying</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> schoolName;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">student.cpp的内容：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">namespace</span> student_namespace&#123;</span><br><span class="line">    Student::Student(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _schoolName):Human(_name,_age),schoolName(_schoolName)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    Student::Student():Human(),schoolName(<span class="string">"none"</span>)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Student::setSchoolName(<span class="built_in">string</span> _schoolName)&#123;</span><br><span class="line">        schoolName=_schoolName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> Student::getSchoolName()&#123;</span><br><span class="line">        <span class="keyword">return</span> schoolName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Student::studying(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是学生"</span>&lt;&lt;getName()&lt;&lt;<span class="string">"，我在学习！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>teacher.h的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEACHER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"human.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">namespace</span> teacher_namespace&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Teacher(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _subject);</span><br><span class="line">            Teacher();</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(<span class="built_in">string</span> _schoolName)</span></span>;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">getSubject</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">teaching</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">string</span> subject;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>teacher.cpp的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"teacher.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">namespace</span> teacher_namespace&#123;</span><br><span class="line">    Teacher::Teacher(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _subject):Human(_name,_age),subject(_subject)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    Teacher::Teacher():Human(),subject(<span class="string">"none"</span>)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Teacher::setSubject(<span class="built_in">string</span> _subject)&#123;</span><br><span class="line">        subject=_subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> Teacher::getSubject()&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Teacher::teaching(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是一个老师，我在教书！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main.cpp的内容:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"teacher.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> student_namespace;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> teacher_namespace;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1=Student(<span class="string">"小明"</span>,<span class="number">25</span>,<span class="string">"黄冈中学"</span>);</span><br><span class="line">    Student s2;</span><br><span class="line">    Teacher t1=Teacher(<span class="string">"老王"</span>,<span class="number">40</span>,<span class="string">"语文"</span>);</span><br><span class="line">    Teacher t2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1.getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s2.getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    s1.studying();</span><br><span class="line">    s1.setName(<span class="string">"小小明"</span>);</span><br><span class="line">    s1.studying();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t1.getSubject()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t2.getAge()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>makefile的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main.exe:student.o teacher.o main.o human.o</span><br><span class="line">g++ -o main.exe student.o teacher.o main.o human.o</span><br><span class="line">human.o:human.cpp human.h</span><br><span class="line">student.o:student.cpp student.h  </span><br><span class="line">g++ -c student.cpp student.h </span><br><span class="line">teacher.o:teacher.cpp teacher.h </span><br><span class="line">g++ -c teacher.cpp teacher.h </span><br><span class="line">main.o:main.cpp</span><br><span class="line">g++ -c main.cpp</span><br><span class="line">cleanall:</span><br><span class="line">rm main.exe student.o teacher.o main.o human.o student.h.gch teacher.h.gch</span><br><span class="line">cleansome:</span><br><span class="line">rm student.o teacher.o main.o human.o student.h.gch teacher.h.gch</span><br></pre></td></tr></table></figure></p><p>继承的编码语法这里就不在赘述。派生类自动获得基类的所有成员变量和成员函数（特例：一些特殊的成员函数，比如构造函数将不会被自动继承，私有成员函数根本就不会被继承），继承的成员函数和成员变量不在派生类的定义中提到(特例：如果你需要更改一个继承的函数的定义，那么你需要在派生类的定义中列出它)，但他们会自动成为派生类的成员。</p><h2 id="派生类中的构造函数"><a href="#派生类中的构造函数" class="headerlink" title="派生类中的构造函数"></a>派生类中的构造函数</h2><p>基类中的构造函数不被派生类继承，但可以在派生类的构造函数的定义中调用基类的构造函数。要用一种特殊的语法来调用基类的构造函数，即初始化区域：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Teacher::Teacher(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _subject):Human(_name,_age),subject(_subject)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">Teacher::Teacher():Human(),subject(<span class="string">"none"</span>)&#123;</span><br><span class="line">    <span class="comment">//主体有意留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Teacher类继承自Human类，这个Teacher类的构造函数在定义是就是调用了Human类的构造函数。对派生类定义构造函数应该包括对某个基类构造函数的调用，并将这个调用放在构造函数定义的初始化区域。假如不包括对任何基础类构造函数的调用，那么在调用派生类构造函数时，会自动调用基类的默认构造函数(即没有参数的那个构造函数)，如果基类并没有定义这样的默认构造函数，那么在编译时就会报错。<br>派生类成员函数定义中可以使用来自基类的私有变量吗？</p><p>答案当然是不可以。就如上面的小项目，Student类继承自Human类，现在在Student类中增加了一个方法studying,这个方法需要用到name,上面我是这样处理的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Student::studying(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是学生"</span>&lt;&lt;getName()&lt;&lt;<span class="string">"，我在学习！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里调用的是继承得来的getName()这一取值函数来获取当前对象的name,按理说name这一个基类的私有变量也被继承才对，为何不直接使用name呢？这里需要注意，name是基类Human的私有成员变量，所以只有在Human类的成员函数的定义中才能够直接访问，在其他的任何类中（包括派生类）的成员函数的定义中都不能够直接通过名称来访问.虽然Student类有一个名为name的成员变量(从Human继承得来)，但是在Student类定义的任何成员函数中对成员name的任何直接访问都是非法的。其它的继承来的私有属性或函数也一样。</p><h2 id="私有成员函数不会被继承"><a href="#私有成员函数不会被继承" class="headerlink" title="私有成员函数不会被继承"></a>私有成员函数不会被继承</h2><p>上面讲到除非在基类的接口与实现中，否则不能直接访问基类的私有成员变量和私有成员函数，即使是在派生类的一个成员函数的定义中。私有成员变量与私有成员函数类似，但是对私有成员函数来讲这种限制似乎更加严格，在派生类中，基类私有成员变量好歹可以通过取值函数和赋值函数来操作，但是私有成员函数则根本就不可用了。事实上私有成员函数根本就不会被继承下来。</p><h2 id="protected限定符"><a href="#protected限定符" class="headerlink" title="protected限定符"></a>protected限定符</h2><p>在前面类的定义中只使用了两种类的成员:public和private,其实还存在第三种:protected.对除了基类的派生类以外的所有类以及外部函数来说，基类中用protected标记的成员和用private标记的成员没有任何区别。但是对与基类的派生类来说，则可以在自己的成员函数的定义中直接通过名称来访问基类的protected成员。如果在Human类中name这一属性没有被标记为private,而被标记为protected，那么Student类中studying函数应该像下面这样定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Student::studying(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是学生"</span>&lt;&lt;name&lt;&lt;<span class="string">"，我在学习！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>被protected标记的成员在继承时仍然成为派生类的protected成员，所以对派生类的派生类来讲，它仍然可以通过名称来直接访问在它的爷爷类中定义的protected成员。<br>同样的，对protected的使用也是说法不一，有人认为使用protected是一种不好的风格，因为它违背了“隐藏类实现的细节”这一原则。但也有人认为protected的使用简化了派生类成员函数定义，提高了效率。</p><h2 id="重定义成员函数"><a href="#重定义成员函数" class="headerlink" title="重定义成员函数"></a>重定义成员函数</h2><p>继承时基类中的绝大多数成员函数会被原封不动的继承到派生类中，但有时这并不是我们想要的，我们可能还需要某些成员函数的定义做出一些变化，这时我们就需要对其进行重定义。重定义需要注意需要在派生类中明确列出需要修改定义的那些继承成员函数的声明，并且不可改变原函数的参数数量，顺序和类型。</p><h2 id="重定义和重载的比较"><a href="#重定义和重载的比较" class="headerlink" title="重定义和重载的比较"></a>重定义和重载的比较</h2><p>不要混淆在派生类中对一个函数定义的重定义以及对一个函数名的重载。重定义函数时，派生类中给出的新函数定义和原函数具有相同的参数数量顺序和类型。与基类的中的函数定义相比，如果派生类中的函数使用了数量不同的参数，或者某个参数具有不同的类型，那么派生类实际上会同时存在两个函数，这成为重载，而非重定义。</p><h2 id="访问重定义的基函数"><a href="#访问重定义的基函数" class="headerlink" title="访问重定义的基函数"></a>访问重定义的基函数</h2><p>假如我们重定义了一个函数，使其在派生类中的定义有别与基类中的定义，在这种情况下，并不是说基类中的定义就再也不能由派生类的对象使用了。要为派生类的对象调用函数的基类版本。<br>现在假定Human类中有一个saying函数，它不接受任何参数。Student类继承自Human类，并且在Student类中重定义了saying函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明对象</span></span><br><span class="line">Human A;</span><br><span class="line">Student B;</span><br><span class="line"><span class="comment">//A,B分别调用自己版本的saying()</span></span><br><span class="line">A.saying();</span><br><span class="line">B.saying();</span><br><span class="line"><span class="comment">//B调用saying的基类版本</span></span><br><span class="line">B.Human::saying();</span><br></pre></td></tr></table></figure></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p>下面的实例中，基类 Shape 被派生为两个类，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Rectangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Triangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Triangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (width * height / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent class area</span><br><span class="line">Parent class area</span><br></pre></td></tr></table></figure></p><p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。<br>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle class area</span><br><span class="line">Triangle class area</span><br></pre></td></tr></table></figure></p><p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。<br>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。<br>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。<br>我们可以把基类中的虚函数 area() 改写如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// pure virtual function</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>C++面向对象程序设计(第七版)</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python的Socket练习——伪SSH</title>
      <link href="/2017/09/01/a-fake-ssh-based-on-python/"/>
      <url>/2017/09/01/a-fake-ssh-based-on-python/</url>
      
        <content type="html"><![CDATA[<p>这一篇博客介绍一下我最近用python中的socket模块写的一个类似于ssh的小工具，虽说是一个工具，但是比那个真的ssh还是弱了不少，基本上也没什么使用价值。但是学习价值还是有的。主要的学习点是网络传输中的数据包粘包问题的解决方案，和发送过去的数据与源数据的md5校验以及python的os，socket模块的简单使用。</p><h1 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h1><p>远程操作主机，实现系统中的部分命令的执行并返回执行的输出，上传本地文件到服务器运行的目录，从服务器运行目录下载文件到本地。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="上传-下载文件-过程差不多"><a href="#上传-下载文件-过程差不多" class="headerlink" title="上传/下载文件(过程差不多)"></a>上传/下载文件(过程差不多)</h3><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,json,hashlib,os</span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">8005</span></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((HOST, PORT))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    cmd = input(<span class="string">"&gt;&gt;&gt;"</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(cmd)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">　  <span class="keyword">elif</span> cmd.startswith(<span class="string">'get'</span>):</span><br><span class="line">    client.send(cmd.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    dateHeader_s2c = json.loads(client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">if</span> dateHeader_s2c[<span class="string">'status'</span>]==<span class="string">'Y'</span>:</span><br><span class="line">        client.send(<span class="string">b'ok'</span>)</span><br><span class="line">        md5 = hashlib.md5()</span><br><span class="line">        filename = dateHeader_s2c[<span class="string">'filename'</span>]</span><br><span class="line">        accept_length=<span class="number">0</span></span><br><span class="line">        response_length=dateHeader_s2c[<span class="string">'size'</span>]</span><br><span class="line">        <span class="keyword">while</span> accept_length &lt; response_length:</span><br><span class="line">            <span class="keyword">with</span> open(filename + <span class="string">".s2c"</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                accept_temp = client.recv(<span class="number">1024</span>)</span><br><span class="line">                md5.update(accept_temp)</span><br><span class="line">                f.write(accept_temp)</span><br><span class="line">                accept_length += len(accept_temp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            client.send(<span class="string">b'ok'</span>)</span><br><span class="line">            accept_md5 = client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> accept_md5 == md5.hexdigest():</span><br><span class="line">                print(<span class="string">'下载成功！'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.popen(<span class="string">'rm %s'</span> % filename + <span class="string">".s2c"</span>) <span class="comment">#删除已经下载的破碎文件</span></span><br><span class="line">                print(<span class="string">'文件破碎！请重新下载'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'请输入一个正确的文件名'</span>)</span><br></pre></td></tr></table></figure><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os,hashlib,json</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> server_config</span><br><span class="line">server=socket.socket()</span><br><span class="line">server.bind((server_config.HOST,server_config.PORT))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Server start at: %s:%s'</span> %(server_config.HOST,server_config.PORT))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'wait for connection...'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Connected by '</span>, addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment">#接收到客户端输入的命令</span></span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode().strip()</span><br><span class="line">        <span class="keyword">if</span> len(cmd)==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'客户端断开链接．．．'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#响应客户端的下载文件请求</span></span><br><span class="line">        <span class="keyword">if</span> cmd.startswith(<span class="string">'get'</span>):</span><br><span class="line">            dataHeader_s2c = &#123;&#125;</span><br><span class="line">            fileName=cmd.split(<span class="string">' '</span>)[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> os.path.isfile(fileName):</span><br><span class="line">                dataHeader_s2c[<span class="string">'status'</span>]=<span class="string">'Y'</span></span><br><span class="line">                dataHeader_s2c[<span class="string">'filename'</span>]=fileName</span><br><span class="line">                dataHeader_s2c[<span class="string">'size'</span>]=os.stat(fileName).st_size <span class="comment">#文件大小</span></span><br><span class="line">                conn.send((json.dumps(dataHeader_s2c)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">                conn.recv(<span class="number">1024</span>) <span class="comment">#防止粘包</span></span><br><span class="line">                md5=hashlib.md5()</span><br><span class="line">                <span class="keyword">with</span> open(fileName,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                        md5.update(line)</span><br><span class="line">                        conn.send(line)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        conn.recv(<span class="number">1024</span>)<span class="comment">#防止粘包</span></span><br><span class="line">                        conn.send(md5.hexdigest().encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dataHeader_s2c[<span class="string">'status'</span>]=<span class="string">'N'</span></span><br><span class="line">                conn.send((json.dumps(dataHeader_s2c)).encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><pre><code>命令处理：客户端首先接收用户输入的命令，如果输入为空则跳出本轮循环，进入下一轮循环，重新等待用户的输入，如果输入不为空则将输入的内容发送给服务器。服务器接收到数据之后也会判断这个内容是否为空，如果内容为空就会认为客户端已经断开链接，从而直接跳出这一层的循环，等待并处理下一个接入的客户端。可能大家会有疑问，我们在客户端已经检查了用户的输入，可以确保发送给服务器的数据不为空，在服务器端又做一遍这样的检查，有什么用呢？其实python的socket模块做了特殊的设计，当客户端进程退出之前，他会自动向服务器发送一个空消息。所以服务器就是依据这一点来判断客户端是否断开的。编码与解码：在python3中socket的发送和接收的都是字节，所以我们在发送数据之前要将我们的数据编码（encode）成字节的形式才能发送，同理我们在客户端接收到的数据也是字节形式，所以我们要将其解码（decode）成字符串.头数据：为了方便客户端接收数据（如什么时候数据可以接收完等），服务器端需要在真正发送数据之前先发送一些与客户端需要的文件相关的头数据，如文件的大小等信息，这里由于客户端并不是只做文件的下载处理，所以这里的头数据还包含了一些标志数据。这里是先将这些数据放入一个字典，然后序列化成json数据，到客户端之后在进行反序列化。粘包问题：有时候我们需要连续几次发送不同的数据，在客户端也要连续几次来分别接收这些信息。但是这个时候事情往往不是按照我们想象的那样进行的，可能服务器的连续几次发送的信息被客户端的一次接收给接收到了，这个问题叫做粘包。这显然不是我们希望得到的，我们需要解决这个问题。解决这个问题的思路就是将这些连续发送的数据让它不连续，比如我们让一次发送与下一次发送中间休息（sleep）几秒.但是这种方法显然是不对的，这会极大的降低数据传输的速度。实际上我们解决的方法是在两次连续的发送中间来一次接收，或者让接收方在接收的时候恰恰接收当次发送的那么多数据，我们上面采用的都是前一种方法。md5比对：为了判断在数据传输的过程中是否发生错误，我们还需要对发送过去的数据和原数据进行一个md5值比对，如果不一致我们就删掉破损的文件，提示用户重新下载。</code></pre><h3 id="操作远程主机命令"><a href="#操作远程主机命令" class="headerlink" title="操作远程主机命令"></a>操作远程主机命令</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    client.send(cmd.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    dateHeader_s2c = json.loads(client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    response_length=dateHeader_s2c[<span class="string">'size'</span>]</span><br><span class="line">    accept_length=<span class="number">0</span></span><br><span class="line">    accept_content=<span class="string">b''</span></span><br><span class="line">    client.send(<span class="string">b'ok'</span>)</span><br><span class="line">    <span class="keyword">while</span> accept_length&lt;response_length:</span><br><span class="line">        accept_temp = client.recv(<span class="number">1024</span>)</span><br><span class="line">        accept_length+=len(accept_temp)</span><br><span class="line">        accept_content+=accept_temp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(accept_content.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dataHeader_s2c = &#123;&#125;</span><br><span class="line">    res_content = os.popen(cmd).read()</span><br><span class="line">    <span class="keyword">if</span> len(res_content) == <span class="number">0</span>:</span><br><span class="line">        res_content = <span class="string">"命令没有返回内容"</span></span><br><span class="line">    dataHeader_s2c[<span class="string">'type'</span>] = <span class="string">'cmd'</span></span><br><span class="line">    dataHeader_s2c[<span class="string">'size'</span>] = len(res_content)</span><br><span class="line">    conn.send(json.dumps(dataHeader_s2c).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    conn.recv(<span class="number">1024</span>)</span><br><span class="line">    conn.send(res_content.encode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure><h4 id="需要注意的点-1"><a href="#需要注意的点-1" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><p>其实这个过程和前面的文件上传下载差不多，上面要注意的点，这里都要注意这里的主要实现其实就是python中的os模块中的操作操作系统的接口res_content = os.popen(cmd).read()，这一popen需要传输一个系统的命令（字符串），同时返回的是一个类似文件的对象，我们read它之后得到的就是命令返回的内容（字符串）</p><p>这里还有一些命令是运行不了的，或者说可以执行但无法返回命令的输出。</p><h1 id="我的demo"><a href="#我的demo" class="headerlink" title="我的demo"></a>我的demo</h1><p><a href="https://github.com/Andrewpqc/FakeSsh" target="_blank" rel="noopener">demo</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python socket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Socket.io和Express的聊天室</title>
      <link href="/2017/08/31/a-chatroom-based-on-Express-and-Socketio/"/>
      <url>/2017/08/31/a-chatroom-based-on-Express-and-Socketio/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h1><p>HTTP协议是无状态的，每次处理完客户端的一个(http/1.0)或几个(http/1.1)请求就会立即断开并且。这就导致很难实现客户端与服务器数据的实时同步。以往大家实现实时通信都是通过ajax长轮询，和long poll长连接两种方式。ajax长轮询就是客户端每隔很短的时间就去访问一次服务器，看服务器那里有没有新的数据，如果有就将数据渲染在页面上，没有就一段时间之后又发起相同的请求。如果发起请求的间隔时间够短，就可以给人造成一种实时通信的错觉。ajax请求是一种非阻塞的请求，渲染消息的时候不用重新加载页面，所以用户体验比较好。但是这样频繁的发请求，并且大多数请求是无用的，这对服务器和客户端都造成了巨大的资源浪费。long poll长连接和ajax轮询其实是差不多的,只不过是采用阻塞的方式，如果服务器现在还没有消息，那么就不返回response给他，导致客户端一直在等待,直到等到了消息才返回，返回后又发起一个http请求，又到服务器哪儿去等着。上面的两种方式其实都是客户端不断的发起http请求，服务器被动的接受请求并处理。他们都不是很好的处理这个问题的方式。这时h5中提出了Websocket协议。Websocket解决了下面的几个问题：<br>１．在客户端与服务器首次连接之后，客户端与服务器的地位就平等了，两者之间可以进行真正的全双工通信。不仅客户端可以发送请求给服务器，服务器也可以主动通知客户端了。也就是说客户端再也不用一次一次的到服务器那里去询问有没有新数据，或者傻傻的到服务器那里去等着，直接在有新数据的时候让服务器通知一下客户端就行了。<br>２．首次连接之后，客户端与服务器之间的通信不需要发送头信息了，提高了信息交换的效率。</p><h2 id="Websocket的细节"><a href="#Websocket的细节" class="headerlink" title="Websocket的细节"></a>Websocket的细节</h2><p>首先是客户端发送一个http请求给服务器，这个请求头中包含转换协议的数据，服务器接受到之后就会在之后本次会话的其他心意转为tcp,之后两者就是以tcp协议来交流的，而不是http.由于websocket的这种设计与原来的通过http协议运作的浏览器与服务器的架构有很大的不同，所以websocket的应用需要浏览器和服务器以及中间可能有的代理服务器的共同的支持。好在现在的主流的高版本的浏览器，和主流的高版本的服务器软件都已经支持了websocket这一协议，并且越来越多的产品都在慢慢的支持websocket.</p><h2 id="socket-IO库"><a href="#socket-IO库" class="headerlink" title="socket.IO库"></a>socket.IO库</h2><p>socket.IO是一个基于websocket的一个实时获取浏览器/客户端数据的库，他能够使开发者不必关心websocket底层的细节，而只需要关心自己的业务逻辑，顶层调用非常简单。并且，它还为不支持websocket协议的浏览器，提供了长轮询的透明模拟机制,它会自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用，非常方便和人性化，而且支持的浏览器最低达IE5.5。这使得在大部分情境下，你都能通过socket.io与浏览器保持类似长连接的功能。由于nodejs的单线程，异步I/O,事件驱动的特点，它非常适合编写websocket方面的应用。</p><h1 id="用socket-io和express打造聊天室"><a href="#用socket-io和express打造聊天室" class="headerlink" title="用socket.io和express打造聊天室"></a>用socket.io和express打造聊天室</h1><h2 id="下载socket-io"><a href="#下载socket-io" class="headerlink" title="下载socket.io"></a>下载socket.io</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install socket.io</span><br></pre></td></tr></table></figure><h2 id="服务器端代码"><a href="#服务器端代码" class="headerlink" title="服务器端代码"></a>服务器端代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express并实例化一个app</span></span><br><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line"><span class="comment">//socket.io需要原生node的http模块的支持</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//监听客户端的连接，并将连接传入socket</span></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line"><span class="comment">//当前连接的socket监听客户端的名为'c2s'的数据发送，并将接收到的数据传入msg</span></span><br><span class="line">        socket.on(<span class="string">'c2s'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//向所有的当前在线的客户端发送一个名为's2c'的广播</span></span><br><span class="line">                io.sockets.emit(<span class="string">'s2c'</span>, msg);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>聊天| 聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎你，<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">'username'</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>发布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'/socket.io/socket.io.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'/public/javascripts/plugin/jquery-1.12.4.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//创建一个sokeet对象，io()是上面的socket.io.js暴露给我们的一个函数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket=io.connect(<span class="string">'http://localhost'</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">//点击提交触发事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//判断输入框中是否有内容</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>($(<span class="string">'#content'</span>).val())&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//向服务器发送一个名为'c2s'的消息，后面的一个对象为消息的内容</span></span></span><br><span class="line"><span class="javascript">            socket.emit(<span class="string">"c2s"</span>,&#123;<span class="attr">user</span>:$(<span class="string">"#username"</span>).text(),<span class="attr">content</span>:$(<span class="string">'#content'</span>).val()&#125;);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//清空输入框</span></span></span><br><span class="line"><span class="javascript">                $(<span class="string">"#content"</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//如果输入框为空，则什么也不做</span></span></span><br><span class="line"><span class="undefined">            &#125; </span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//按下enter键触发事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#content"</span>).keydown(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>((e.keyCode===<span class="number">13</span>)&amp;&amp;($(<span class="string">'#content'</span>).val())&#123;</span></span><br><span class="line"><span class="javascript">                            socket.emit(<span class="string">"c2s"</span>,&#123;<span class="attr">user</span>:$(<span class="string">"#username"</span>).text(),<span class="attr">content</span>:$(<span class="string">'#content'</span>).val()&#125;);</span></span><br><span class="line"><span class="javascript">                            $(<span class="string">"#content"</span>).val(<span class="string">" "</span>);</span></span><br><span class="line"><span class="javascript">&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//啥也不做</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//监听服务器发出的's2c'消息，消息内容传入msg        </span></span></span><br><span class="line"><span class="javascript">            socket.on(<span class="string">'s2c'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//利用jQuery将消息渲染到页面上</span></span></span><br><span class="line"><span class="javascript">                  $(<span class="string">"#ul"</span>).prepend(<span class="string">"&lt;li&gt;&lt;b&gt;"</span>+msg.user+<span class="string">"&lt;/b&gt;说"</span>+msg.content+<span class="string">"&lt;/li&gt;"</span>)</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们的服务器跑起来之后,我们可以直接在浏览器中访问这样一个地址：127.0.0.1:3000/socket.io/socket.io.js,这时我们会发现这一个url已经被劫持了，页面中出现了一个js脚本。我们再回头看一看我们的项目文件夹中，并没有出现socket.io.js这样一个脚本。这个js文件实际放在了服务器端的node_modules文件夹中，在请求这个文件时会重定向，因此不要诧异服务器端不存在这个文件但为什么还能正常工作。其实你可以把服务器端的socket.io.js这个文件拷贝到本地，使它成为客户端的js文件，这样就不用每次都向服务器请求这个js文件，以增强稳定性。无论如何我们必须在客户端引用这个脚本才能使用socket.io的功能。从上面的代码看，群聊聊天室的原理是:某一个客户端需要发言，他就把自己的发言内容先发送到聊天室的服务器，然后由服务器对所有连接到服务器的客户端进行广播，这样其他用户就可以看到你的消息，这也就实现了群聊。</p><h2 id="socket-IO的使用"><a href="#socket-IO的使用" class="headerlink" title="socket.IO的使用"></a>socket.IO的使用</h2><p>从上面的聊天室的例子就可以发现，socket.io在使用上的核心其实就是两个函数emit()和on().<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit()</span><br></pre></td></tr></table></figure></p><p>用来发射一个事件或者说触发一个事件，第一个参数为事件名，第二个参数为要发送的数据，第三个参数为回调函数（一般省略，如需对方接受到信息后立即得到确认时，则需要用到回调函数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on()</span><br></pre></td></tr></table></figure><p>用来监听一个 emit 发射的事件，第一个参数为要监听的事件名，第二个参数为一个匿名函数用来接收对方发来的数据，该匿名函数的第一个参数为接收的数据，若有第二个参数，则为要返回的函数。</p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><h4 id="监听客户端的链接与断开"><a href="#监听客户端的链接与断开" class="headerlink" title="监听客户端的链接与断开"></a>监听客户端的链接与断开</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听客户端连接,回调函数会传递本次连接的socket</span></span><br><span class="line">io.on(‘connection’,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>));</span></span><br><span class="line"><span class="function">//监听客户端的断开连接,这里会传入"<span class="title">transport</span> <span class="title">close</span>"这个字符串到<span class="title">c</span>这个形参中</span></span><br><span class="line"><span class="function"><span class="title">socket</span>.<span class="title">on</span>(<span class="params"><span class="string">'disconnect'</span>,function(c</span>))</span></span><br></pre></td></tr></table></figure><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给所有的客户端广播消息(包含发送消息过来触发这个函数的那个客户端)</span></span><br><span class="line">io.sockets.emit(‘<span class="built_in">String</span>’,data);</span><br><span class="line">或　io.emit(<span class="string">'String'</span>,data);</span><br><span class="line"><span class="comment">//给客户端广播消息(除了该socket所属于的那个客户端)</span></span><br><span class="line">socket.boradcast.emit(<span class="string">'String'</span>,data)</span><br><span class="line"><span class="comment">//给指定的客户端发送消息</span></span><br><span class="line">io.sockets.socket(socketid).emit(‘<span class="built_in">String</span>’, data);</span><br><span class="line"><span class="comment">//给该socket的客户端发送消息</span></span><br><span class="line">socket.emit(‘<span class="built_in">String</span>’, data);</span><br></pre></td></tr></table></figure><h4 id="监听客户端的事件"><a href="#监听客户端的事件" class="headerlink" title="监听客户端的事件"></a>监听客户端的事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听该socket所属于的客户端的String消息，这里的String是自定义的消息名称</span></span><br><span class="line">socket.on(<span class="string">'String'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>))</span></span><br></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">socket.on(<span class="string">'group1'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">socket.join(<span class="string">'group1'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">'group2'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">socket.join(<span class="string">'group2'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上面的代码，当一个客户端链接进来之后，并且发送了一个名为group1的事件消息，那么在服务器端，它与服务器的socket就通过socket.join(‘group1’)加入了一个名为group1的分组中，客户端的代码可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">'text/javascript'</span> src=<span class="string">'/socket.io/socket.io.js'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*创建与服务器的连接，并且返回一个socket对象，这里由于是服务器和客户端到是在本地</span></span><br><span class="line"><span class="comment">*所以在connect()中可以不用传递值，如果是在生产环境这里就需要传值，如：</span></span><br><span class="line"><span class="comment">* socket.connect('localhost:3000')</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> socket=io.connect();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*发送一个名为group1的消息，就可以在服务器的处理中被加入group1组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">socket.emit(<span class="string">'group1'</span>,&#123;&#125;);</span><br></pre></td></tr></table></figure></p><p>一个用户可以存在与多个分组中</p><h4 id="踢出分组"><a href="#踢出分组" class="headerlink" title="踢出分组"></a>踢出分组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.leave(data.room)</span><br></pre></td></tr></table></figure><h4 id="向一个组广播消息"><a href="#向一个组广播消息" class="headerlink" title="向一个组广播消息"></a>向一个组广播消息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向一个组广播消息(发送者无法收到消息)，并且这一方法允许当前socket不在这一分组中</span></span><br><span class="line">socket.broadcast.to(<span class="string">'your group name'</span>).emit(<span class="string">'broadcast group message'</span>);</span><br><span class="line"><span class="comment">//向一个组广播消息(包括发送者都能收到消息),发送者必须在分组中</span></span><br><span class="line">io.sockets.in(<span class="string">'your group name'</span>).emit(<span class="string">'broadcast romm message'</span>)</span><br></pre></td></tr></table></figure><h4 id="获取连接的客户端socket"><a href="#获取连接的客户端socket" class="headerlink" title="获取连接的客户端socket"></a>获取连接的客户端socket</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.sockets.clients().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line"><span class="comment">//可以对其进行操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="获取分组信息"><a href="#获取分组信息" class="headerlink" title="获取分组信息"></a>获取分组信息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有的组别信息</span></span><br><span class="line">io.sockets.manager.rooms</span><br><span class="line"><span class="comment">//获取此socketid进入的组别信息</span></span><br><span class="line">io.sockets.manager.roomClients[socket.id]</span><br><span class="line"><span class="comment">//获取某一个房间中的客户端，返回所有在此房间的socket实例</span></span><br><span class="line">io.sockets.clients(<span class="string">'某组名'</span>)</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="建立socket链接"><a href="#建立socket链接" class="headerlink" title="建立socket链接"></a>建立socket链接</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket=io(<span class="string">'http://&lt;hostname&gt;:&lt;port&gt;'</span>);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">var</span> socket=io.connect(<span class="string">'http://&lt;hostname&gt;:&lt;port&gt;'</span>)</span><br></pre></td></tr></table></figure><p>如果是在本机做测试，客户端，服务器都在同一台主机上，则上面两个连接方式<br>的括号中可以不用写东西</p><h4 id="监听服务器的消息"><a href="#监听服务器的消息" class="headerlink" title="监听服务器的消息"></a>监听服务器的消息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'msg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="comment">//向服务器发送消息</span></span><br><span class="line">socket.emit(<span class="string">'msg_c2s'</span>,&#123;&#125;);</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure><h4 id="监听socket断开与重连"><a href="#监听socket断开与重连" class="headerlink" title="监听socket断开与重连"></a>监听socket断开与重连</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'disconnect'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'与服务器断开链接'</span>)；</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">'reconnect'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'重新链接到服务器'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述的’disconnect’,’reconnect’是socket.io默认支持的可以被客户端监听的事件，像这样的事件有：<br>connect：连接成功<br>connecting：正在连接<br>disconnect：断开连接<br>connect_failed：连接失败<br>error：错误发生，并且无法被其他事件类型所处理<br>message：同服务器端message事件<br>anything：同服务器端anything事件<br>reconnect_failed：重连失败<br>reconnect：成功重连<br>reconnecting：正在重连<br>当第一次连接时，事件触发顺序为：connecting-&gt;connect；当失去连接时，事件触发顺序为：disconnect-&gt;reconnecting（可能进行多次）-&gt;connecting-&gt;reconnect-&gt;connect</p><h1 id="我的demo"><a href="#我的demo" class="headerlink" title="我的demo"></a>我的demo</h1><p><a href="https://github.com/Andrewpqc/simpleChatroom" target="_blank" rel="noopener">demo</a></p>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket.io </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker容器操作</title>
      <link href="/2017/08/25/Docker-container-operation/"/>
      <url>/2017/08/25/Docker-container-operation/</url>
      
        <content type="html"><![CDATA[<p>前面总结了docker的镜像的基本操作,有了镜像之后我们就可以用这个镜像来运行容器了。</p><h1 id="docker的容器技术是什么？"><a href="#docker的容器技术是什么？" class="headerlink" title="docker的容器技术是什么？"></a>docker的容器技术是什么？</h1><p>以我极度不专业的话来讲，docker的容器技术就是一种数据虚拟化和数据隔离的技术，通过某个镜像，比如ubuntu，就可以在你的电脑上虚拟出来一台装了ubuntu系统的计算机，它里面有文件系统，有用户管理，文件的权限管理等等，你可以在里面下载软件，敲实体ubuntu中能够敲的绝大多数命令，并且他可以与外界的环境进行有效的隔离。虽然他无法完全模拟出物理机的所有功能，但是对于应用的部署，集群的构建，分布式系统的构建来说，他的功能已经够用。灵活高效，对物理机的低消耗是他的特点。</p><h1 id="Container-VS-Virtual-Machine"><a href="#Container-VS-Virtual-Machine" class="headerlink" title="Container VS Virtual Machine"></a>Container VS Virtual Machine</h1><p>与虚拟机相比Docker实现了轻量级虚拟化。<br><img src="/images/dockervsvm.png" alt="docker vs VM"></p><p>为什么不是虚拟机，而是Container呢？大家可能会讲，虚拟机的功能比Container的功能全，比如虚拟机可以虚拟出图形化操作，但是Container就不行。没错，同样作为一种数据虚拟化和数据隔离的技术，虚拟机在功能上比Container强的多，但是虚拟机的资源消耗，安装过程，存储空间的占用等都是惊人的。虚拟机中部署的应用，是依赖于虚拟机所安装的操作系统，虚拟机的操作系统又依赖于虚拟机引擎，而虚拟机引擎则依赖于其底层包和物理机的操作系统。而Container则不一样，在其中的应用直接依赖于docker引擎及其底层包，然后docker引擎则依赖于操作系统。两相对比，就可以发现，运行虚拟机比运行container要多占用一个操作系统的空间。更不用说物理机的操作系统要付出多大的代价了。最为重要的是，虚拟机的安装过程是及其繁琐和耗时的，这对于集群的构建来说是致命的。而对Container,只要一条命令即可安装docker,然后几条命令就可以跑起来一个容器，并且这个容器可以非常方便的移植到其他的主机上。</p><h1 id="容器操作的基本命令"><a href="#容器操作的基本命令" class="headerlink" title="容器操作的基本命令"></a>容器操作的基本命令</h1><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run IMAGE [COMMAND] [ARG…]</span><br></pre></td></tr></table></figure><p>IMAGE－－－－－镜像的名称，可以是镜像的唯一ＩＤ，也可以是repository:tag的形式<br>COMMAND－－－－－启动容器后运行的命令<br>ARG－－－－－命令的参数<br>比如下面以ubuntu为镜像，运行起来一个容器，并且在容器中运行/bin/bash(即打开容器的bash):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>运行完了之后我们发现容器直接退出了！？容器退出了，但是我们的命令确实执行了，容器运行了起来，bash也打开了，然后容器就退出了。可是这有什么用呢?我们需要容器一直打开，然后进行其他操作。请往下看。</p><h2 id="启动交互式容器"><a href="#启动交互式容器" class="headerlink" title="启动交互式容器"></a>启动交互式容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –i –t IMAGE /bin/bash</span><br></pre></td></tr></table></figure><p>-i –interactive=ture|false 默认为false 告诉docker的守护进程，为容器始终打开标准输入<br>-t –tty=ture|false 默认为false，告诉docker为容器分配一个伪tty终端</p><p>上面的命令让新创建的容器提供了一个交互式的shell 当然IMAGE里必须有bash才行。这条命令运行完了之后，我们就直接进入了这个容器的交互式运行环境，我们会发现我们终端中输入命令的前缀已经发生了变化。也就是说，现在你所输入的命令已经不是在你的物理机上执行的，而是在容器中执行的。你可以输入ls,ps 等你在物理机上常使用的命令，你会发现你就好像进入了另一台计算机的终端一样。最后你要想直接退出当前容器，请直接在容器中输入exit，这样你就退出了容器，回到了你的主机bash中。同时刚才的容器也就停止运行了</p><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps  查看当前还在运行的容器</span><br><span class="line">$ docker ps –a 查看系统中所有的容器</span><br><span class="line">$ docker ps –l   查看最近一次使用的容器</span><br></pre></td></tr></table></figure><h2 id="查看容器的详细信息"><a href="#查看容器的详细信息" class="headerlink" title="查看容器的详细信息"></a>查看容器的详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect NAME</span><br></pre></td></tr></table></figure><p>NAME既可以是docker ps 命令返回内容中的容器的CONTAINER ID也可以是最后一列中的NAME，该命令会返回该容器的详细信息。在将镜像的时候也提到过docker的inspect命令，inspect命令既可以查看容器也可以查看镜像，并且用法还相同。</p><h2 id="自定义容器名"><a href="#自定义容器名" class="headerlink" title="自定义容器名"></a>自定义容器名</h2><p>我们在上面查看容器的一些操作中会发现，有一列数据NAME,每一个容器都会对应一个NAME,这里的NAME非常没有规律，不便于记忆，就是一串随机的字符串。那是因为我们在运行这个容器的时候没有指定容器的名字，然后docker就分配了一个随机的名字给我们的容器。那么怎样制定容器的名字呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name　容器名 ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>看到没，就是这么简单，在刚才运行容器的命令上面再加一个–name的参数就可以指定容器名了。</p><h2 id="重新启动已经停止的容器"><a href="#重新启动已经停止的容器" class="headerlink" title="重新启动已经停止的容器"></a>重新启动已经停止的容器</h2><p>我们刚才用exit直接退出了容器，容器就停止运行了，假如我们又想进入这个容器，怎么办呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start [-i] 容器名</span><br></pre></td></tr></table></figure></p><p>-i 表示是否用交互的方式启动已经停止的容器</p><h2 id="删除已经停止的容器"><a href="#删除已经停止的容器" class="headerlink" title="删除已经停止的容器"></a>删除已经停止的容器</h2><p>又假如我们不想要这个容器了，想要删除他，可以下面这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm 容器名或ＩＤ</span><br></pre></td></tr></table></figure></p><p>这样这个容器就删除了，注意这个命令只能删除已经停止运行的容器</p><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><p>有时，需要将容器从一个系统迁移到另外一个系统，此时就可以使用docker的导入和导出功能。</p><h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，都可以使用docker export命令，示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> -o test.tar CONTAINER_ID</span><br><span class="line">或者：</span><br><span class="line">$ docker <span class="built_in">export</span> CONTAINER_ID &gt;test.tar</span><br></pre></td></tr></table></figure></p><p>之后可以将导出的tar文件传输到其他的机器上，然后通过导入命令导入到系统中，从而实现了容器的迁移。</p><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>导出的文件可以通过docker import命令导入变成镜像，下面将上面导出的test.tar文件导入到系统中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import test.tar - <span class="built_in">test</span>/ubuntu:v1.0</span><br></pre></td></tr></table></figure></p><p>完成后通过docker images命令就可以看到导入的test/ubuntu:v1.0镜像了。</p><h3 id="导入导出容器与导入导出镜像的区别"><a href="#导入导出容器与导入导出镜像的区别" class="headerlink" title="导入导出容器与导入导出镜像的区别"></a>导入导出容器与导入导出镜像的区别</h3><p>在docker image and repostory中讲过docker load命令来导入一个镜像文件，这与docker import命令十分相似。事实上既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。这两者之间的区别在于容器快照文件将丢失所有的历史记录和元数据信息（仅保存容器运行时的快照状态），而镜像存储文件将保存完整记录，体积也更大。</p><h2 id="docker的守护式容器"><a href="#docker的守护式容器" class="headerlink" title="docker的守护式容器"></a>docker的守护式容器</h2><p>我们在交互式容器中不要以exit 命令来退出，而是用Ctrl+Ｐ,Ctrl+Q来退出交互式容器，这时我们就得到了一个守护容器。这种方式退出与exit不同的是，用exit退出之后容器就停止了，而这种方式容器就会移入到后台运行，容器并未停止。<br>如果我们想要再次进入此在后台运行的容器的话，我们可以使用：updated:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach 容器名或ＩＤ</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 容器名或ＩＤ　/bin/bash</span><br></pre></td></tr></table></figure></p><p>这样我们就又可以进入其交互式环境中了。上面这两种进入守护式容器的命令稍有不同，后面会讲到。</p><p>除了通过交互式环境得到守护容器外，我们还通过run命令来启动一个守护式容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –d IMAGE [COMMAND] [ARG…]</span><br></pre></td></tr></table></figure><p>在run命令中加入-d这个选项之后，命令的执行被放在了后台。这样同样可以得到一个守护式容器。</p><h2 id="Log命令查看容器的日志"><a href="#Log命令查看容器的日志" class="headerlink" title="Log命令查看容器的日志"></a>Log命令查看容器的日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">log</span> [-f ] [-t ] [--tail] 容器名</span><br></pre></td></tr></table></figure><p>-f –follow=ture|false 默认为 false 跟踪日志的变化，并返回结果<br>-t –timestamps=ture|false 默认为false 给每条日志加上一个时间戳，及日志产生的时间<br>–tail 选择结尾处多少数量的日志，如果不指定，返回所有的日志</p><h2 id="查看运行中容器内的进程"><a href="#查看运行中容器内的进程" class="headerlink" title="查看运行中容器内的进程"></a>查看运行中容器内的进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker top 容器名</span><br></pre></td></tr></table></figure><h2 id="在已经运行的容器中启动新的进程"><a href="#在已经运行的容器中启动新的进程" class="headerlink" title="在已经运行的容器中启动新的进程"></a>在已经运行的容器中启动新的进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> [-i] [-t] [-d] 容器名 [COMMAND] [ARG…]</span><br></pre></td></tr></table></figure><p>虽然docker的理念是一个容器运行一种服务，但我们有时任然需要做一些监控，日志记录等服务，所以有时候我们还会在已经运行的容器中开启新的进程，上面的命令可以做到这一点，可以发现他与run命令非常像。</p><h2 id="停止守护式容器"><a href="#停止守护式容器" class="headerlink" title="停止守护式容器"></a>停止守护式容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 容器名</span><br><span class="line">$ docker <span class="built_in">kill</span> 容器名</span><br></pre></td></tr></table></figure><h2 id="attach和exec的区别"><a href="#attach和exec的区别" class="headerlink" title="attach和exec的区别"></a>attach和exec的区别</h2><p>刚刚我们讲到进入守护式容器有两种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach 容器名或ＩＤ</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 容器名或ＩＤ　/bin/bash</span><br></pre></td></tr></table></figure><p>他们之间有什么区别呢？他们有很大的区别，attach是进入前面的那个进程，并且进入你离开时的状态，而exec则是在容器内开启一个新的进程。虽然两条命令都可以进入到一个容器中去操作容器，但是我们还是有必要学会在什么时候用什么命令。如果我们一直以exec进入容器，并且在退出的时候是以ctrl+p,ctrl+q的方式退出的话，那么容器中开启的进程会逐渐的增多，这对资源是一个巨大的消耗，如果以exit退出当前的进程则可以避免这个问题。attach呢？貌似我们可以一直使用attach，其实不然。由于attach总是进入到同一个进程，如果那个进程由于运行个什么东西而被阻塞（比如uwsgi）那么你就无法再次进入到这个进程了，这个时候就该使用exec开启一个新线程。总而言之，明白两者之间的区别，根据不同的情况使用不同的命令，才是最好的。<br>对了，关于attach还有一个小问题。就是当使用attach进入时，容器中的命令提示符总是迟迟不出来，好像就是卡在哪儿似的。其实他已经进入了容器，只是不显示前面的命令提示符而已。这个时候我们可以敲一个ls或者是个其他的什么命令，就可以让命令行回归正常了。不知道这是不是docker的一个小bug呢？（我的系统环境是：4.10.0-32-generic，docker版本：Docker version 17.05.0-ce, build 89658be）</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker container </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker简介,安装及镜像基本操作</title>
      <link href="/2017/08/24/Docker-introduction-and-basic-operation/"/>
      <url>/2017/08/24/Docker-introduction-and-basic-operation/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/docker.jpeg" alt="docker"></p><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上.Docker容器完全使用沙箱机制，相互之间不会有任何接口。使用docker容器可以实现开发，测试，部署环境的一致化，缩短产品的开发周期。Docker是以Docker容器为资源分割和调度的基本单位，封装整个软件的运行时环境，为开发者和系统管理员设计的，用于构建，发布和运行分布式应用的平台。</p><p>docker是按照C/S架构设计而成，由docker客户端（docker client）,docker守护进程（docker doamonn,充当着server的角色，响应docker客户端的指令），docker　registry组成。docker里面还有两个重要的概念：镜像（image）与容器(container)。镜像是容器的基础。而docker的容器技术是基于Linux内核的namespace和cgroups实现的。两者分别实现了资源的隔离和限制。镜像存放在registry(注册服务器)中。</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="查看系统情况"><a href="#查看系统情况" class="headerlink" title="查看系统情况"></a>查看系统情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br></pre></td></tr></table></figure><p>Docker要求Ubuntu系统的内核版本高于３．１０。只有满足这一条件方可继续下面的步骤。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>上面的命令会下载并安装最新版本的docker</p><h2 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>如果docker安装成功，上面的命令就会在docker　hub的公共仓库中去拉取hello-world这个镜像，并且启动镜像，生成一个容器，执行容器中预设的命令，然后立即退出容器。如果在这条命令的输出结果中出现的是关于docker的相关说明的话，那么你就安装成功了。注意：这里我们一定要以超级用户的身份运行这一命令，如果运行上述命令时漏掉了sudo,则会报下面的错误：docker:Connot not connect to the docker deamon.Is the docker deamon runing on this host? See ”docker run –help”，要想解决这个问题，请往下看。</p><h2 id="在Docker用户组中添加自己"><a href="#在Docker用户组中添加自己" class="headerlink" title="在Docker用户组中添加自己"></a>在Docker用户组中添加自己</h2><p>默认情况下，我们在执行docker命令的时候都要开启超级用户的权限，也就是说，每条命令都要输入sudo,这显然太麻烦了。好在docker在安装的时候给我们的系统中建了一个名为docker的用户组，只要是用户组中的用户，就可以直接使用docker了。方法是运行下面的这条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo usermod -aG docker &lt;your name&gt;</span><br></pre></td></tr></table></figure></p><p>然后重启docker服务（$ sudo servire docker restart），注销,重新登录系统，这样以后输入dcoker命令就不用每次都输入sudo了。</p><h2 id="配置镜像加速服务"><a href="#配置镜像加速服务" class="headerlink" title="配置镜像加速服务"></a>配置镜像加速服务</h2><p>现在我们已经完全安装好了docker,但是如果要想愉快的使用docker的话，还需要配置镜像加速服务。默认情况下，我们在拉取镜像时是在docker　hub这一个仓库中拉取的，由于docker hub仓库在国外，所以在国内拉取镜像时，速度及其的慢（翻墙除外）。好在国内有docker hub的镜像，我们可以通过简单的配置docker守护进程的启动选项即可免费使用这一镜像加速服务了。具体的配置就不讲了，因为在daocloud的网站上有配置脚本，并且提供了获取和启动脚本的命令，大家只需要到daocloud的网站上复制下这条命令，然后粘贴到终端并回车即可配置好，之后我们拉取镜像就用的是国内的镜像仓库，不用翻墙速度也超快。<br>下面的是我在daocloud上复制下的linux版本的加速命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s</span><br></pre></td></tr></table></figure></p><p>大家在配置的时候最好不要直接抄我这个，还是自己到daocloud网站上去复制吧，在加速器中。因为还存在版本的升级问题。</p><h1 id="Docker镜像基本操作"><a href="#Docker镜像基本操作" class="headerlink" title="Docker镜像基本操作"></a>Docker镜像基本操作</h1><p>Docker镜像是一个只读的Docker容器模板，含有启动Docker容器所需文件系统结构及其内容，因此是启动Docker容器的基础。docker镜像的文件内容以及一些运行Docker容器的配置文件组成了Docker容器的静态文件系统运行环境——rootfs。可以这么理解，Docker镜像是Docker容器的静态视角，Docker容器是Dokcer镜像的运行状态。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>获取镜像的方式有两种：<br>１．在docker hub或某个私有镜像仓库中拉取镜像(即下载镜像到本地)。<br>２．自己在基础镜像的基础上构建镜像。<br>由于即使是自己构建镜像也需要一个镜像作为基础镜像，而这个基础镜像一般是从docker hub的公共仓库中拉取的。所以我们在这里讲如何在docker hub中拉取镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [OPTIONS] NAME [:TAG]</span><br></pre></td></tr></table></figure></p><p>常用选项OPTIONS:-a,–all-tags 会下载所有此仓库中的打了标签的镜像<br>如果拉取镜像的速度极慢，那么请参考docker的安装及基本概念中的镜像加速部分。</p><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p>其实我们一般在拉取镜像之前，会先以我们想要的镜像名字做一个搜索，然后更具搜索出来的信息来决定我们想要拉取的镜像。搜索的信息一般会包括这个镜像的星级，镜像是否为官方镜像以及此镜像的一个简短的描述。这些信息都可以作为我们拉取镜像的一个参考。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure></p><p>常用选项OPTIONS: –automated 只显示自动化构建出的镜像<br>         –no-trunc    不使用截断输出<br>         -s,–stars=0  规定显示结果的最低星级</p><p>由于构建镜像是docker中的一个非常重要的一部分，所以我在后面会专门写一篇博客来介绍。</p><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>我们不仅可以构建自己的镜像，还可以把我们构建的有适用性的高质量的镜像推送到docker hub上，贡献给社区的其他小伙伴(public)，或者自己保存(private),以便以后接着使用。说明:dockerhub的共公镜像存储服务是完全免费的。但仅支持每个用户一个私有仓库，如果你想保存更多的私有镜像的话，就可以使用docker hub的付费服务。在推送镜像之前，必须要有docker hub的账号。</p><p>命令行登录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login -p &lt;docker hub <span class="built_in">pwd</span> &gt; -u &lt;docker hub username&gt;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure></p><p>下面会提示你输入用户名和密码。<br>登录成功之后就可以推送自己的镜像了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push NAME[:TAG]</span><br></pre></td></tr></table></figure></p><p>成功之后，你可以登录docker hub,就可以看到这个镜像了，默认他是公开的，你可以把他转为私有。如果公开的话，你还可以在命令行搜索到你的镜像。当然，社区的其他人也可以搜索到。</p><p>这条命令并不会把整个镜像都提交上去，而是提交你在基础镜像的基础上所作出的修改的那一部分。</p><h2 id="tag命令添加镜像标签"><a href="#tag命令添加镜像标签" class="headerlink" title="tag命令添加镜像标签"></a>tag命令添加镜像标签</h2><p>为了方便在后续工作中使用特定的镜像，可以使用docker tag命令来为本地镜像任意添加新的标签，例如将ubuntu:latest打上标签：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest myubuntu:latest</span><br></pre></td></tr></table></figure></p><p>当我们使用docker images列出本地主机上的镜像信息的时候，可以看到多了一个拥有myubuntu:latest标签的镜像，之后我们就可以直接使用myubuntu:latest来表示这个镜像了。尝试一下就可以发现，打上新标签的镜像与原来的镜像的id是一样的，加入我们要删除原镜像ubuntu:latest,那么myubuntu:latest也就跟着不见了。事实上打上新的标签并没有复制一个新的镜像，实际上只是给原镜像去了一个别名而已，他们实际指向的是同一个镜像，docker tag命令添加的标签实际上起到了类似链接的作用。</p><h2 id="镜像历史"><a href="#镜像历史" class="headerlink" title="镜像历史"></a>镜像历史</h2><p>镜像文件由多个层组成，我们可以通过history子命令来查看各个层的创建信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> ubuntu:latest</span><br></pre></td></tr></table></figure></p><h2 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h2><p>如果要导出镜像到本地文件，可以使用docker save命令，例如：导出本地的ubuntu:latest镜像为文件ubuntu_latest.tar,使用如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o ubuntu_latest ubuntu:latest</span><br></pre></td></tr></table></figure></p><p>之后就可以通过复制ubuntu_latest.tar文件将该镜像分享给别人。</p><h2 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h2><p>可以使用docker load将导出的tar文件再导入到本地镜像库，例如从文件ubuntu_latest.tar导入镜像到本地镜像列表，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker load --input ubuntu_latest.tar</span><br><span class="line">或者：</span><br><span class="line">$ docker load &lt; ubuntu_latest.tar</span><br></pre></td></tr></table></figure></p><p>这将导入镜像及其相关的元数据信息(包括标签等)</p><h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images [OPTIONS] [REPOSITORY]</span><br></pre></td></tr></table></figure><p>上面的命令会列出我们系统中已经有的镜像，有下面这些条件：<br>　　　　　OPTIONS: -a,–all=false 默认为false,为true时会显示所有的镜像，包括中间层镜像<br>-f,–filter=[] 默认不过滤某个镜像<br>-q,–quit=false 为true时只显示镜像的唯一ＩＤ<br>REPOSITORY:　仓库名，制定要显示那个仓库的镜像</p><h2 id="查看镜像的详细信息"><a href="#查看镜像的详细信息" class="headerlink" title="查看镜像的详细信息"></a>查看镜像的详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect [OPTIONS] IMAGE [IMAGE2.....]</span><br></pre></td></tr></table></figure><p>docker的inspect命令可以输出所查看镜像的完整的详细的信息。其实这个命令也可以用来查看容器的信息。</p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi [OPTIONS] IMAGE [IMAGE2….]</span><br></pre></td></tr></table></figure><p>个选项会删除所指定的一个或多个镜像<br>OPTIONS: -f,–force 强制删除镜像<br>有时候我们想要删除某个仓库中的所有镜像，如过使用上面的这条命令的话就太麻烦了，这是我们可以使用下面这条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images –q ubuntu)</span><br></pre></td></tr></table></figure></p><p>上面的命令删除了ubuntu仓库中的所有镜像，$ docker images -q ubuntu 这条命令就会输出ubuntu仓库中的所有镜像的唯一id,而输出结果更好作为docker rmi命令的参数了。</p><h1 id="正确区分registry和repository"><a href="#正确区分registry和repository" class="headerlink" title="正确区分registry和repository"></a>正确区分registry和repository</h1><p>Repository：仓库，一个repository里面存放的着相同种类不同标签的镜像，比如Tomcat下面有很多个版本的镜像，它们共同组成了Tomcat的Repository。粗浅的理解：比如一个基础镜像ubuntu分别制作成了各种不同的功能，而打上了不同的标签，这样每一个镜像就是不同的镜像，而他们都共同组成了ubuntu的repository</p><p>Registry：镜像注册服务器，比如DockerHub网站就是一个registry,Registry上有很多的Repository，Redis、Tomcat、MySQL等等Repository组成了Registry。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> install Docker </tag>
            
            <tag> Docker images </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
